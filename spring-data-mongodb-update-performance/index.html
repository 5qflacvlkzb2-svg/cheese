
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Yun Blog">
    <title>MongoDB Update 성능 측정 및 분석 - Yun Blog</title>
    <meta name="author" content="Yun">
    
        <meta name="keywords" content="Node,Spring,Spring Boot,Spring Batch,Kotlin,기술 블로그,JPA,Mongo,MySQL,OOP,">
    
    
    
        
            <link rel="alternate" type="application/rss+xml" title="RSS" href="/rss2.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg"},"articleBody":"MongoDB는 현대 웹 애플리케이션에서 널리 사용되는 NoSQL 데이터베이스입니다. 특히, Spring Data MongoDB는 Java 개발자에게 친숙하고 효율적인 방법으로 MongoDB와의 상호작용을 가능하게 합니다. 이번 포스팅에서는 Spring Data MongoDB를 사용하여 데이터를 업데이트하는 여러 방법의 성능을 비교하고 분석합니다. 특히, saveAll, updateFirst, bulkOps(UNORDERED), bulkOps(ORDERED) 이 네 가지 방법에 대해 깊이 있게 살펴보겠습니다.\nUpdate CodeDocument123456789101112131415161718192021222324@Document(collection = &quot;members&quot;)class Member(    // .. 대략 11개 필드들 존재    @Field(name = &quot;name&quot;)    var name: String) : Auditable()abstract class Auditable &#123;    @Id    var id: ObjectId? = null        internal set    @Field(name = &quot;created_at&quot;)    @CreatedDate    open lateinit var createdAt: LocalDateTime        internal set    @Field(name = &quot;updated_at&quot;)    @LastModifiedDate    open lateinit var updatedAt: LocalDateTime        internal set&#125;\n\n이 코드는 Kotlin을 사용하여 MongoDB 문서에 대해 정의된 Member 클래스를 나타냅니다. 이 클래스에는 대략 11개의 필드가 정의되어 있으며, 테스트에 사용될 주요 필드는 name입니다. 이 Member 클래스는 Auditable 추상 클래스를 상속받아, MongoDB 문서의 생성 및 수정 시간을 자동으로 추적합니다. 테스트 과정에서는 name 필드만을 대상으로 업데이트 작업을 수행하고 성능을 평가할 예정입니다. 이를 통해 MongoDB에서 단일 필드 업데이트의 성능을 파악하고자 합니다.\nsaveAll1234fun updateSaveAll(members: List&lt;Member&gt;) &#123;    // name 필드만 UUID.randomUUID().toString() 으로 업데이트     memberRepository.saveAll(members)&#125;\n\nsaveAll 메서드는 Spring Data MongoDB의 CrudRepository 인터페이스에서 제공하는 메서드로, 여러 개의 문서를 데이터베이스에 저장하거나 업데이트하는 데 사용됩니다. 동작 방식은 다음과 같습니다.\n\nID 존재 여부에 따른 동작: saveAll 메서드는 전달된 Member 객체 리스트를 순회하면서 각 객체의 id 필드를 확인합니다.\nID가 없는 경우 (Insert): Member 객체에 id 필드가 null이거나 존재하지 않으면, 해당 객체는 새로운 문서로 간주되어 데이터베이스에 삽입됩니다.\nID가 있는 경우 (Update): 이미 id 필드가 있는 Member 객체는 해당 id를 가진 기존 문서를 업데이트합니다.\n\n\n일괄 처리: 여러 객체를 포함하는 리스트를 한 번에 데이터베이스에 저장하거나 업데이트할 수 있는 이점이 있습니다.\n\n이번 테스트에서는 saveAll 메서드를 사용하여 Member 객체의 name 필드를 업데이트하는 데 집중합니다. 테스트에 사용되는 모든 Member 객체는 이미 id를 가지고 있으므로, 이 메서드는 모든 객체를 데이터베이스에 업데이트하는 작업으로 처리합니다. 이를 통해 saveAll 메서드가 대량의 업데이트 작업을 얼마나 효과적으로 처리할 수 있는지 성능을 평가하고자 합니다.\nupdateFirst1234567fun updateFirst(id: ObjectId): UpdateResult &#123;    return mongoTemplate.updateFirst(        Query(Criteria.where(&quot;_id&quot;).`is`(id)),        Update().set(&quot;name&quot;, UUID.randomUUID().toString()),        Member::class.java    )&#125;\n\nupdateFirst 메서드는 Spring Data MongoDB의 MongoTemplate을 사용하여 특정 조건을 만족하는 첫 번째 문서를 업데이트하는 기능을 제공합니다. 이 메서드는 주어진 쿼리에 따라 데이터베이스 내에서 일치하는 첫 번째 문서를 찾아 해당 필드를 업데이트합니다. 동작 방식은 다음과 같습니다.\n\n쿼리 매칭: updateFirst는 Query 객체를 사용하여 업데이트할 문서를 찾습니다. 이 예제에서는 Criteria.where(&quot;_id&quot;).is(id)를 통해 특정 id 값을 가진 문서를 찾습니다.\n업데이트 내용 지정: Update 객체를 사용하여 업데이트할 내용을 지정합니다. 여기서는 name 필드를 새롭게 생성된 무작위 UUID 문자열로 설정합니다.\n첫 번째 일치 문서 업데이트: 쿼리에 일치하는 첫 번째 문서만 업데이트됩니다. 만약 일치하는 문서가 없으면 업데이트는 수행되지 않습니다.\n결과 반환: 메서드는 UpdateResult를 반환하여 업데이트 작업의 결과를 나타냅니다. 이를 통해 몇 개의 문서가 영향을 받았는지 확인할 수 있습니다.\n\n이번 테스트에서는 updateFirst 메서드를 사용하여 Member 클래스의 name 필드를 업데이트합니다. 테스트는 특정 id를 가진 Member 문서를 대상으로 하며, 이 메서드는 해당 문서의 name 필드를 새로운 값으로 업데이트합니다. 이 방법을 통해 updateFirst 메서드의 단일 문서 업데이트 성능을 평가하고자 합니다.\nbulkOps12345678910111213fun updateBulk(    ids: List&lt;ObjectId&gt;,    bulkMode: BulkOperations.BulkMode = BulkOperations.BulkMode.UNORDERED // or BulkOperations.BulkMode.ORDERED): BulkWriteResult &#123;    val bulkOps = mongoTemplate.bulkOps(bulkMode, Member::class.java)    for (id in ids) &#123;        bulkOps.updateOne(            Query(Criteria.where(&quot;_id&quot;).`is`(id)),            Update().set(&quot;name&quot;, UUID.randomUUID().toString())        )    &#125;    return bulkOps.execute()&#125;\n\nbulkOps 메서드는 Spring Data MongoDB의 MongoTemplate을 사용하여 대량의 업데이트 작업을 효율적으로 처리하는 방법을 제공합니다. bulkOps는 한 번의 연산으로 여러 업데이트 작업을 모아서 실행할 수 있으며, BulkMode에 따라 순서대로(ORDERED) 또는 순서에 구애받지 않고(UNORDERED) 실행할 수 있습니다. 동작 방식은 다음과 같습니다.\n\nBulk Operations 설정: bulkOps는 주어진 BulkMode와 문서 클래스(Member::class.java)를 기반으로 초기화됩니다.\n업데이트 작업 추가: updateOne 메서드를 사용하여 각 id에 대한 업데이트 작업을 추가합니다. 여기서는 name 필드를 새로운 무작위 UUID 문자열로 설정합니다.\nBulk 작업 실행: execute 메서드를 호출하여 누적된 모든 업데이트 작업을 한 번에 실행합니다.\n결과 반환: 메서드는 BulkWriteResult를 반환하여 대량 업데이트 작업의 결과를 나타냅니다.\n\n이번 테스트에서는 bulkOps 메서드를 사용하여 Member 클래스의 name 필드를 대량으로 업데이트합니다. 여러 id를 가진 Member 문서에 대해 각각 name 필드를 새로운 값으로 업데이트하는 작업을 모아 한 번에 실행합니다. 이 방법을 통해 bulkOps 메서드의 대량 업데이트 성능과 UNORDERED와 ORDERED 모드 간의 성능 차이를 평가하고자 합니다.\nBulkMode 차이점:\nBulkOperations.BulkMode.UNORDERED:\n\n작업들이 순서에 구애받지 않고 병렬적으로 처리됩니다.\n성능 측면에서 더 효율적일 수 있으나, 하나의 작업 실패가 다른 작업에 영향을 미치지 않습니다.\n대량의 독립적인 작업을 빠르게 처리해야 할 때 유용합니다.\n\n\nBulkOperations.BulkMode.ORDERED:\n\n작업들이 추가된 순서대로 처리됩니다.\n하나의 작업이 실패하면 그 이후의 작업은 실행되지 않을 수 있습니다.\n작업들 간의 순서가 중요한 경우에 적합합니다.\n\n\n\n성능 측정 결과\n\n\n\nrows\nsaveAll\nupdateFirst\nbulkOps(UNORDERED)\nbulkOps(ORDERED)\n\n\n\n100\n1,052 ms\n1,176 ms\n46 ms\n79 ms\n\n\n200\n2,304 ms\n2,196 ms\n103 ms\n124 ms\n\n\n500\n5,658 ms\n5,250 ms\n309 ms\n257 ms\n\n\n1,000\n11,106 ms\n10,846 ms\n418 ms\n412 ms\n\n\n2,000\n22,592 ms\n21,427 ms\n1,060 ms\n1,004 ms\n\n\n5,000\n54,407 ms\n52,075 ms\n2,663 ms\n2,292 ms\n\n\n10,000\n107,651 ms\n110,884 ms\n4,514 ms\n4,496 ms\n\n\n결과는 saveAll, updateFirst, bulkOps(UNORDERED), bulkOps(ORDERED) 네 가지 방법에 대해 다양한 행(rows) 수에 따라 수행 시간(밀리초)을 비교합니다.\n분석 결과:saveAll과 updateFirst\n이 두 방법은 유사한 성능을 보입니다. 행의 수가 증가함에 따라 수행 시간이 선형적으로 증가하는 경향을 보이며, 대량의 데이터를 처리할 때 상대적으로 높은 지연 시간을 가집니다.\nsaveAll과 updateFirst 메서드의 성능 차이는 유의미하지 않습니다. 따라서, 상대적으로 데이터 양이 적은 경우에는 upsert 기능을 제공하는 saveAll을 사용하여 로직을 단순화할 수 있습니다.\n예제 코드에서는 updateFirst 메서드를 사용하여 기본 키(PK)를 기반으로 업데이트를 수행했습니다. 그러나 다른 키 값으로 조회를 진행할 경우, 조회 속도가 느려져 성능 차이가 발생할 수 있습니다.\nsaveAll 메서드는 Member 객체의 모든 변경 사항을 반영합니다. 따라서, 특정 필드만을 명확하게 업데이트하고자 할 때는 updateFirst와 같은 메서드를 사용하여 정확한 업데이트 쿼리를 작성하는 것이 좋은 대안이 될 수 있습니다. 이 방법은 업데이트하고자 하는 필드를 직접 지정할 수 있어, 더 세밀한 데이터 업데이트 제어가 가능합니다.\n\nbulkOps(UNORDERED)와 bulkOps(ORDERED)\n이 방법들은 saveAll과 updateFirst에 비해 현저히 빠른 성능을 보입니다. 특히 bulkOps(UNORDERED)는 가장 빠른 처리 시간을 나타냅니다.\nbulkOps(UNORDERED)는 순서에 구애받지 않고 여러 작업을 동시에 처리할 수 있기 때문에, 대량의 데이터 처리에 더 효율적이며, 개별 작업들이 독립적으로 처리됩니다. 이는 특정 작업이 실패해도 다른 작업들에 영향을 주지 않는다는 것을 의미합니다.\nbulkOps(ORDERED)도 비교적 빠른 성능을 보이지만, bulkOps(UNORDERED)에 비해 약간 느린 경향이 있습니다. 이는 작업을 순서대로 처리해야 하는 부가적인 비용 때문 이며, 순차적으로 작업이 진행되기 때문에 한 작업이 실패하면 그 이후의 작업은 실행되지 않을 수 있습니다.\nbulkOps(UNORDERED)와 bulkOps(ORDERED) 방식은 10,000개의 데이터 모수까지는 큰 성능 차이가 나타나지 않았습니다. 그러나 데이터가 많은 노드에 분산되어 저장된 경우, 이 두 방식 사이에서 더 유의미한 성능 차이가 발생할 수 있습니다. 분산 환경에서는 데이터의 위치와 네트워크 지연이 성능에 영향을 미칠 수 있으며, 이러한 조건에서는 bulkOps(UNORDERED)와 bulkOps(ORDERED)의 처리 방식 차이가 더 명확하게 드러날 가능성이 있습니다.\n\n결론\n소량의 데이터를 업데이트할 때는 saveAll과 updateFirst 메서드가 적합할 수 있습니다. 하지만 데이터 양이 많아질수록 이 두 방법의 성능은 상대적으로 감소합니다. 데이터 모수가 적은 경우, saveAll과 updateFirst 각각의 장단점이 있으므로, 특정 환경과 요구사항에 맞게 적절한 메서드를 선택하는 것이 중요합니다.\n대량의 데이터 처리에는 bulkOps 메서드 사용이 효율적입니다. bulkOps(UNORDERED)와 bulkOps(ORDERED) 각각의 장단점이 존재하므로, 이 두 방식 중에서는 특정 환경과 요구사항에 맞게 적절한 옵션을 선택하는 것이 중요합니다.\n\n이러한 결과는 MongoDB 데이터 업데이트 전략을 선택할 때 중요한 고려 사항을 제공합니다. 데이터의 양, 업데이트의 복잡성, 순서의 중요성 등을 고려하여 적절한 방법을 선택할 필요가 있습니다.\nbulkOps 편의 기능 제공이전 포스팅인 Spring Data MongoDB Repository 확장에서는 MongoCustomRepositorySupport를 사용해 MongoRepository에 편의 기능을 추가하고, 보일러플레이트 코드를 줄이는 방법을 소개했습니다. 이 방법은 코드의 재사용성을 높이는 효과가 있습니다. 마찬가지로, bulkOps와 같은 반복적인 코드도 MongoCustomRepositorySupport에 통합함으로써 더 편리하게 기능을 제공할 수 있습니다. 이렇게 하면 bulkOps 관련 코드를 중앙화하여 관리 및 사용의 용이성을 향상시킬 수 있습니다.\nMongoCustomRepositorySupport을 통한 bulkOps 기능 제공1234567891011121314151617181920212223242526272829303132333435363738394041424344abstract class MongoCustomRepositorySupport&lt;T&gt;(    protected val documentClass: Class&lt;T&gt;,    protected val mongoTemplate: MongoTemplate) &#123;    protected fun bulkUpdate(        operations: List&lt;Pair&lt;() -&gt; Query, () -&gt; Update&gt;&gt;, // Query와 Update 생성자를 위한 람다 리스트        bulkMode: BulkOperations.BulkMode    ): BulkWriteResult &#123;        // BulkOperations 객체를 생성합니다.        val bulkOps = mongoTemplate.bulkOps(bulkMode, documentClass)        // 제공된 리스트를 반복하면서 bulk 연산에 각 update를 추가합니다.        operations.forEach &#123; (queryCreator, updateCreator) -&gt;            bulkOps.updateOne(queryCreator.invoke(), updateCreator.invoke())        &#125;        // 모든 업데이트를 실행합니다.        return bulkOps.execute()    &#125;&#125;class MemberCustomRepositoryImpl(mongoTemplate: MongoTemplate) : MemberCustomRepository,    MongoCustomRepositorySupport&lt;Member&gt;(        Member::class.java,        mongoTemplate    ) &#123;    override fun updateName(listOf: List&lt;Pair&lt;() -&gt; Query, () -&gt; Update&gt;&gt;, bulkMode: BulkOperations.BulkMode) &#123;        bulkUpdate(listOf, bulkMode)    &#125;&#125;fun `updateNmae 사용하는 곳`(pairs: List&lt;Pair&lt;() -&gt; Query, () -&gt; Update&gt;&gt;, bulkMode: BulkOperations.BulkMode) &#123;    val pair = listOf(        Pair(            first = &#123; Query(Criteria.where(&quot;_id&quot;).`is`(ObjectId(&quot;id&quot;))) &#125;,            second = &#123; Update().set(&quot;name&quot;, UUID.randomUUID().toString()) &#125;        )    )    memberRepository.updateName(pair, BulkOperations.BulkMode.UNORDERED)&#125;\n\n코드는 외부에서 정의된 쿼리와 업데이트 로직을 사용하여 데이터 업데이트를 수행합니다. 코드는 Pair 리스트를 통해 각 업데이트 작업에 필요한 Query와 Update 객체를 정의하고, 이를 memberRepository의 updateName 메서드에 전달하여 BulkOperations.BulkMode.UNORDERED 모드로 업데이트를 진행합니다. 이 방식은 업데이트 과정을 유연하게 처리할 수 있게 해줍니다.\n","dateCreated":"2023-12-17T00:00:00+09:00","dateModified":"2025-01-31T04:41:33+09:00","datePublished":"2023-12-17T00:00:00+09:00","description":"MongoDB는 현대 웹 애플리케이션에서 널리 사용되는 NoSQL 데이터베이스입니다. 특히, Spring Data MongoDB는 Java 개발자에게 친숙하고 효율적인 방법으로 MongoDB와의 상호작용을 가능하게 합니다.","headline":"MongoDB Update 성능 측정 및 분석","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://cheese10yun.github.io/spring-data-mongodb-update-performance/"},"publisher":{"@type":"Organization","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg","logo":{"@type":"ImageObject","url":"yun-icon.jpg"}},"url":"https://cheese10yun.github.io/spring-data-mongodb-update-performance/","keywords":"Performance, Mongo"}</script>
    <meta name="description" content="MongoDB는 현대 웹 애플리케이션에서 널리 사용되는 NoSQL 데이터베이스입니다. 특히, Spring Data MongoDB는 Java 개발자에게 친숙하고 효율적인 방법으로 MongoDB와의 상호작용을 가능하게 합니다.">
<meta property="og:type" content="blog">
<meta property="og:title" content="MongoDB Update 성능 측정 및 분석">
<meta property="og:url" content="https://cheese10yun.github.io/spring-data-mongodb-update-performance/index.html">
<meta property="og:site_name" content="Yun Blog">
<meta property="og:description" content="MongoDB는 현대 웹 애플리케이션에서 널리 사용되는 NoSQL 데이터베이스입니다. 특히, Spring Data MongoDB는 Java 개발자에게 친숙하고 효율적인 방법으로 MongoDB와의 상호작용을 가능하게 합니다.">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/5fc6127a0800ca9bce5de5a6c73931b2025b0791/mongo-study/images/performance-update.png">
<meta property="article:published_time" content="2023-12-16T15:00:00.000Z">
<meta property="article:modified_time" content="2025-01-30T19:41:33.914Z">
<meta property="article:author" content="Yun">
<meta property="article:tag" content="Performance">
<meta property="article:tag" content="Mongo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/5fc6127a0800ca9bce5de5a6c73931b2025b0791/mongo-study/images/performance-update.png">
    
    
        
    
    
        <meta property="og:image" content="https://cheese10yun.github.io/assets/images/yun-icon.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90907312-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-90907312-1');
    </script>


    

    
        
    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5813739623204880" crossorigin="anonymous"></script>
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="5">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Yun Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="링크 열기: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="5">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="저자에 대해 더 알아보기"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
                </a>
                <h4 class="sidebar-profile-name">Yun</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기술 블로그</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="카테고리"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">카테고리</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="태그"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="아카이브"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">아카이브</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="검색"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">검색</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/cheese10yun"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/rss2.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="5"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            MongoDB Update 성능 측정 및 분석
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2023-12-17T00:00:00+09:00">
	
		    2023/12/17
    	
    </time>
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>MongoDB는 현대 웹 애플리케이션에서 널리 사용되는 NoSQL 데이터베이스입니다. 특히, Spring Data MongoDB는 Java 개발자에게 친숙하고 효율적인 방법으로 MongoDB와의 상호작용을 가능하게 합니다. 이번 포스팅에서는 Spring Data MongoDB를 사용하여 데이터를 업데이트하는 여러 방법의 성능을 비교하고 분석합니다. 특히, saveAll, updateFirst, bulkOps(UNORDERED), bulkOps(ORDERED) 이 네 가지 방법에 대해 깊이 있게 살펴보겠습니다.</p>
<h2 id="Update-Code"><a href="#Update-Code" class="headerlink" title="Update Code"></a>Update Code</h2><h3 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document(collection = <span class="string">&quot;members&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span>(</span><br><span class="line"></span><br><span class="line">    <span class="comment">// .. 대략 11개 필드들 존재</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = <span class="string">&quot;name&quot;</span>)</span></span><br><span class="line">    <span class="keyword">var</span> name: String</span><br><span class="line">) : Auditable()</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Auditable</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">var</span> id: ObjectId? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = <span class="string">&quot;created_at&quot;</span>)</span></span><br><span class="line">    <span class="meta">@CreatedDate</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> createdAt: LocalDateTime</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = <span class="string">&quot;updated_at&quot;</span>)</span></span><br><span class="line">    <span class="meta">@LastModifiedDate</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> updatedAt: LocalDateTime</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이 코드는 Kotlin을 사용하여 MongoDB 문서에 대해 정의된 <code>Member</code> 클래스를 나타냅니다. 이 클래스에는 대략 11개의 필드가 정의되어 있으며, 테스트에 사용될 주요 필드는 <code>name</code>입니다. 이 <code>Member</code> 클래스는 <code>Auditable</code> 추상 클래스를 상속받아, MongoDB 문서의 생성 및 수정 시간을 자동으로 추적합니다. 테스트 과정에서는 <code>name</code> 필드만을 대상으로 업데이트 작업을 수행하고 성능을 평가할 예정입니다. 이를 통해 MongoDB에서 단일 필드 업데이트의 성능을 파악하고자 합니다.</p>
<h3 id="saveAll"><a href="#saveAll" class="headerlink" title="saveAll"></a>saveAll</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">updateSaveAll</span><span class="params">(members: <span class="type">List</span>&lt;<span class="type">Member</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// name 필드만 UUID.randomUUID().toString() 으로 업데이트 </span></span><br><span class="line">    memberRepository.saveAll(members)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>saveAll</code> 메서드는 Spring Data MongoDB의 <code>CrudRepository</code> 인터페이스에서 제공하는 메서드로, 여러 개의 문서를 데이터베이스에 저장하거나 업데이트하는 데 사용됩니다. 동작 방식은 다음과 같습니다.</p>
<ol>
<li><strong>ID 존재 여부에 따른 동작</strong>: <code>saveAll</code> 메서드는 전달된 <code>Member</code> 객체 리스트를 순회하면서 각 객체의 <code>id</code> 필드를 확인합니다.<ul>
<li><strong>ID가 없는 경우 (Insert)</strong>: <code>Member</code> 객체에 <code>id</code> 필드가 <code>null</code>이거나 존재하지 않으면, 해당 객체는 새로운 문서로 간주되어 데이터베이스에 삽입됩니다.</li>
<li><strong>ID가 있는 경우 (Update)</strong>: 이미 <code>id</code> 필드가 있는 <code>Member</code> 객체는 해당 <code>id</code>를 가진 기존 문서를 업데이트합니다.</li>
</ul>
</li>
<li><strong>일괄 처리</strong>: 여러 객체를 포함하는 리스트를 한 번에 데이터베이스에 저장하거나 업데이트할 수 있는 이점이 있습니다.</li>
</ol>
<p>이번 테스트에서는 <code>saveAll</code> 메서드를 사용하여 <code>Member</code> 객체의 <code>name</code> 필드를 업데이트하는 데 집중합니다. 테스트에 사용되는 모든 <code>Member</code> 객체는 이미 <code>id</code>를 가지고 있으므로, 이 메서드는 모든 객체를 데이터베이스에 업데이트하는 작업으로 처리합니다. 이를 통해 <code>saveAll</code> 메서드가 대량의 업데이트 작업을 얼마나 효과적으로 처리할 수 있는지 성능을 평가하고자 합니다.</p>
<h3 id="updateFirst"><a href="#updateFirst" class="headerlink" title="updateFirst"></a>updateFirst</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">updateFirst</span><span class="params">(id: <span class="type">ObjectId</span>)</span></span>: UpdateResult &#123;</span><br><span class="line">    <span class="keyword">return</span> mongoTemplate.updateFirst(</span><br><span class="line">        Query(Criteria.<span class="keyword">where</span>(<span class="string">&quot;_id&quot;</span>).`<span class="keyword">is</span>`(id)),</span><br><span class="line">        Update().<span class="keyword">set</span>(<span class="string">&quot;name&quot;</span>, UUID.randomUUID().toString()),</span><br><span class="line">        Member::<span class="keyword">class</span>.java</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>updateFirst</code> 메서드는 Spring Data MongoDB의 <code>MongoTemplate</code>을 사용하여 특정 조건을 만족하는 첫 번째 문서를 업데이트하는 기능을 제공합니다. 이 메서드는 주어진 쿼리에 따라 데이터베이스 내에서 일치하는 첫 번째 문서를 찾아 해당 필드를 업데이트합니다. 동작 방식은 다음과 같습니다.</p>
<ol>
<li><strong>쿼리 매칭</strong>: <code>updateFirst</code>는 <code>Query</code> 객체를 사용하여 업데이트할 문서를 찾습니다. 이 예제에서는 <code>Criteria.where(&quot;_id&quot;).is(id)</code>를 통해 특정 <code>id</code> 값을 가진 문서를 찾습니다.</li>
<li><strong>업데이트 내용 지정</strong>: <code>Update</code> 객체를 사용하여 업데이트할 내용을 지정합니다. 여기서는 <code>name</code> 필드를 새롭게 생성된 무작위 UUID 문자열로 설정합니다.</li>
<li><strong>첫 번째 일치 문서 업데이트</strong>: 쿼리에 일치하는 첫 번째 문서만 업데이트됩니다. 만약 일치하는 문서가 없으면 업데이트는 수행되지 않습니다.</li>
<li><strong>결과 반환</strong>: 메서드는 <code>UpdateResult</code>를 반환하여 업데이트 작업의 결과를 나타냅니다. 이를 통해 몇 개의 문서가 영향을 받았는지 확인할 수 있습니다.</li>
</ol>
<p>이번 테스트에서는 <code>updateFirst</code> 메서드를 사용하여 <code>Member</code> 클래스의 <code>name</code> 필드를 업데이트합니다. 테스트는 특정 <code>id</code>를 가진 <code>Member</code> 문서를 대상으로 하며, 이 메서드는 해당 문서의 <code>name</code> 필드를 새로운 값으로 업데이트합니다. 이 방법을 통해 <code>updateFirst</code> 메서드의 단일 문서 업데이트 성능을 평가하고자 합니다.</p>
<h3 id="bulkOps"><a href="#bulkOps" class="headerlink" title="bulkOps"></a>bulkOps</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">updateBulk</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ids: <span class="type">List</span>&lt;<span class="type">ObjectId</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    bulkMode: <span class="type">BulkOperations</span>.<span class="type">BulkMode</span> = BulkOperations.BulkMode.UNORDERED <span class="comment">// or BulkOperations.BulkMode.ORDERED</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: BulkWriteResult &#123;</span><br><span class="line">    <span class="keyword">val</span> bulkOps = mongoTemplate.bulkOps(bulkMode, Member::<span class="keyword">class</span>.java)</span><br><span class="line">    <span class="keyword">for</span> (id <span class="keyword">in</span> ids) &#123;</span><br><span class="line">        bulkOps.updateOne(</span><br><span class="line">            Query(Criteria.<span class="keyword">where</span>(<span class="string">&quot;_id&quot;</span>).`<span class="keyword">is</span>`(id)),</span><br><span class="line">            Update().<span class="keyword">set</span>(<span class="string">&quot;name&quot;</span>, UUID.randomUUID().toString())</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bulkOps.execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>bulkOps</code> 메서드는 Spring Data MongoDB의 <code>MongoTemplate</code>을 사용하여 대량의 업데이트 작업을 효율적으로 처리하는 방법을 제공합니다. <code>bulkOps</code>는 한 번의 연산으로 여러 업데이트 작업을 모아서 실행할 수 있으며, <code>BulkMode</code>에 따라 순서대로(<code>ORDERED</code>) 또는 순서에 구애받지 않고(<code>UNORDERED</code>) 실행할 수 있습니다. 동작 방식은 다음과 같습니다.</p>
<ol>
<li><strong>Bulk Operations 설정</strong>: <code>bulkOps</code>는 주어진 <code>BulkMode</code>와 문서 클래스(<code>Member::class.java</code>)를 기반으로 초기화됩니다.</li>
<li><strong>업데이트 작업 추가</strong>: <code>updateOne</code> 메서드를 사용하여 각 <code>id</code>에 대한 업데이트 작업을 추가합니다. 여기서는 <code>name</code> 필드를 새로운 무작위 UUID 문자열로 설정합니다.</li>
<li><strong>Bulk 작업 실행</strong>: <code>execute</code> 메서드를 호출하여 누적된 모든 업데이트 작업을 한 번에 실행합니다.</li>
<li><strong>결과 반환</strong>: 메서드는 <code>BulkWriteResult</code>를 반환하여 대량 업데이트 작업의 결과를 나타냅니다.</li>
</ol>
<p>이번 테스트에서는 <code>bulkOps</code> 메서드를 사용하여 <code>Member</code> 클래스의 <code>name</code> 필드를 대량으로 업데이트합니다. 여러 <code>id</code>를 가진 <code>Member</code> 문서에 대해 각각 <code>name</code> 필드를 새로운 값으로 업데이트하는 작업을 모아 한 번에 실행합니다. 이 방법을 통해 <code>bulkOps</code> 메서드의 대량 업데이트 성능과 <code>UNORDERED</code>와 <code>ORDERED</code> 모드 간의 성능 차이를 평가하고자 합니다.</p>
<h4 id="BulkMode-차이점"><a href="#BulkMode-차이점" class="headerlink" title="BulkMode 차이점:"></a>BulkMode 차이점:</h4><ul>
<li><p><strong><code>BulkOperations.BulkMode.UNORDERED</code></strong>:</p>
<ul>
<li>작업들이 순서에 구애받지 않고 병렬적으로 처리됩니다.</li>
<li>성능 측면에서 더 효율적일 수 있으나, 하나의 작업 실패가 다른 작업에 영향을 미치지 않습니다.</li>
<li>대량의 독립적인 작업을 빠르게 처리해야 할 때 유용합니다.</li>
</ul>
</li>
<li><p><strong><code>BulkOperations.BulkMode.ORDERED</code></strong>:</p>
<ul>
<li>작업들이 추가된 순서대로 처리됩니다.</li>
<li>하나의 작업이 실패하면 그 이후의 작업은 실행되지 않을 수 있습니다.</li>
<li>작업들 간의 순서가 중요한 경우에 적합합니다.</li>
</ul>
</li>
</ul>
<h2 id="성능-측정-결과"><a href="#성능-측정-결과" class="headerlink" title="성능 측정 결과"></a>성능 측정 결과</h2><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/5fc6127a0800ca9bce5de5a6c73931b2025b0791/mongo-study/images/performance-update.png"></p>
<table>
<thead>
<tr>
<th>rows</th>
<th>saveAll</th>
<th>updateFirst</th>
<th>bulkOps(UNORDERED)</th>
<th>bulkOps(ORDERED)</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>1,052 ms</td>
<td>1,176 ms</td>
<td>46 ms</td>
<td>79 ms</td>
</tr>
<tr>
<td>200</td>
<td>2,304 ms</td>
<td>2,196 ms</td>
<td>103 ms</td>
<td>124 ms</td>
</tr>
<tr>
<td>500</td>
<td>5,658 ms</td>
<td>5,250 ms</td>
<td>309 ms</td>
<td>257 ms</td>
</tr>
<tr>
<td>1,000</td>
<td>11,106 ms</td>
<td>10,846 ms</td>
<td>418 ms</td>
<td>412 ms</td>
</tr>
<tr>
<td>2,000</td>
<td>22,592 ms</td>
<td>21,427 ms</td>
<td>1,060 ms</td>
<td>1,004 ms</td>
</tr>
<tr>
<td>5,000</td>
<td>54,407 ms</td>
<td>52,075 ms</td>
<td>2,663 ms</td>
<td>2,292 ms</td>
</tr>
<tr>
<td>10,000</td>
<td>107,651 ms</td>
<td>110,884 ms</td>
<td>4,514 ms</td>
<td>4,496 ms</td>
</tr>
</tbody></table>
<p>결과는 <code>saveAll</code>, <code>updateFirst</code>, <code>bulkOps(UNORDERED)</code>, <code>bulkOps(ORDERED)</code> 네 가지 방법에 대해 다양한 행(rows) 수에 따라 수행 시간(밀리초)을 비교합니다.</p>
<h3 id="분석-결과"><a href="#분석-결과" class="headerlink" title="분석 결과:"></a>분석 결과:</h3><h4 id="saveAll과-updateFirst"><a href="#saveAll과-updateFirst" class="headerlink" title="saveAll과 updateFirst"></a><code>saveAll과</code> <code>updateFirst</code></h4><ul>
<li>이 두 방법은 유사한 성능을 보입니다. 행의 수가 증가함에 따라 수행 시간이 선형적으로 증가하는 경향을 보이며, 대량의 데이터를 처리할 때 상대적으로 높은 지연 시간을 가집니다.</li>
<li><code>saveAll</code>과 <code>updateFirst</code> 메서드의 성능 차이는 유의미하지 않습니다. 따라서, 상대적으로 데이터 양이 적은 경우에는 upsert 기능을 제공하는 <code>saveAll</code>을 사용하여 로직을 단순화할 수 있습니다.</li>
<li>예제 코드에서는 <code>updateFirst</code> 메서드를 사용하여 기본 키(PK)를 기반으로 업데이트를 수행했습니다. 그러나 다른 키 값으로 조회를 진행할 경우, 조회 속도가 느려져 성능 차이가 발생할 수 있습니다.</li>
<li><code>saveAll</code> 메서드는 <code>Member</code> 객체의 모든 변경 사항을 반영합니다. 따라서, 특정 필드만을 명확하게 업데이트하고자 할 때는 <code>updateFirst</code>와 같은 메서드를 사용하여 정확한 업데이트 쿼리를 작성하는 것이 좋은 대안이 될 수 있습니다. 이 방법은 업데이트하고자 하는 필드를 직접 지정할 수 있어, 더 세밀한 데이터 업데이트 제어가 가능합니다.</li>
</ul>
<h4 id="bulkOps-UNORDERED-와-bulkOps-ORDERED"><a href="#bulkOps-UNORDERED-와-bulkOps-ORDERED" class="headerlink" title="bulkOps(UNORDERED)와 bulkOps(ORDERED)"></a><code>bulkOps(UNORDERED)</code>와 <code>bulkOps(ORDERED)</code></h4><ul>
<li>이 방법들은 <code>saveAll</code>과 <code>updateFirst</code>에 비해 현저히 빠른 성능을 보입니다. 특히 <code>bulkOps(UNORDERED)</code>는 가장 빠른 처리 시간을 나타냅니다.</li>
<li><code>bulkOps(UNORDERED)</code>는 순서에 구애받지 않고 여러 작업을 동시에 처리할 수 있기 때문에, 대량의 데이터 처리에 더 효율적이며, 개별 작업들이 독립적으로 처리됩니다. 이는 특정 작업이 실패해도 다른 작업들에 영향을 주지 않는다는 것을 의미합니다.</li>
<li><code>bulkOps(ORDERED)</code>도 비교적 빠른 성능을 보이지만, <code>bulkOps(UNORDERED)</code>에 비해 약간 느린 경향이 있습니다. 이는 작업을 순서대로 처리해야 하는 부가적인 비용 때문 이며, 순차적으로 작업이 진행되기 때문에 한 작업이 실패하면 그 이후의 작업은 실행되지 않을 수 있습니다.</li>
<li><code>bulkOps(UNORDERED)</code>와 <code>bulkOps(ORDERED)</code> 방식은 10,000개의 데이터 모수까지는 큰 성능 차이가 나타나지 않았습니다. 그러나 데이터가 많은 노드에 분산되어 저장된 경우, 이 두 방식 사이에서 더 유의미한 성능 차이가 발생할 수 있습니다. 분산 환경에서는 데이터의 위치와 네트워크 지연이 성능에 영향을 미칠 수 있으며, 이러한 조건에서는 <code>bulkOps(UNORDERED)</code>와 <code>bulkOps(ORDERED)</code>의 처리 방식 차이가 더 명확하게 드러날 가능성이 있습니다.</li>
</ul>
<h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><ul>
<li>소량의 데이터를 업데이트할 때는 <code>saveAll</code>과 <code>updateFirst</code> 메서드가 적합할 수 있습니다. 하지만 데이터 양이 많아질수록 이 두 방법의 성능은 상대적으로 감소합니다. 데이터 모수가 적은 경우, <code>saveAll</code>과 <code>updateFirst</code> 각각의 장단점이 있으므로, 특정 환경과 요구사항에 맞게 적절한 메서드를 선택하는 것이 중요합니다.</li>
<li>대량의 데이터 처리에는 <code>bulkOps</code> 메서드 사용이 효율적입니다. <code>bulkOps(UNORDERED)</code>와 <code>bulkOps(ORDERED)</code> 각각의 장단점이 존재하므로, 이 두 방식 중에서는 특정 환경과 요구사항에 맞게 적절한 옵션을 선택하는 것이 중요합니다.</li>
</ul>
<p>이러한 결과는 MongoDB 데이터 업데이트 전략을 선택할 때 중요한 고려 사항을 제공합니다. 데이터의 양, 업데이트의 복잡성, 순서의 중요성 등을 고려하여 적절한 방법을 선택할 필요가 있습니다.</p>
<h2 id="bulkOps-편의-기능-제공"><a href="#bulkOps-편의-기능-제공" class="headerlink" title="bulkOps 편의 기능 제공"></a>bulkOps 편의 기능 제공</h2><p>이전 포스팅인 <a href="https://cheese10yun.github.io/spring-data-mongo-repository/">Spring Data MongoDB Repository 확장</a>에서는 <code>MongoCustomRepositorySupport</code>를 사용해 <code>MongoRepository</code>에 편의 기능을 추가하고, 보일러플레이트 코드를 줄이는 방법을 소개했습니다. 이 방법은 코드의 재사용성을 높이는 효과가 있습니다. 마찬가지로, <code>bulkOps</code>와 같은 반복적인 코드도 <code>MongoCustomRepositorySupport</code>에 통합함으로써 더 편리하게 기능을 제공할 수 있습니다. 이렇게 하면 <code>bulkOps</code> 관련 코드를 중앙화하여 관리 및 사용의 용이성을 향상시킬 수 있습니다.</p>
<h3 id="MongoCustomRepositorySupport을-통한-bulkOps-기능-제공"><a href="#MongoCustomRepositorySupport을-통한-bulkOps-기능-제공" class="headerlink" title="MongoCustomRepositorySupport을 통한 bulkOps 기능 제공"></a>MongoCustomRepositorySupport을 통한 bulkOps 기능 제공</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MongoCustomRepositorySupport</span>&lt;<span class="type">T</span>&gt;(</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> documentClass: Class&lt;T&gt;,</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> mongoTemplate: MongoTemplate</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">bulkUpdate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        operations: <span class="type">List</span>&lt;<span class="type">Pair</span>&lt;() -&gt; <span class="type">Query</span>, ()</span></span> -&gt; Update&gt;&gt;, <span class="comment">// Query와 Update 생성자를 위한 람다 리스트</span></span><br><span class="line">        bulkMode: BulkOperations.BulkMode</span><br><span class="line">    ): BulkWriteResult &#123;</span><br><span class="line">        <span class="comment">// BulkOperations 객체를 생성합니다.</span></span><br><span class="line">        <span class="keyword">val</span> bulkOps = mongoTemplate.bulkOps(bulkMode, documentClass)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 제공된 리스트를 반복하면서 bulk 연산에 각 update를 추가합니다.</span></span><br><span class="line">        operations.forEach &#123; (queryCreator, updateCreator) -&gt;</span><br><span class="line">            bulkOps.updateOne(queryCreator.invoke(), updateCreator.invoke())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 모든 업데이트를 실행합니다.</span></span><br><span class="line">        <span class="keyword">return</span> bulkOps.execute()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemberCustomRepositoryImpl</span>(mongoTemplate: MongoTemplate) : MemberCustomRepository,</span><br><span class="line">    MongoCustomRepositorySupport&lt;Member&gt;(</span><br><span class="line">        Member::<span class="keyword">class</span>.java,</span><br><span class="line">        mongoTemplate</span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateName</span><span class="params">(listOf: <span class="type">List</span>&lt;<span class="type">Pair</span>&lt;() -&gt; <span class="type">Query</span>, ()</span></span> -&gt; Update&gt;&gt;, bulkMode: BulkOperations.BulkMode) &#123;</span><br><span class="line">        bulkUpdate(listOf, bulkMode)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `updateNmae 사용하는 곳`<span class="params">(pairs: <span class="type">List</span>&lt;<span class="type">Pair</span>&lt;() -&gt; <span class="type">Query</span>, ()</span></span> -&gt; Update&gt;&gt;, bulkMode: BulkOperations.BulkMode) &#123;</span><br><span class="line">    <span class="keyword">val</span> pair = listOf(</span><br><span class="line">        Pair(</span><br><span class="line">            first = &#123; Query(Criteria.<span class="keyword">where</span>(<span class="string">&quot;_id&quot;</span>).`<span class="keyword">is</span>`(ObjectId(<span class="string">&quot;id&quot;</span>))) &#125;,</span><br><span class="line">            second = &#123; Update().<span class="keyword">set</span>(<span class="string">&quot;name&quot;</span>, UUID.randomUUID().toString()) &#125;</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    memberRepository.updateName(pair, BulkOperations.BulkMode.UNORDERED)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>코드는 외부에서 정의된 쿼리와 업데이트 로직을 사용하여 데이터 업데이트를 수행합니다. 코드는 <code>Pair</code> 리스트를 통해 각 업데이트 작업에 필요한 <code>Query</code>와 <code>Update</code> 객체를 정의하고, 이를 <code>memberRepository</code>의 <code>updateName</code> 메서드에 전달하여 <code>BulkOperations.BulkMode.UNORDERED</code> 모드로 업데이트를 진행합니다. 이 방식은 업데이트 과정을 유연하게 처리할 수 있게 해줍니다.</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">태그</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/Mongo/" rel="tag">Mongo</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/Performance/" rel="tag">Performance</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/intellij-cannot-resolve-symbol/"
                    data-tooltip="IntelliJ cannot resolve symbol 에러 해결"
                    aria-label="이전: IntelliJ cannot resolve symbol 에러 해결"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/spring-data-mongo-test-setup/"
                    data-tooltip="MongoDB 다양한 테스트 케이스를 커버할 수 있는 테스트 데이터 셋업 방법"
                    aria-label="다음: MongoDB 다양한 테스트 케이스를 커버할 수 있는 테스트 데이터 셋업 방법"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/spring-data-mongodb-update-performance/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/spring-data-mongodb-update-performance/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cheese10yun.github.io/spring-data-mongodb-update-performance/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>


<!-- Comment -->
<!--  utteranc comment -->

<script src="https://utteranc.es/client.js"
        repo="cheese10yun/blog-comment"
        issue-term="title"
        label="Comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Yun. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/intellij-cannot-resolve-symbol/"
                    data-tooltip="IntelliJ cannot resolve symbol 에러 해결"
                    aria-label="이전: IntelliJ cannot resolve symbol 에러 해결"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/spring-data-mongo-test-setup/"
                    data-tooltip="MongoDB 다양한 테스트 케이스를 커버할 수 있는 테스트 데이터 셋업 방법"
                    aria-label="다음: MongoDB 다양한 테스트 케이스를 커버할 수 있는 테스트 데이터 셋업 방법"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/spring-data-mongodb-update-performance/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/spring-data-mongodb-update-performance/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cheese10yun.github.io/spring-data-mongodb-update-performance/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="5">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/spring-data-mongodb-update-performance/"
                        aria-label="Facebook에 공유하기"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Facebook에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/spring-data-mongodb-update-performance/"
                        aria-label="Twitter에 공유하기"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Twitter에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://cheese10yun.github.io/spring-data-mongodb-update-performance/"
                        aria-label="Google+에 공유하기"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Google+에 공유하기</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
            <h4 id="about-card-name">Yun</h4>
        
            <div id="about-card-bio"><p>기술 블로그</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
