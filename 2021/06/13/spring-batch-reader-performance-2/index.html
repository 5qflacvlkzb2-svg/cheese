
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Yun Blog">
    <title>Spring Batch Reader 성능 분석 및 측정 part 2 - Yun Blog</title>
    <meta name="author" content="Yun">
    
        <meta name="keywords" content="Node,Spring,Spring Boot,Spring Batch,Kotlin,기술 블로그,JPA,Mongo,MySQL,OOP,">
    
    
    
        
            <link rel="alternate" type="application/rss+xml" title="RSS" href="/rss2.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg"},"articleBody":"Spring Batch Reader 성능 분석 및 측정 part 1 이어지는 글입니다.\nHibernateCursorItemReaderHibernateCursorItemReader를 이해하기 앞서 JDBC를 이용하여 대량의 데이터를 가져오는 방에 대해서 이야기해보겠습니다. 이론적인 설명은 Real MySQL을 보고 정리했습니다. MySQL를 사용 중이면 정말 추천드리는 도서입니다.\n대용량 조회 스트리밍 방식JDBC 표준에서 제공하는 Statement.setFetchSize()를 이용해서 MySQL 서버로부터 SELECT된 레코드를 클라이언트 애플리케이션으로 한 번에 가져올 레코드의 건수를 설정하는 역할을 합니다. 하지만 Connector&#x2F;J에서 Statement.setFetchSize()의 표준을 지원하지 못하고 있습니다. 즉 Statement.setFetchSize(100)을 설정해도 100개의 레코드만 가져오게 동작하지는 않습니다.\n\nConnector&#x2F;J를 사용해서 조회 쿼리를 실행하면(Statement.executeQuery()를 이용) 실행하면 Connetor&#x2F;J가 조회 결과를 MySQL 서버로부터 실행 결과 모두를 다운로드해 Connector&#x2F;J가 관리하는 캐시메모리에 그 결과를 저장합니다. 당연히 조회 쿼리의 결과 가를 모두 응답받기 전까지는 Blocking 상태이며 모든 결과를 응답받게 되면 ResultSEt의 핸들러를 애플리케이션에게 반환합니다. 그 이후부터 우리가 일반적으로 사용하는 ResultSet.next(), ResultSet.getSting()의 호출이 가능하고, 해당 메서드를 호출하면 Connector&#x2F;J가 캐시 해둔 값으로 빠르게 응답이 가능합니다.(MySQL 서버까지 요청이 가지 않고 Connector&#x2F;J를 사용한다는 의미) 이것이 클라이언트 커서라고 하며, 이는 매우 효율적이라서 MySQL Connector&#x2F;J의 기본 동작으로 채택되어 있습니다.\n하지만 이는 문제가 있습니다. 대량의 데이터를 조회할 때 해당 쿼리의 결과가 너무 오래 걸리기 때문에 클라이언트로 다운로드하는 데 많은 시간이 소요되며 무엇보다도 애플리케이션의 메모리를 한정적이기 때문에 OOM이 발생하기도 합니다.\nJdbcResultSet다음 코드는 조회 대상 rows 20,480,000에 대해서 조회하는 코드입니다.\n12345678910111213141516171819202122232425262728293031323334public class JdbcResultSet &#123;    public static void main(String[] args) throws Exception &#123;        final Connection connection = (new JdbcResultSet()).getConnection();        final StopWatch stopWatch = new StopWatch();        stopWatch.start();        final String sql = &quot;SELECT *FROM payment WHERE created_at &gt;= &#x27;2021-05-01 00:00:00&#x27; ORDER BY id ASC&quot;;        final Statement statement = connection.createStatement();        final ResultSet resultSet = statement.executeQuery(sql);        while (resultSet.next()) &#123;            System.out.println(&quot;id: &quot; + resultSet.getString(&quot;id&quot;));        &#125;        resultSet.close();        statement.close();        connection.close();        stopWatch.stop();        System.out.println(stopWatch.getTotalTimeSeconds());    &#125;    public Connection getConnection() throws Exception &#123;        final String driver = &quot;com.mysql.cj.jdbc.Driver&quot;;        final String url = &quot;jdbc:mysql://localhost:3366/batch_study&quot;;        final String user = &quot;root&quot;;        final String password = &quot;&quot;;        Class.forName(driver).newInstance();        return DriverManager.getConnection(url, user, password);    &#125;&#125;\n\nresultSet의 rowData 항목을 디버깅해보고 확인해보면 모든 조회 레코드 rows 20,480,000를 가져온 것을 확인할 수 있습니다. rows의 실제 객체는 ResultsetRowsStatic입니다. 해당 코드의 주석문을 첨부합니다.\n\nRepresents an in-memory result set\n\n\n위에서도 언급했듯이 Connector&#x2F;J를 사용해서 조회 쿼리를 실행하면(Statement.executeQuery()를 이용) 실행하면 Connetor&#x2F;J가 조회 결과를 MySQL 서버로부터 실행 결과 모두를 다운로드해 Connector&#x2F;J가 관리하는 캐시메모리에 그 결과를 저장합니다. Connector&#x2F;J는 실행 결과 모두를 애플리케이션에 캐시를 하기 때문에 Heap 용량이 max 용량인 8,589,934,592 크기 중 5,298,401,400를 사용하고 있습니다. 현재 애플리케이션의 Heap 사이즈가 8GB이므로 OOM이 발생하지 않았지만, 그보다 낮은 Heap 사이즈에서는 발생할 수 있습니다.\nResultSetStreaming이러한 문제를 해결하기 위해서 MySQL에서는 Statement.setFetchSize()를 예약된 값인 Integer.MIN_VALUE으로 설정하면 한 번에 쿼리의 결과를 모두 다운로드하지 않고 MySQL 서버에서 한 건 단위로 읽어서 가져가게 할 수 있습니다. 이러한 방식을 ResultSet Streaming 방식이라고 합니다.\n\nResultSetSteaming 방식은 매번 레코드 단위로 MySQL 서버와 통신해야 하므로 Connector&#x2F;J의 기본적인 처리 방식에 비해서 느리지만 레코드의 단위가 대량이고 내부적인 애플리케이션의 메모리가 크지 않다면 이 방법을 택할 수밖에 없습니다. 보다 자세한 내용은 Connector-J: 6.4 JDBC API Implementation Notes를 참고해 주세요.\n다음 코드도 동일하게 rows 20,480,000에 대해서 조회하는 코드입니다.\n1234567891011121314151617181920212223242526272829303132333435public class JdbcResultSetStreaming &#123;    public static void main(String[] args) throws Exception &#123;        final Connection connection = (new JdbcResultSetStreaming()).getConnection();        final StopWatch stopWatch = new StopWatch();        stopWatch.start();        final String sql = &quot;SELECT *FROM payment WHERE created_at &gt;= &#x27;2021-05-01 00:00:00&#x27; ORDER BY created_at DESC&quot;;        final Statement statement = connection.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);        statement.setFetchSize(Integer.MIN_VALUE);        final ResultSet resultSet = statement.executeQuery(sql);        while (resultSet.next()) &#123;           System.out.println(&quot;id: &quot; + resultSet.getString(&quot;id&quot;));        &#125;        resultSet.close();        statement.close();        connection.close();        stopWatch.stop();        System.out.println(stopWatch.getTotalTimeSeconds());    &#125;    public Connection getConnection() throws Exception &#123;        final String driver = &quot;com.mysql.cj.jdbc.Driver&quot;;        final String url = &quot;jdbc:mysql://localhost:3366/batch_study&quot;;        final String user = &quot;root&quot;;        final String password = &quot;&quot;;        Class.forName(driver).newInstance();        return DriverManager.getConnection(url, user, password);    &#125;&#125;\nJdbcResultSet 코드와 거의 동일하며 차이점은 connection.createStatement(...) 메서드로 Statement를 생성할 때 ResultSet.CONCUR_READ_ONLY 설정을 통해서 읽기 전용으로 설정하고, ResultSet.TYPE_FORWARD_ONLY으로 Statement 진행 방향을 앞쪽으로 읽을 것을 설정하고 마지막으로 statement.setFetchSize(Integer.MIN_VALUE); 설정을 통해 MySQL 서버는 클라이언트가 결과 셋을 레코드 한 건 단위로 다운로드한다고 간주합니다. 이는 예약된 값으로 특별한 의미를 갖는 것이 아니며 100으로 설정한다고 해서 100 건 단위로 가져오지 않습니다.\n\nResultSetStreaming 방식은 말 그대로 스트리밍 해오는 방식이기 때문에 ResultRowsStreaming 객체를 사용합니다. 스트리밍 하기 때문에 ResultRowsStatic 객체와 다르게 rows를 담지 않습니다. 자세한 설명은 해당 객체의 주석문을 첨부하겠습니다.\n\nProvides streaming of Resultset rows. Each next row is consumed from the input stream only on next() call. Consumed rows are not cached thus we only stream result sets when they are forward-only, read-only, and the fetch size has been set to Integer.MIN_VALUE (rows are read one by one).Type parameters: – ProtocolEntity type\n\n해당 주석에도 Integer.MIN_VALUE (rows are read one by one). 한 건으로 가져온다고 나와있습니다.\n\nConnector&#x2F;J에서 모든 결과를 캐시하지 않기 때문에 Heap 메모리는 균일한것 확인할 수 있습니다.\nHibernateCursorItemReader다시 본론으로 돌아가서 HibernateCursorItemReader에 대해서 설명드리겠습니다. HibernateCursorItemReader는 ResultSetStreaming 방식을 사용합니다. HibernateCursorItemReader의 doRead 코드를 break point를 찍고 보면 다음과 같습니다.\n\ncursor.get();를 통해서 가져온 currentRow 데이터가 1개인 것을 확인할 수 있습니다. 이는 ResultSetStreaming 방식과 동일하게 한건 한건 가져오는 방식과 동일합니다.\n\nHeap 사이즈를 보면 위에서 확인했던 ResultSetStreaming Heap 사이즈와 비슷한 그래프를 확인할 수 있습니다. 그리고 fetchSize 옵션에 대해 약간 오해가 소지가 있을 수 있습니다.\n123456789101112131415161718@Configurationclass ReaderPerformanceJobConfiguration(    @Bean    @StepScope    fun hibernateCursorItemReader(        sessionFactory: SessionFactory    ) = HibernateCursorItemReaderBuilder&lt;Payment&gt;()        .name(&quot;hibernateCursorItemReader&quot;)        .fetchSize(10)        .sessionFactory(sessionFactory)        .queryString(&quot;SELECT p FROM Payment p where p.createdAt &gt;= :createdAt ORDER BY p.createdAt DESC&quot;)        .parameterValues(mapOf(&quot;createdAt&quot; to localDateTime))        .build()    fun writer() = ItemWriter&lt;Payment&gt; &#123;        log.info(&quot;item size $&#123;it.size&#125;&quot;)    &#125;&#125;\nfetchSize를 위처럼 10으로 주면 마치 Statement.setFetchSize(10)이 입력되게 되며 해당 rows 별로 스트리밍 하는 거 같지만 저건 어디까지나 청크 사이즈 개념으로 해당 해당 Reader가 fetchSize 만큼 읽고 나서 Processor or Writer로 넘어가는 사이즈입니다.\n\n출처 Chunk-oriented Processing\n\n\nfetchSize를 10으로 설정하면 10단위 Writer으로 넘어 게가 됩니다.\n주의 사항한 번 맺은 커넥션으로 계속 스트리밍을 하기 때문에 애플리케이션은 한번 연결한 커넥션을 애플리케이션 종료될 때까지 사용하게 됩니다. 이는 Connection을 반납하지 않는 구조이기 때문에 Connection Timeout이 발생할 수 있기 때문에 조심해야 합니다. 당장은 데이터가 상대적으로 적어서 발생하지 않더라도 데이터가 많아짐에 따라 Connection 시간도 증가하기 때문에 각별히 조심해야 합니다.\n참고\nSpring Batch - Reference Documentation\nReal MySQL 개발자와 DBA를 위한\nMySQL 5.7 완벽 분석 \n기억보단 기록을 - Spring Batch와 QuerydslItemReader\n\n","dateCreated":"2021-06-13T00:00:00+09:00","dateModified":"2025-01-31T04:41:33+09:00","datePublished":"2021-06-13T00:00:00+09:00","description":"HibernateCursorItemReader를 이해하기 앞서 JDBC를 이용하여 대량의 데이터를 가져오는 방에 대해서 이야기해보겠습니다.","headline":"Spring Batch Reader 성능 분석 및 측정 part 2","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://cheese10yun.github.io/2021/06/13/spring-batch-reader-performance-2/"},"publisher":{"@type":"Organization","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg","logo":{"@type":"ImageObject","url":"yun-icon.jpg"}},"url":"https://cheese10yun.github.io/2021/06/13/spring-batch-reader-performance-2/","keywords":"Performance, Spring Batch"}</script>
    <meta name="description" content="HibernateCursorItemReader를 이해하기 앞서 JDBC를 이용하여 대량의 데이터를 가져오는 방에 대해서 이야기해보겠습니다.">
<meta property="og:type" content="blog">
<meta property="og:title" content="Spring Batch Reader 성능 분석 및 측정 part 2">
<meta property="og:url" content="https://cheese10yun.github.io/2021/06/13/spring-batch-reader-performance-2/index.html">
<meta property="og:site_name" content="Yun Blog">
<meta property="og:description" content="HibernateCursorItemReader를 이해하기 앞서 JDBC를 이용하여 대량의 데이터를 가져오는 방에 대해서 이야기해보겠습니다.">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="https://github.com/cheese10yun/TIL/raw/master/assets/rea-mysql-flow-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/JdbcResultSet-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/JdbcResultSet.png">
<meta property="og:image" content="https://github.com/cheese10yun/TIL/raw/master/assets/real_mysql_2222.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/JdbcResultSetStreaming-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/JdbcResultSetStreaming.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/HibernateCursorItemReader-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/HibernateCursorItemReader-1.png">
<meta property="og:image" content="https://camo.githubusercontent.com/11d20a04aec707c42067d8d6797ffcdf55245c07d6345acf883bfec0a6674a4d/68747470733a2f2f646f63732e737072696e672e696f2f737072696e672d62617463682f646f63732f342e302e782f7265666572656e63652f68746d6c2f696d616765732f6368756e6b2d6f7269656e7465642d70726f63657373696e672e706e67">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/HibernateCursorItemReader-3.png">
<meta property="article:published_time" content="2021-06-12T15:00:00.000Z">
<meta property="article:modified_time" content="2025-01-30T19:41:33.826Z">
<meta property="article:author" content="Yun">
<meta property="article:tag" content="Performance">
<meta property="article:tag" content="Spring Batch">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/cheese10yun/TIL/raw/master/assets/rea-mysql-flow-1.png">
    
    
        
    
    
        <meta property="og:image" content="https://cheese10yun.github.io/assets/images/yun-icon.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90907312-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-90907312-1');
    </script>


    

    
        
    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5813739623204880" crossorigin="anonymous"></script>
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="5">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Yun Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="링크 열기: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="5">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="저자에 대해 더 알아보기"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
                </a>
                <h4 class="sidebar-profile-name">Yun</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기술 블로그</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="카테고리"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">카테고리</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="태그"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="아카이브"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">아카이브</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="검색"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">검색</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/cheese10yun"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/rss2.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="5"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Spring Batch Reader 성능 분석 및 측정 part 2
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2021-06-13T00:00:00+09:00">
	
		    2021/06/13
    	
    </time>
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p><a href="https://cheese10yun.github.io/spring-batch-reader-performance/">Spring Batch Reader 성능 분석 및 측정 part 1</a> 이어지는 글입니다.</p>
<h2 id="HibernateCursorItemReader"><a href="#HibernateCursorItemReader" class="headerlink" title="HibernateCursorItemReader"></a>HibernateCursorItemReader</h2><p>HibernateCursorItemReader를 이해하기 앞서 JDBC를 이용하여 대량의 데이터를 가져오는 방에 대해서 이야기해보겠습니다. 이론적인 설명은 <a target="_blank" rel="noopener" href="http://www.yes24.com/Product/Goods/6960931">Real MySQL</a>을 보고 정리했습니다. MySQL를 사용 중이면 정말 추천드리는 도서입니다.</p>
<h3 id="대용량-조회-스트리밍-방식"><a href="#대용량-조회-스트리밍-방식" class="headerlink" title="대용량 조회 스트리밍 방식"></a>대용량 조회 스트리밍 방식</h3><p>JDBC 표준에서 제공하는 <code>Statement.setFetchSize()</code>를 이용해서 MySQL 서버로부터 SELECT된 레코드를 클라이언트 애플리케이션으로 한 번에 가져올 레코드의 건수를 설정하는 역할을 합니다. <strong>하지만 Connector&#x2F;J에서 <code>Statement.setFetchSize()</code>의 표준을 지원하지 못하고 있습니다. 즉 Statement.setFetchSize(100)을 설정해도 100개의 레코드만 가져오게 동작하지는 않습니다.</strong></p>
<p><img src="https://github.com/cheese10yun/TIL/raw/master/assets/rea-mysql-flow-1.png"></p>
<p><strong>Connector&#x2F;J를 사용해서 조회 쿼리를 실행하면(Statement.executeQuery()를 이용) 실행하면 Connetor&#x2F;J가 조회 결과를 MySQL 서버로부터 실행 결과 모두를 다운로드해 Connector&#x2F;J가 관리하는 캐시메모리에 그 결과를 저장합니다.</strong> 당연히 조회 쿼리의 결과 가를 모두 응답받기 전까지는 Blocking 상태이며 모든 결과를 응답받게 되면 ResultSEt의 핸들러를 애플리케이션에게 반환합니다. 그 이후부터 우리가 일반적으로 사용하는 <code>ResultSet.next()</code>, <code>ResultSet.getSting()</code>의 호출이 가능하고, <strong>해당 메서드를 호출하면 Connector&#x2F;J가 캐시 해둔 값으로 빠르게 응답이 가능합니다.(MySQL 서버까지 요청이 가지 않고 Connector&#x2F;J를 사용한다는 의미)</strong> 이것이 클라이언트 커서라고 하며, 이는 매우 효율적이라서 MySQL Connector&#x2F;J의 기본 동작으로 채택되어 있습니다.</p>
<p>하지만 이는 문제가 있습니다. 대량의 데이터를 조회할 때 해당 쿼리의 결과가 너무 오래 걸리기 때문에 클라이언트로 다운로드하는 데 많은 시간이 소요되며 <strong>무엇보다도 애플리케이션의 메모리를 한정적이기 때문에 OOM이 발생하기도 합니다.</strong></p>
<h3 id="JdbcResultSet"><a href="#JdbcResultSet" class="headerlink" title="JdbcResultSet"></a>JdbcResultSet</h3><p>다음 코드는 조회 대상 rows 20,480,000에 대해서 조회하는 코드입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcResultSet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">JdbcResultSet</span>()).getConnection();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">        stopWatch.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT *FROM payment WHERE created_at &gt;= &#x27;2021-05-01 00:00:00&#x27; ORDER BY id ASC&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;id: &quot;</span> + resultSet.getString(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resultSet.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        System.out.println(stopWatch.getTotalTimeSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3366/batch_study&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Class.forName(driver).newInstance();</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/JdbcResultSet-2.png"></p>
<p>resultSet의 rowData 항목을 디버깅해보고 확인해보면 모든 조회 레코드 rows 20,480,000를 가져온 것을 확인할 수 있습니다. rows의 실제 객체는 ResultsetRowsStatic입니다. 해당 코드의 주석문을 첨부합니다.</p>
<blockquote>
<p>Represents an in-memory result set</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/JdbcResultSet.png"></p>
<p>위에서도 언급했듯이 <strong>Connector&#x2F;J를 사용해서 조회 쿼리를 실행하면(Statement.executeQuery()를 이용) 실행하면 Connetor&#x2F;J가 조회 결과를 MySQL 서버로부터 실행 결과 모두를 다운로드해 Connector&#x2F;J가 관리하는 캐시메모리에 그 결과를 저장합니다.</strong> Connector&#x2F;J는 실행 결과 모두를 애플리케이션에 캐시를 하기 때문에 Heap 용량이 max 용량인 8,589,934,592 크기 중 5,298,401,400를 사용하고 있습니다. 현재 애플리케이션의 Heap 사이즈가 8GB이므로 OOM이 발생하지 않았지만, 그보다 낮은 Heap 사이즈에서는 발생할 수 있습니다.</p>
<h3 id="ResultSetStreaming"><a href="#ResultSetStreaming" class="headerlink" title="ResultSetStreaming"></a>ResultSetStreaming</h3><p>이러한 문제를 해결하기 위해서 MySQL에서는 <code>Statement.setFetchSize()</code>를 예약된 값인 <code>Integer.MIN_VALUE</code>으로 설정하면 한 번에 쿼리의 결과를 모두 다운로드하지 않고 MySQL 서버에서 한 건 단위로 읽어서 가져가게 할 수 있습니다. 이러한 방식을 ResultSet Streaming 방식이라고 합니다.</p>
<p><img src="https://github.com/cheese10yun/TIL/raw/master/assets/real_mysql_2222.png"></p>
<p>ResultSetSteaming 방식은 매번 레코드 단위로 MySQL 서버와 통신해야 하므로 Connector&#x2F;J의 기본적인 처리 방식에 비해서 느리지만 레코드의 <strong>단위가 대량이고 내부적인 애플리케이션의 메모리가 크지 않다면 이 방법을 택할 수밖에 없습니다.</strong> 보다 자세한 내용은 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-implementation-notes.html">Connector-J: 6.4 JDBC API Implementation Notes</a>를 참고해 주세요.</p>
<p>다음 코드도 동일하게 rows 20,480,000에 대해서 조회하는 코드입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcResultSetStreaming</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> (<span class="keyword">new</span> <span class="title class_">JdbcResultSetStreaming</span>()).getConnection();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">        stopWatch.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT *FROM payment WHERE created_at &gt;= &#x27;2021-05-01 00:00:00&#x27; ORDER BY created_at DESC&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);</span><br><span class="line"></span><br><span class="line">        statement.setFetchSize(Integer.MIN_VALUE);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;id: &quot;</span> + resultSet.getString(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resultSet.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        System.out.println(stopWatch.getTotalTimeSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3366/batch_study&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Class.forName(driver).newInstance();</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JdbcResultSet 코드와 거의 동일하며 차이점은 <code>connection.createStatement(...)</code> 메서드로 Statement를 생성할 때 <code>ResultSet.CONCUR_READ_ONLY</code> 설정을 통해서 읽기 전용으로 설정하고, <code>ResultSet.TYPE_FORWARD_ONLY</code>으로 Statement 진행 방향을 앞쪽으로 읽을 것을 설정하고 마지막으로 <code>statement.setFetchSize(Integer.MIN_VALUE);</code> 설정을 통해 MySQL 서버는 클라이언트가 결과 셋을 레코드 한 건 단위로 다운로드한다고 간주합니다. 이는 예약된 값으로 특별한 의미를 갖는 것이 아니며 100으로 설정한다고 해서 100 건 단위로 가져오지 않습니다.</p>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/JdbcResultSetStreaming-1.png"></p>
<p>ResultSetStreaming 방식은 말 그대로 스트리밍 해오는 방식이기 때문에 ResultRowsStreaming 객체를 사용합니다. 스트리밍 하기 때문에 ResultRowsStatic 객체와 다르게 rows를 담지 않습니다. 자세한 설명은 해당 객체의 주석문을 첨부하겠습니다.</p>
<blockquote>
<p>Provides streaming of Resultset rows. Each next row is consumed from the input stream only on next() call. Consumed rows are not cached thus we only stream result sets when they are forward-only, read-only, and the fetch size has been set to Integer.MIN_VALUE (rows are read one by one).<br>Type parameters:<br><T> – ProtocolEntity type</p>
</blockquote>
<p>해당 주석에도 <code>Integer.MIN_VALUE (rows are read one by one).</code> 한 건으로 가져온다고 나와있습니다.</p>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/JdbcResultSetStreaming.png"></p>
<p><strong>Connector&#x2F;J에서 모든 결과를 캐시하지 않기 때문에 Heap 메모리는 균일한것 확인할 수 있습니다.</strong></p>
<h3 id="HibernateCursorItemReader-1"><a href="#HibernateCursorItemReader-1" class="headerlink" title="HibernateCursorItemReader"></a>HibernateCursorItemReader</h3><p>다시 본론으로 돌아가서 HibernateCursorItemReader에 대해서 설명드리겠습니다. HibernateCursorItemReader는 ResultSetStreaming 방식을 사용합니다. HibernateCursorItemReader의 doRead 코드를 break point를 찍고 보면 다음과 같습니다.</p>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/HibernateCursorItemReader-2.png"></p>
<p><code>cursor.get();</code>를 통해서 가져온 currentRow 데이터가 1개인 것을 확인할 수 있습니다. 이는 ResultSetStreaming 방식과 동일하게 한건 한건 가져오는 방식과 동일합니다.</p>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/HibernateCursorItemReader-1.png"></p>
<p>Heap 사이즈를 보면 위에서 확인했던 ResultSetStreaming Heap 사이즈와 비슷한 그래프를 확인할 수 있습니다. 그리고 <code>fetchSize</code> 옵션에 대해 약간 오해가 소지가 있을 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReaderPerformanceJobConfiguration</span>(</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@StepScope</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">hibernateCursorItemReader</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        sessionFactory: <span class="type">SessionFactory</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> = HibernateCursorItemReaderBuilder&lt;Payment&gt;()</span><br><span class="line">        .name(<span class="string">&quot;hibernateCursorItemReader&quot;</span>)</span><br><span class="line">        .fetchSize(<span class="number">10</span>)</span><br><span class="line">        .sessionFactory(sessionFactory)</span><br><span class="line">        .queryString(<span class="string">&quot;SELECT p FROM Payment p where p.createdAt &gt;= :createdAt ORDER BY p.createdAt DESC&quot;</span>)</span><br><span class="line">        .parameterValues(mapOf(<span class="string">&quot;createdAt&quot;</span> to localDateTime))</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">writer</span><span class="params">()</span></span> = ItemWriter&lt;Payment&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;item size <span class="subst">$&#123;it.size&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fetchSize를 위처럼 10으로 주면 마치 <code>Statement.setFetchSize(10)</code>이 입력되게 되며 해당 rows 별로 스트리밍 하는 거 같지만 저건 어디까지나 청크 사이즈 개념으로 해당 해당 Reader가 fetchSize 만큼 읽고 나서 Processor or Writer로 넘어가는 사이즈입니다.</p>
<blockquote>
<p><img src="https://camo.githubusercontent.com/11d20a04aec707c42067d8d6797ffcdf55245c07d6345acf883bfec0a6674a4d/68747470733a2f2f646f63732e737072696e672e696f2f737072696e672d62617463682f646f63732f342e302e782f7265666572656e63652f68746d6c2f696d616765732f6368756e6b2d6f7269656e7465642d70726f63657373696e672e706e67"><br>출처 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-batch/docs/4.0.x/reference/html/index-single.html#chunkOrientedProcessing">Chunk-oriented Processing</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/HibernateCursorItemReader-3.png"></p>
<p>fetchSize를 10으로 설정하면 10단위 Writer으로 넘어 게가 됩니다.</p>
<h3 id="주의-사항"><a href="#주의-사항" class="headerlink" title="주의 사항"></a>주의 사항</h3><p>한 번 맺은 커넥션으로 계속 스트리밍을 하기 때문에 애플리케이션은 한번 연결한 커넥션을 애플리케이션 종료될 때까지 사용하게 됩니다. 이는 Connection을 반납하지 않는 구조이기 때문에 Connection Timeout이 발생할 수 있기 때문에 조심해야 합니다. 당장은 데이터가 상대적으로 적어서 발생하지 않더라도 데이터가 많아짐에 따라 Connection 시간도 증가하기 때문에 각별히 조심해야 합니다.</p>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-batch/docs/current/reference/html/index.html">Spring Batch - Reference Documentation</a></li>
<li><a target="_blank" rel="noopener" href="http://www.yes24.com/Product/Goods/6960931">Real MySQL 개발자와 DBA를 위한</a></li>
<li><a target="_blank" rel="noopener" href="http://www.yes24.com/Product/Goods/72270172">MySQL 5.7 완벽 분석 </a></li>
<li><a target="_blank" rel="noopener" href="https://jojoldu.tistory.com/473?category=902551">기억보단 기록을 - Spring Batch와 QuerydslItemReader</a></li>
</ul>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">태그</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/Performance/" rel="tag">Performance</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/Spring-Batch/" rel="tag">Spring Batch</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2021/06/24/jpa-jpql/"
                    data-tooltip="Isolation Repeatable Read을 보장 하기 위한 JPA JPQL의 동작 원리"
                    aria-label="이전: Isolation Repeatable Read을 보장 하기 위한 JPA JPQL의 동작 원리"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2021/06/05/spring-batch-reader-performance/"
                    data-tooltip="Spring Batch Reader 성능 분석 및 측정 part 1"
                    aria-label="다음: Spring Batch Reader 성능 분석 및 측정 part 1"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/2021/06/13/spring-batch-reader-performance-2/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/2021/06/13/spring-batch-reader-performance-2/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cheese10yun.github.io/2021/06/13/spring-batch-reader-performance-2/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>


<!-- Comment -->
<!--  utteranc comment -->

<script src="https://utteranc.es/client.js"
        repo="cheese10yun/blog-comment"
        issue-term="title"
        label="Comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Yun. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2021/06/24/jpa-jpql/"
                    data-tooltip="Isolation Repeatable Read을 보장 하기 위한 JPA JPQL의 동작 원리"
                    aria-label="이전: Isolation Repeatable Read을 보장 하기 위한 JPA JPQL의 동작 원리"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2021/06/05/spring-batch-reader-performance/"
                    data-tooltip="Spring Batch Reader 성능 분석 및 측정 part 1"
                    aria-label="다음: Spring Batch Reader 성능 분석 및 측정 part 1"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/2021/06/13/spring-batch-reader-performance-2/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/2021/06/13/spring-batch-reader-performance-2/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cheese10yun.github.io/2021/06/13/spring-batch-reader-performance-2/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="5">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/2021/06/13/spring-batch-reader-performance-2/"
                        aria-label="Facebook에 공유하기"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Facebook에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/2021/06/13/spring-batch-reader-performance-2/"
                        aria-label="Twitter에 공유하기"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Twitter에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://cheese10yun.github.io/2021/06/13/spring-batch-reader-performance-2/"
                        aria-label="Google+에 공유하기"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Google+에 공유하기</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
            <h4 id="about-card-name">Yun</h4>
        
            <div id="about-card-bio"><p>기술 블로그</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
