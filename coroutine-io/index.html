
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="google-site-verification" content="sBAfGubPxv1ol5QEVGgOJ4ggp5spK-zFFXpK-Pd2xZM" />
    <meta name="naver-site-verification" content="a37ea649edf26e70c3de94f9cb034f9d6e11de3f" />
    <meta name="generator" content="Yun Blog">
    <title>코루틴 Dispatchers.IO로 블록킹 문제 해결하기 - Yun Blog</title>
    <meta name="author" content="Yun">
    
        <meta name="keywords" content="Node,Spring,Spring Boot,Spring Batch,Kotlin,기술 블로그,JPA,Mongo,MySQL,OOP,">
    
    
    
        
            <link rel="alternate" type="application/rss+xml" title="RSS" href="/rss2.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg"},"articleBody":"서론#Kotlin 코루틴은 복잡한 스레드 관리와 동시성 문제를 간단하게 해결할 수 있는 강력한 도구입니다. 이 글에서는 특히 I&#x2F;O 작업에 최적화된 Dispatchers.IO에 집중하여, 이 디스패처가 어떻게 스레드 블록킹 문제를 해결하고 전체 애플리케이션의 성능과 반응성을 개선할 수 있는지 구체적인 코드 예제와 실행 로그를 통해 살펴봅니다. 또한, JDBC 드라이버나 파일 입출력, 동기식 네트워크 호출 등 블록킹이 발생할 수 있는 실제 상황에서 Dispatchers.IO를 적용하는 방법과 그 효과를 자세히 설명하여, 개발자가 실제 프로젝트에서 효율적인 비동기 처리를 구현할 수 있도록 돕는 것을 주요 목적으로 합니다.\nDispatchers 종류 비교#아래 테이블은 각 디스패처의 특징과 사용 용도를 간략하게 정리한 것입니다.\n\n\n\n디스패처\n설명\n사용 시나리오\n실행 스레드 예시\n\n\n\nDispatchers.Main\nUI 스레드에서 실행되며, 메인 스레드 업데이트를 담당합니다.\nUI 업데이트, 사용자 이벤트 처리\nAndroid의 메인 스레드 등\n\n\nDispatchers.Default\nCPU 집약적인 작업에 적합하며, 공용 스레드 풀을 사용합니다.\n복잡한 계산, 데이터 처리\n일반적인 백그라운드 작업 스레드\n\n\nDispatchers.Unconfined\n호출한 컨텍스트에 묶이지 않고, 일시적으로 다른 스레드에서 실행될 수 있습니다.\n빠른 초기 작업, 스레드 전환 없이 동작 확인 시\n컨텍스트에 따라 달라짐\n\n\nDispatchers.IO\nI&#x2F;O 작업에 최적화된 별도의 스레드 풀을 사용하며, 블록킹 작업에 대응할 수 있습니다.\n파일 I&#x2F;O, 네트워크, DB 접근 등 블록킹이 발생하는 작업\n“DefaultDispatcher-worker-#” 와 같은 I&#x2F;O 전용 스레드\n\n\nDispatchers.IO는 특히 I&#x2F;O 작업에서 스레드가 블록킹(blocking) 되는 상황에 적합하여, 별도의 스레드 풀을 사용함으로써 전체 애플리케이션의 응답성을 유지하는 데 큰 역할을 합니다.이번 포스팅에서는 특히 Dispatchers.IO에 대해 자세히 알아보고, 이를 통해 효율적인 비동기 처리와 블록킹 문제 해결 방안을 알아보겠습니다.\nDispatchers.IO 사용 시나리오#Dispatchers.IO를 도입해야 하는 대표적인 경우는 스레드가 블록킹될 때입니다. 예를 들어\n\nJDBC 드라이버: JDBC 드라이버는 네트워크 I&#x2F;O나 DB 쿼리 실행 중 스레드를 블록킹합니다.\n파일 입출력: 파일을 읽거나 쓰는 작업 역시 블록킹 될 수 있습니다.\n네트워크 요청: 동기 방식의 네트워크 호출 역시 블록킹을 유발할 수 있습니다.\n\n이와 같이 블록킹 작업이 발생하면, 동일 스레드에서 순차적으로 실행될 경우 전체 애플리케이션의 성능 저하로 이어질 수 있으므로, Dispatchers.IO를 통해 별도의 스레드 풀에서 작업을 처리하여 동시 실행(parallel execution)을 보장하는 것이 중요합니다.\n아래는 async()를 호출할 때 별도의 디스패처를 지정하지 않은 경우의 코드 예제와 그에 따른 실행 로그를 바탕으로 병렬 실행이 어떻게 이루어지는지 구체적으로 설명한 내용입니다.\nDispatchers.IO 코드 예제 분석#123456789101112131415161718192021222324252627282930@Testfun `동시성 테스트`() &#123;    runBlocking &#123;        println(&quot;Main 시작 - 실행 스레드: $&#123;Thread.currentThread().name&#125;&quot;)        val stopWatch = StopWatch()        stopWatch.start()        val deferred1 = async &#123; doSomething(&quot;deferred1&quot;) &#125;        val deferred2 = async &#123; doSomething(&quot;deferred2&quot;) &#125;        // 결과 대기        val resultDefault = deferred1.await()        println(&quot;deferred1 결과: $resultDefault - 호출 스레드: $&#123;Thread.currentThread().name&#125;&quot;)        val resultIO = deferred2.await()        println(&quot;deferred2 결과: $resultIO - 호출 스레드: $&#123;Thread.currentThread().name&#125;&quot;)        stopWatch.stop()        println(&quot;소요 시간 : $&#123;stopWatch.totalTimeMillis&#125; ms&quot;)        println(&quot;Main 종료 - 실행 스레드: $&#123;Thread.currentThread().name&#125;&quot;)    &#125;&#125;private fun doSomething(dispatchersName: String): String &#123;    println(&quot;[$dispatchersName] 시작 - 실행 스레드: $&#123;Thread.currentThread().name&#125;&quot;)    // 2,000 ms 대기    runBlocking &#123; delay(2000) &#125;    println(&quot;[$dispatchersName] 완료 - 실행 스레드: $&#123;Thread.currentThread().name&#125;&quot;)    return &quot;Result from $dispatchersName&quot;&#125;\n\nasync()를 호출할 때 별도의 디스패처를 지정하지 않으면, 해당 코루틴은 상위 코루틴의 컨텍스트(여기서는 runBlocking의 컨텍스트)를 그대로 상속받게 됩니다. 이 예제에서는 doSomething() 함수가 두 번 호출되며, 각각 2,000ms의 지연(delay)을 포함한 블록킹 작업을 수행한다고 가정합니다. 이 경우, 두 작업은 async를 통해 병렬로 실행되므로 이론상 전체 소요 시간은 2,000ms 내외여야 합니다.\n실제 실행 로그는 다음과 같습니다.\n123456789Main 시작 - 실행 스레드: Test worker @coroutine#1[deferred1] 시작 - 실행 스레드: Test worker @coroutine#2[deferred2] 시작 - 실행 스레드: Test worker @coroutine#3[deferred2] 완료 - 실행 스레드: Test worker @coroutine#3[deferred1] 완료 - 실행 스레드: Test worker @coroutine#2deferred1 결과: Result from deferred1 - 호출 스레드: Test worker @coroutine#1deferred2 결과: Result from deferred2 - 호출 스레드: Test worker @coroutine#1소요 시간 : 2020 msMain 종료 - 실행 스레드: Test worker @coroutine#1\n\n로그를 분석해보면, Main 코루틴은 “Test worker @coroutine#1” 스레드에서 시작되고, async로 생성된 두 자식 코루틴은 각각 “Test worker @coroutine#2”와 “Test worker @coroutine#3” 스레드에서 실행됩니다. 두 코루틴은 독립적으로 동시에 실행되기 때문에, doSomething() 함수 내에서 2,000ms의 대기가 발생하더라도 두 작업이 병렬로 처리되어 전체 소요 시간은 약 2,000ms(실제 2020ms)로 측정됩니다.\n즉, async()를 통해 생성된 두 코루틴이 부모의 컨텍스트를 상속받더라도, 각각의 코루틴이 별도의 스레드에서 실행되어 병렬 처리가 이루어지는 것을 확인할 수 있습니다. 이는 동일한 스레드에서 순차적으로 처리될 경우(예: 동기 호출 시 4,000ms 소요)와 비교했을 때, 전체 실행 시간을 크게 단축시키는 효과가 있음을 보여줍니다.\n기본 async() 사용 시 동작 (Thread.sleep 사용)#아래 코드는 doSomething() 함수 내부에서 delay(2000) 대신 Thread.sleep(2000)을 사용한 경우입니다.\n1234567private fun doSomething(dispatchersName: String): String &#123;    println(&quot;[$dispatchersName] 시작 - 실행 스레드: $&#123;Thread.currentThread().name&#125;&quot;)    // 2,000 ms 대기 (Thread.sleep 사용)    Thread.sleep(2000)    println(&quot;[$dispatchersName] 완료 - 실행 스레드: $&#123;Thread.currentThread().name&#125;&quot;)    return &quot;Result from $dispatchersName&quot;&#125;\n\n이 경우 실행 로그는 다음과 같이 나타납니다.\n123456789Main 시작 - 실행 스레드: Test worker @coroutine#1[deferred1] 시작 - 실행 스레드: Test worker @coroutine#2[deferred1] 완료 - 실행 스레드: Test worker @coroutine#2[deferred2] 시작 - 실행 스레드: Test worker @coroutine#3[deferred2] 완료 - 실행 스레드: Test worker @coroutine#3deferred1 결과: Result from deferred1 - 호출 스레드: Test worker @coroutine#1deferred2 결과: Result from deferred2 - 호출 스레드: Test worker @coroutine#1소요 시간 : 4021 msMain 종료 - 실행 스레드: Test worker @coroutine#1\n\n기본 async() 사용 시 동작(Thread.sleep 사용)에서는, 별도의 디스패처를 지정하지 않아 상위 코루틴의 컨텍스트를 그대로 상속받게 됩니다. 이 경우, runBlocking 내부의 메인 스레드인 Test worker가 블로킹되기 때문에, doSomething() 함수 내의 Thread.sleep(2000)이 호출되면 해당 스레드가 2,000ms 동안 점유되고, 첫 번째 코루틴(deferred1)이 완료되어야만 두 번째 코루틴(deferred2)이 실행될 수 있습니다. 그 결과, 두 작업이 실제로 순차적으로 실행되어 전체 소요 시간이 약 4021ms로 측정되는 것입니다.\nDispatchers.IO를 적용한 경우#이 문제를 해결하기 위해 async() 호출 시 Dispatchers.IO를 지정하면, 각 코루틴이 I&#x2F;O 전용 스레드 풀에서 실행되므로 별도의 스레드에서 동시에 작업이 수행됩니다. 수정된 코드는 다음과 같습니다.\n12val deferred1 = async(Dispatchers.IO) &#123; doSomething(&quot;deferred1&quot;) &#125;val deferred2 = async(Dispatchers.IO) &#123; doSomething(&quot;deferred2&quot;) &#125;\n\n이때 실행 로그는 아래와 같이 나타납니다.\n123456789Main 시작 - 실행 스레드: Test worker @coroutine#1[deferred2] 시작 - 실행 스레드: DefaultDispatcher-worker-3 @coroutine#3[deferred1] 시작 - 실행 스레드: DefaultDispatcher-worker-1 @coroutine#2[deferred2] 완료 - 실행 스레드: DefaultDispatcher-worker-3 @coroutine#3[deferred1] 완료 - 실행 스레드: DefaultDispatcher-worker-1 @coroutine#2deferred1 결과: Result from deferred1 - 호출 스레드: Test worker @coroutine#1deferred2 결과: Result from deferred2 - 호출 스레드: Test worker @coroutine#1소요 시간 : 2018 msMain 종료 - 실행 스레드: Test worker @coroutine#1\n\n여기서 확인할 수 있듯이, Main 코루틴은 Test worker에서 시작하지만, deferred1과 deferred2 코루틴은 각각 DefaultDispatcher-worker-1과 DefaultDispatcher-worker-3과 같이 별도의 스레드에서 실행됩니다. 각 코루틴이 독립된 스레드에서 실행되기 때문에, doSomething() 함수 내부의 Thread.sleep(2000)과 같은 블록킹 호출이 해당 코루틴의 스레드에만 영향을 미치며, 다른 코루틴의 실행에는 영향을 주지 않습니다. 그 결과, 두 작업이 동시에 병렬로 실행되어 전체 소요 시간이 약 2018ms로 단축되는 효과를 얻을 수 있습니다.\n1234567private fun doSomething(dispatchersName: String): String &#123;    // ...    // runBlocking &#123; delay(2000) &#125; // delay 에서 Thread sleep 으로 대체    Thread.sleep(2000)    // ...    return &quot;Result from $dispatchersName&quot;&#125;\n\n기존 delay에서 Thread.sleep(2000) 으로 변경 했을 경우에 로그를 보자\n123456789Main 시작 - 실행 스레드: Test worker @coroutine#1[deferred1] 시작 - 실행 스레드: Test worker @coroutine#2[deferred1] 완료 - 실행 스레드: Test worker @coroutine#2[deferred2] 시작 - 실행 스레드: Test worker @coroutine#3[deferred2] 완료 - 실행 스레드: Test worker @coroutine#3deferred1 결과: Result from deferred1 - 호출 스레드: Test worker @coroutine#1deferred2 결과: Result from deferred1 - 호출 스레드: Test worker @coroutine#1소요 시간 : 4021 msMain 종료 - 실행 스레드: Test worker @coroutine#1\n\ndoSomething() 함수가 @coroutine#2와 @coroutine#3에서 각각 실행되었음에도 불구하고, 전체 소요 시간이 4021ms로 측정된다는 것은 async()를 사용할 때 의도한 병렬 실행이 이루어지지 않았음을 의미합니다. 그 이유는, async()에 별도의 디스패처를 지정하지 않아 상위 코루틴(runBlocking)의 컨텍스트를 그대로 상속받게 되면서, Main 스레드인 Test worker가 deferred1의 실행으로 인해 블록킹되고, deferred2도 동일한 Test worker에서 실행되기 때문입니다. 즉, Test worker 스레드가 블록킹이 해제될 때까지 전체 작업이 순차적으로 실행됩니다.\n이 문제를 해결하기 위해, 각 async() 호출 시 Dispatchers.IO와 같이 별도의 I&#x2F;O 전용 스레드 풀을 지정하면, 각 코루틴이 상위 컨텍스트를 상속받지 않고 독립적인 스레드에서 실행되게 됩니다. 다음과 같이 코드를 수정하면, deferred1과 deferred2가 각각 다른 스레드에서 동시에 블록킹 작업을 수행하므로, 전체 소요 시간이 약 2000ms 내외로 단축됩니다.\n12val deferred1 = async(Dispatchers.IO) &#123; doSomething(&quot;deferred1&quot;) &#125;val deferred2 = async(Dispatchers.IO) &#123; doSomething(&quot;deferred2&quot;) &#125;\n\n이렇게 수정한 후 로그를 확인하면, Main 코루틴은 여전히 Test worker에서 실행되지만, deferred1은 DefaultDispatcher-worker-1, deferred2는 DefaultDispatcher-worker-3과 같이 서로 다른 스레드에서 실행되어 병렬 처리가 이루어지는 것을 확인할 수 있습니다.\n123456789Main 시작 - 실행 스레드: Test worker @coroutine#1[deferred2] 시작 - 실행 스레드: DefaultDispatcher-worker-3 @coroutine#3[deferred1] 시작 - 실행 스레드: DefaultDispatcher-worker-1 @coroutine#2[deferred2] 완료 - 실행 스레드: DefaultDispatcher-worker-3 @coroutine#3[deferred1] 완료 - 실행 스레드: DefaultDispatcher-worker-1 @coroutine#2deferred1 결과: Result from deferred1 - 호출 스레드: Test worker @coroutine#1deferred2 결과: Result from deferred1 - 호출 스레드: Test worker @coroutine#1소요 시간 : 2018 msMain 종료 - 실행 스레드: Test worker @coroutine#1\n\nTest worker 으로 메인 스레드가 시작하는 것을 확인할 수 있고 deferred1, deferred2의 수행 스레드가 DefaultDispatcher-worker-1, DefaultDispatcher-worker-3 으로 각기 다른 스레드를 통해서 수행되는 것을 확인할 수 있습니다.\n각기 다른 스레드로 동작하기 때문에 각각의 스레드가 블록킹 당해도 동시에 수행이 가능하며 소요 시간이 2018 ms 으로 동작하는 것을 확인할 수 있습니다. 이 처럼 스레드가 블록킹 당하는 경우라면 Dispatchers.IO 가 적절한 대안이 될 수 있습니다.\n실제 사례: JDBC 드라이버와 블록킹 문제#다음은 JDBC 드라이버를 사용하는 페이징 쿼리 예제입니다. 아래 코드에서는 content와 totalCount 두 쿼리를 동시에 실행하도록 작성되었지만, async()에 별도의 디스패처를 지정하지 않아 모든 코루틴이 runBlocking의 컨텍스트를 상속받아 동일한 스레드에서 순차적으로 실행됩니다.\n12345678910111213141516171819202122override fun findPagingBy(pageable: Pageable, address: String): Page&lt;Order&gt; = runBlocking &#123;  log.info(&quot;findPagingBy thread : $&#123;Thread.currentThread()&#125;&quot;)  val content: Deferred&lt;List&lt;Order&gt;&gt; = async() &#123;    log.info(&quot;content thread : $&#123;Thread.currentThread()&#125;&quot;)    from(order)      .select(order)      .innerJoin(user).on(order.userId.eq(user.id))      .leftJoin(coupon).on(order.couponId.eq(coupon.id))      .where(order.address.eq(address))      .run &#123;        querydsl.applyPagination(pageable, this).fetch()      &#125;  &#125;  val totalCount: Deferred&lt;Long&gt; = async() &#123;    log.info(&quot;count thread : $&#123;Thread.currentThread()&#125;&quot;)    from(order)      .select(order.count())      .where(order.address.eq(address))      .fetchFirst()  &#125;  PageImpl(content.await(), pageable, totalCount.await())&#125;\n\n아래 이미지는 위 코드가 실행되었을 때의 로그를 보여줍니다.\n\n여기서 특히 강조해야 할 점은, JDBC 드라이버가 기본적으로 블록킹 I&#x2F;O를 수행한다는 것입니다. JDBC 드라이버는 데이터베이스와의 통신 과정에서 네트워크 I&#x2F;O 및 쿼리 실행을 진행하는 동안 스레드를 블록킹합니다. 이로 인해 동일한 스레드에서 쿼리가 순차적으로 실행될 경우, 한 쿼리의 블록킹이 다른 쿼리의 실행까지 지연시키게 됩니다. 위 예제에서는 async()에 별도의 디스패처를 지정하지 않아, content와 totalCount 쿼리가 모두 runBlocking의 컨텍스트인 동일한 스레드에서 실행됩니다. 이로 인해 한 쿼리의 작업이 완료되어야만 다음 쿼리가 실행되므로 전체 성능 저하와 응답성 저하가 발생할 수 있습니다.\n이를 해결하기 위해, 아래와 같이 async() 호출 시 Dispatchers.IO와 같은 I&#x2F;O 전용 스레드 풀을 지정하면, 각 코루틴이 독립된 별도의 스레드에서 실행됩니다.\n12val content: Deferred&lt;List&lt;Order&gt;&gt; = async(Dispatchers.IO) &#123; ... &#125;val totalCount: Deferred&lt;Long&gt; = async(Dispatchers.IO) &#123; ... &#125;\n\n이렇게 하면 JDBC 드라이버의 블록킹 특성에도 불구하고, 각 쿼리가 독립적으로 다른 스레드에서 병렬로 실행되므로, 한 쿼리의 블록킹이 다른 쿼리의 실행에 영향을 주지 않습니다. 실제로 이 방식으로 실행할 경우, 전체 성능이 크게 향상되어 병렬 처리의 이점을 얻을 수 있습니다.\n새롭게 추가된 로그 이미지를 보면, Main 코루틴은 여전히 동일한 스레드에서 실행되지만, content와 totalCount 코루틴은 각각 “DefaultDispatcher-worker-1” 및 “DefaultDispatcher-worker-3”과 같은 별도의 스레드에서 실행되어, 동시에 작업을 수행할 수 있습니다. 이와 같이, 블록킹 I&#x2F;O가 발생하는 환경에서는 Dispatchers.IO를 활용하여 각 작업을 독립적인 스레드에서 처리하는 것이 전체 시스템의 응답성과 성능 개선에 효과적입니다.\n결론#이번 포스팅에서는 Kotlin 코루틴의 Dispatchers.IO가 어떻게 블록킹 I&#x2F;O 작업, 특히 JDBC 드라이버나 파일 입출력과 같은 상황에서 전체 애플리케이션의 성능과 반응성을 개선하는 데 기여하는지 살펴보았습니다. 기본적으로 async()를 호출할 때 별도의 디스패처를 지정하지 않으면, 상위 코루틴의 컨텍스트를 그대로 상속받아 동일한 스레드에서 순차적으로 실행되기 때문에, 블록킹 작업이 발생할 경우 전체 실행 시간이 크게 늘어나는 문제가 발생합니다. 그러나, Dispatchers.IO를 지정하면 각 코루틴이 I&#x2F;O 전용 스레드 풀의 독립된 스레드에서 실행되어, 한 작업의 블록킹이 다른 작업에 영향을 주지 않고 병렬 처리가 가능해집니다. 이를 통해 실제 작업에서는 전체 처리 시간이 단축되고, 시스템의 응답성이 크게 향상됨을 확인할 수 있습니다.\n이와 같이 Dispatchers.IO를 적절히 활용하면, 블록킹 I&#x2F;O로 인한 성능 저하를 효과적으로 극복할 수 있으며, 효율적인 비동기 처리와 병렬 실행을 통해 더욱 안정적이고 반응성이 뛰어난 애플리케이션을 구현할 수 있습니다.\n","dateCreated":"2025-03-24T00:00:00+09:00","dateModified":"2025-03-24T01:39:37+09:00","datePublished":"2025-03-24T00:00:00+09:00","description":"Kotlin 코루틴의 Dispatchers.IO를 활용하면 블록킹 I/O 문제를 극복하고, 병렬 처리로 애플리케이션의 성능과 반응성을 크게 향상시킬 수 있습니다.","headline":"코루틴 Dispatchers.IO로 블록킹 문제 해결하기","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://cheese10yun.github.io/coroutine-io/"},"publisher":{"@type":"Organization","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg","logo":{"@type":"ImageObject","url":"yun-icon.jpg"}},"url":"https://cheese10yun.github.io/coroutine-io/","keywords":"Coroutines"}</script>
    <meta name="description" content="Kotlin 코루틴의 Dispatchers.IO를 활용하면 블록킹 I&#x2F;O 문제를 극복하고, 병렬 처리로 애플리케이션의 성능과 반응성을 크게 향상시킬 수 있습니다.">
<meta property="og:type" content="blog">
<meta property="og:title" content="코루틴 Dispatchers.IO로 블록킹 문제 해결하기">
<meta property="og:url" content="https://cheese10yun.github.io/coroutine-io/index.html">
<meta property="og:site_name" content="Yun Blog">
<meta property="og:description" content="Kotlin 코루틴의 Dispatchers.IO를 활용하면 블록킹 I&#x2F;O 문제를 극복하고, 병렬 처리로 애플리케이션의 성능과 반응성을 크게 향상시킬 수 있습니다.">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/refs/heads/master/kotlin-coroutine/images/00001.png">
<meta property="article:published_time" content="2025-03-23T15:00:00.000Z">
<meta property="article:modified_time" content="2025-03-23T16:39:37.504Z">
<meta property="article:author" content="Yun">
<meta property="article:tag" content="Coroutines">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/refs/heads/master/kotlin-coroutine/images/00001.png">
    
    
        
    
    
        <meta property="og:image" content="https://cheese10yun.github.io/assets/images/yun-icon.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90907312-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-90907312-1');
    </script>


    

    
        
    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5813739623204880" crossorigin="anonymous"></script>
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="5">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Yun Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="링크 열기: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="5">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="저자에 대해 더 알아보기"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
                </a>
                <h4 class="sidebar-profile-name">Yun</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기술 블로그</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="태그"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="아카이브"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">아카이브</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/cheese10yun"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/rss2.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="5"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            코루틴 Dispatchers.IO로 블록킹 문제 해결하기
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2025-03-24T00:00:00+09:00">
	
		    2025/03/24
    	
    </time>
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h2><span id="seoron">서론</span><a href="#seoron" class="header-anchor">#</a></h2><p>Kotlin 코루틴은 복잡한 스레드 관리와 동시성 문제를 간단하게 해결할 수 있는 강력한 도구입니다. 이 글에서는 특히 I&#x2F;O 작업에 최적화된 <code>Dispatchers.IO</code>에 집중하여, 이 디스패처가 어떻게 스레드 블록킹 문제를 해결하고 전체 애플리케이션의 성능과 반응성을 개선할 수 있는지 구체적인 코드 예제와 실행 로그를 통해 살펴봅니다. 또한, JDBC 드라이버나 파일 입출력, 동기식 네트워크 호출 등 블록킹이 발생할 수 있는 실제 상황에서 <code>Dispatchers.IO</code>를 적용하는 방법과 그 효과를 자세히 설명하여, 개발자가 실제 프로젝트에서 효율적인 비동기 처리를 구현할 수 있도록 돕는 것을 주요 목적으로 합니다.</p>
<h2><span id="dispatchers-jongryu-bigyo">Dispatchers 종류 비교</span><a href="#dispatchers-jongryu-bigyo" class="header-anchor">#</a></h2><p>아래 테이블은 각 디스패처의 특징과 사용 용도를 간략하게 정리한 것입니다.</p>
<table>
<thead>
<tr>
<th><strong>디스패처</strong></th>
<th><strong>설명</strong></th>
<th><strong>사용 시나리오</strong></th>
<th><strong>실행 스레드 예시</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Dispatchers.Main</td>
<td>UI 스레드에서 실행되며, 메인 스레드 업데이트를 담당합니다.</td>
<td>UI 업데이트, 사용자 이벤트 처리</td>
<td>Android의 메인 스레드 등</td>
</tr>
<tr>
<td>Dispatchers.Default</td>
<td>CPU 집약적인 작업에 적합하며, 공용 스레드 풀을 사용합니다.</td>
<td>복잡한 계산, 데이터 처리</td>
<td>일반적인 백그라운드 작업 스레드</td>
</tr>
<tr>
<td>Dispatchers.Unconfined</td>
<td>호출한 컨텍스트에 묶이지 않고, 일시적으로 다른 스레드에서 실행될 수 있습니다.</td>
<td>빠른 초기 작업, 스레드 전환 없이 동작 확인 시</td>
<td>컨텍스트에 따라 달라짐</td>
</tr>
<tr>
<td>Dispatchers.IO</td>
<td>I&#x2F;O 작업에 최적화된 별도의 스레드 풀을 사용하며, 블록킹 작업에 대응할 수 있습니다.</td>
<td>파일 I&#x2F;O, 네트워크, DB 접근 등 블록킹이 발생하는 작업</td>
<td>“DefaultDispatcher-worker-#” 와 같은 I&#x2F;O 전용 스레드</td>
</tr>
</tbody></table>
<p><code>Dispatchers.IO</code>는 특히 I&#x2F;O 작업에서 스레드가 블록킹(blocking) 되는 상황에 적합하여, 별도의 스레드 풀을 사용함으로써 전체 애플리케이션의 응답성을 유지하는 데 큰 역할을 합니다.<br>이번 포스팅에서는 특히 <code>Dispatchers.IO</code>에 대해 자세히 알아보고, 이를 통해 효율적인 비동기 처리와 블록킹 문제 해결 방안을 알아보겠습니다.</p>
<h2><span id="dispatchers-io-sayong-sinario">Dispatchers.IO 사용 시나리오</span><a href="#dispatchers-io-sayong-sinario" class="header-anchor">#</a></h2><p><code>Dispatchers.IO</code>를 도입해야 하는 대표적인 경우는 <strong>스레드가 블록킹될 때</strong>입니다. 예를 들어</p>
<ul>
<li><strong>JDBC 드라이버:</strong> JDBC 드라이버는 네트워크 I&#x2F;O나 DB 쿼리 실행 중 스레드를 블록킹합니다.</li>
<li><strong>파일 입출력:</strong> 파일을 읽거나 쓰는 작업 역시 블록킹 될 수 있습니다.</li>
<li><strong>네트워크 요청:</strong> 동기 방식의 네트워크 호출 역시 블록킹을 유발할 수 있습니다.</li>
</ul>
<p>이와 같이 블록킹 작업이 발생하면, 동일 스레드에서 순차적으로 실행될 경우 전체 애플리케이션의 성능 저하로 이어질 수 있으므로, <strong><code>Dispatchers.IO</code>를 통해 별도의 스레드 풀에서 작업을 처리하여 동시 실행(parallel execution)을 보장하는 것이 중요합니다.</strong></p>
<p>아래는 async()를 호출할 때 별도의 디스패처를 지정하지 않은 경우의 코드 예제와 그에 따른 실행 로그를 바탕으로 병렬 실행이 어떻게 이루어지는지 구체적으로 설명한 내용입니다.</p>
<h2><span id="dispatchers-io-kodeu-yeje-bunseog">Dispatchers.IO 코드 예제 분석</span><a href="#dispatchers-io-kodeu-yeje-bunseog" class="header-anchor">#</a></h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `동시성 테스트`<span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        println(<span class="string">&quot;Main 시작 - 실행 스레드: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> stopWatch = StopWatch()</span><br><span class="line">        stopWatch.start()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> deferred1 = async &#123; doSomething(<span class="string">&quot;deferred1&quot;</span>) &#125;</span><br><span class="line">        <span class="keyword">val</span> deferred2 = async &#123; doSomething(<span class="string">&quot;deferred2&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 결과 대기</span></span><br><span class="line">        <span class="keyword">val</span> resultDefault = deferred1.await()</span><br><span class="line">        println(<span class="string">&quot;deferred1 결과: <span class="variable">$resultDefault</span> - 호출 스레드: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> resultIO = deferred2.await()</span><br><span class="line">        println(<span class="string">&quot;deferred2 결과: <span class="variable">$resultIO</span> - 호출 스레드: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        stopWatch.stop()</span><br><span class="line">        println(<span class="string">&quot;소요 시간 : <span class="subst">$&#123;stopWatch.totalTimeMillis&#125;</span> ms&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Main 종료 - 실행 스레드: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(dispatchersName: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    println(<span class="string">&quot;[<span class="variable">$dispatchersName</span>] 시작 - 실행 스레드: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment">// 2,000 ms 대기</span></span><br><span class="line">    runBlocking &#123; delay(<span class="number">2000</span>) &#125;</span><br><span class="line">    println(<span class="string">&quot;[<span class="variable">$dispatchersName</span>] 완료 - 실행 스레드: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Result from <span class="variable">$dispatchersName</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>async()</code>를 호출할 때 별도의 디스패처를 지정하지 않으면, 해당 코루틴은 상위 코루틴의 컨텍스트(여기서는 runBlocking의 컨텍스트)를 그대로 상속받게 됩니다. 이 예제에서는 <code>doSomething()</code> 함수가 두 번 호출되며, 각각 2,000ms의 지연(delay)을 포함한 블록킹 작업을 수행한다고 가정합니다. 이 경우, 두 작업은 <code>async</code>를 통해 병렬로 실행되므로 이론상 전체 소요 시간은 2,000ms 내외여야 합니다.</p>
<p>실제 실행 로그는 다음과 같습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Main 시작 - 실행 스레드: Test worker @coroutine#1</span><br><span class="line">[deferred1] 시작 - 실행 스레드: Test worker @coroutine#2</span><br><span class="line">[deferred2] 시작 - 실행 스레드: Test worker @coroutine#3</span><br><span class="line">[deferred2] 완료 - 실행 스레드: Test worker @coroutine#3</span><br><span class="line">[deferred1] 완료 - 실행 스레드: Test worker @coroutine#2</span><br><span class="line">deferred1 결과: Result from deferred1 - 호출 스레드: Test worker @coroutine#1</span><br><span class="line">deferred2 결과: Result from deferred2 - 호출 스레드: Test worker @coroutine#1</span><br><span class="line">소요 시간 : 2020 ms</span><br><span class="line">Main 종료 - 실행 스레드: Test worker @coroutine#1</span><br></pre></td></tr></table></figure>

<p>로그를 분석해보면, Main 코루틴은 “Test worker @coroutine#1” 스레드에서 시작되고, async로 생성된 두 자식 코루틴은 각각 “Test worker @coroutine#2”와 “Test worker @coroutine#3” 스레드에서 실행됩니다. 두 코루틴은 독립적으로 동시에 실행되기 때문에, <code>doSomething()</code> 함수 내에서 2,000ms의 대기가 발생하더라도 두 작업이 병렬로 처리되어 전체 소요 시간은 약 2,000ms(실제 2020ms)로 측정됩니다.</p>
<p><strong>즉, <code>async()</code>를 통해 생성된 두 코루틴이 부모의 컨텍스트를 상속받더라도, 각각의 코루틴이 별도의 스레드에서 실행되어 병렬 처리가 이루어지는 것을 확인할 수 있습니다.</strong> 이는 동일한 스레드에서 순차적으로 처리될 경우(예: 동기 호출 시 4,000ms 소요)와 비교했을 때, 전체 실행 시간을 크게 단축시키는 효과가 있음을 보여줍니다.</p>
<h3><span id="gibon-async-sayong-si-dongjag-thread-sleep-sayong">기본 async() 사용 시 동작 (Thread.sleep 사용)</span><a href="#gibon-async-sayong-si-dongjag-thread-sleep-sayong" class="header-anchor">#</a></h3><p>아래 코드는 <code>doSomething()</code> 함수 내부에서 <code>delay(2000)</code> 대신 <code>Thread.sleep(2000)</code>을 사용한 경우입니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(dispatchersName: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    println(<span class="string">&quot;[<span class="variable">$dispatchersName</span>] 시작 - 실행 스레드: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment">// 2,000 ms 대기 (Thread.sleep 사용)</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">    println(<span class="string">&quot;[<span class="variable">$dispatchersName</span>] 완료 - 실행 스레드: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Result from <span class="variable">$dispatchersName</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이 경우 실행 로그는 다음과 같이 나타납니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Main 시작 - 실행 스레드: Test worker @coroutine#1</span><br><span class="line">[deferred1] 시작 - 실행 스레드: Test worker @coroutine#2</span><br><span class="line">[deferred1] 완료 - 실행 스레드: Test worker @coroutine#2</span><br><span class="line">[deferred2] 시작 - 실행 스레드: Test worker @coroutine#3</span><br><span class="line">[deferred2] 완료 - 실행 스레드: Test worker @coroutine#3</span><br><span class="line">deferred1 결과: Result from deferred1 - 호출 스레드: Test worker @coroutine#1</span><br><span class="line">deferred2 결과: Result from deferred2 - 호출 스레드: Test worker @coroutine#1</span><br><span class="line">소요 시간 : 4021 ms</span><br><span class="line">Main 종료 - 실행 스레드: Test worker @coroutine#1</span><br></pre></td></tr></table></figure>

<p>기본 async() 사용 시 동작(<code>Thread.sleep</code> 사용)에서는, 별도의 디스패처를 지정하지 않아 상위 코루틴의 컨텍스트를 그대로 상속받게 됩니다. 이 경우, runBlocking 내부의 메인 스레드인 Test worker가 블로킹되기 때문에, <code>doSomething()</code> 함수 내의 <code>Thread.sleep(2000)</code>이 호출되면 해당 스레드가 2,000ms 동안 점유되고, 첫 번째 코루틴(deferred1)이 완료되어야만 두 번째 코루틴(deferred2)이 실행될 수 있습니다. 그 결과, 두 작업이 실제로 순차적으로 실행되어 전체 소요 시간이 약 4021ms로 측정되는 것입니다.</p>
<h3><span id="dispatchers-ioreul-jeogyonghan-gyeongu">Dispatchers.IO를 적용한 경우</span><a href="#dispatchers-ioreul-jeogyonghan-gyeongu" class="header-anchor">#</a></h3><p>이 문제를 해결하기 위해 async() 호출 시 <code>Dispatchers.IO</code>를 지정하면, 각 코루틴이 I&#x2F;O 전용 스레드 풀에서 실행되므로 별도의 스레드에서 동시에 작업이 수행됩니다. 수정된 코드는 다음과 같습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> deferred1 = async(Dispatchers.IO) &#123; doSomething(<span class="string">&quot;deferred1&quot;</span>) &#125;</span><br><span class="line"><span class="keyword">val</span> deferred2 = async(Dispatchers.IO) &#123; doSomething(<span class="string">&quot;deferred2&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>이때 실행 로그는 아래와 같이 나타납니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Main 시작 - 실행 스레드: Test worker @coroutine#1</span><br><span class="line">[deferred2] 시작 - 실행 스레드: DefaultDispatcher-worker-3 @coroutine#3</span><br><span class="line">[deferred1] 시작 - 실행 스레드: DefaultDispatcher-worker-1 @coroutine#2</span><br><span class="line">[deferred2] 완료 - 실행 스레드: DefaultDispatcher-worker-3 @coroutine#3</span><br><span class="line">[deferred1] 완료 - 실행 스레드: DefaultDispatcher-worker-1 @coroutine#2</span><br><span class="line">deferred1 결과: Result from deferred1 - 호출 스레드: Test worker @coroutine#1</span><br><span class="line">deferred2 결과: Result from deferred2 - 호출 스레드: Test worker @coroutine#1</span><br><span class="line">소요 시간 : 2018 ms</span><br><span class="line">Main 종료 - 실행 스레드: Test worker @coroutine#1</span><br></pre></td></tr></table></figure>

<p>여기서 확인할 수 있듯이, Main 코루틴은 Test worker에서 시작하지만, deferred1과 deferred2 코루틴은 각각 DefaultDispatcher-worker-1과 DefaultDispatcher-worker-3과 같이 별도의 스레드에서 실행됩니다. 각 코루틴이 독립된 스레드에서 실행되기 때문에, <code>doSomething()</code> 함수 내부의 <code>Thread.sleep(2000)</code>과 같은 블록킹 호출이 해당 코루틴의 스레드에만 영향을 미치며, 다른 코루틴의 실행에는 영향을 주지 않습니다. 그 결과, 두 작업이 동시에 병렬로 실행되어 전체 소요 시간이 약 2018ms로 단축되는 효과를 얻을 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(dispatchersName: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// runBlocking &#123; delay(2000) &#125; // delay 에서 Thread sleep 으로 대체</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Result from <span class="variable">$dispatchersName</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>기존 delay에서 <code>Thread.sleep(2000)</code> 으로 변경 했을 경우에 로그를 보자</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Main 시작 - 실행 스레드: Test worker @coroutine#1</span><br><span class="line">[deferred1] 시작 - 실행 스레드: Test worker @coroutine#2</span><br><span class="line">[deferred1] 완료 - 실행 스레드: Test worker @coroutine#2</span><br><span class="line">[deferred2] 시작 - 실행 스레드: Test worker @coroutine#3</span><br><span class="line">[deferred2] 완료 - 실행 스레드: Test worker @coroutine#3</span><br><span class="line">deferred1 결과: Result from deferred1 - 호출 스레드: Test worker @coroutine#1</span><br><span class="line">deferred2 결과: Result from deferred1 - 호출 스레드: Test worker @coroutine#1</span><br><span class="line">소요 시간 : 4021 ms</span><br><span class="line">Main 종료 - 실행 스레드: Test worker @coroutine#1</span><br></pre></td></tr></table></figure>

<p><code>doSomething()</code> 함수가 @coroutine#2와 @coroutine#3에서 각각 실행되었음에도 불구하고, 전체 소요 시간이 4021ms로 측정된다는 것은 <code>async()</code>를 사용할 때 의도한 병렬 실행이 이루어지지 않았음을 의미합니다. 그 이유는, <code>async()</code>에 별도의 디스패처를 지정하지 않아 상위 코루틴(runBlocking)의 컨텍스트를 그대로 상속받게 되면서, Main 스레드인 Test worker가 deferred1의 실행으로 인해 블록킹되고, deferred2도 동일한 Test worker에서 실행되기 때문입니다. 즉, Test worker 스레드가 블록킹이 해제될 때까지 전체 작업이 순차적으로 실행됩니다.</p>
<p>이 문제를 해결하기 위해, 각 <code>async()</code> 호출 시 <code>Dispatchers.IO</code>와 같이 별도의 I&#x2F;O 전용 스레드 풀을 지정하면, 각 코루틴이 상위 컨텍스트를 상속받지 않고 독립적인 스레드에서 실행되게 됩니다. 다음과 같이 코드를 수정하면, deferred1과 deferred2가 각각 다른 스레드에서 동시에 블록킹 작업을 수행하므로, 전체 소요 시간이 약 2000ms 내외로 단축됩니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> deferred1 = async(Dispatchers.IO) &#123; doSomething(<span class="string">&quot;deferred1&quot;</span>) &#125;</span><br><span class="line"><span class="keyword">val</span> deferred2 = async(Dispatchers.IO) &#123; doSomething(<span class="string">&quot;deferred2&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>이렇게 수정한 후 로그를 확인하면, Main 코루틴은 여전히 Test worker에서 실행되지만, deferred1은 DefaultDispatcher-worker-1, deferred2는 DefaultDispatcher-worker-3과 같이 서로 다른 스레드에서 실행되어 병렬 처리가 이루어지는 것을 확인할 수 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Main 시작 - 실행 스레드: Test worker @coroutine#1</span><br><span class="line">[deferred2] 시작 - 실행 스레드: DefaultDispatcher-worker-3 @coroutine#3</span><br><span class="line">[deferred1] 시작 - 실행 스레드: DefaultDispatcher-worker-1 @coroutine#2</span><br><span class="line">[deferred2] 완료 - 실행 스레드: DefaultDispatcher-worker-3 @coroutine#3</span><br><span class="line">[deferred1] 완료 - 실행 스레드: DefaultDispatcher-worker-1 @coroutine#2</span><br><span class="line">deferred1 결과: Result from deferred1 - 호출 스레드: Test worker @coroutine#1</span><br><span class="line">deferred2 결과: Result from deferred1 - 호출 스레드: Test worker @coroutine#1</span><br><span class="line">소요 시간 : 2018 ms</span><br><span class="line">Main 종료 - 실행 스레드: Test worker @coroutine#1</span><br></pre></td></tr></table></figure>

<p>Test worker 으로 메인 스레드가 시작하는 것을 확인할 수 있고 deferred1, deferred2의 수행 스레드가 DefaultDispatcher-worker-1, DefaultDispatcher-worker-3 으로 각기 다른 스레드를 통해서 수행되는 것을 확인할 수 있습니다.</p>
<p>각기 다른 스레드로 동작하기 때문에 각각의 스레드가 블록킹 당해도 동시에 수행이 가능하며 소요 시간이 2018 ms 으로 동작하는 것을 확인할 수 있습니다. 이 처럼 스레드가 블록킹 당하는 경우라면 <code>Dispatchers.IO</code> 가 적절한 대안이 될 수 있습니다.</p>
<h2><span id="silje-sarye-jdbc-deuraibeowa-beulrogking-munje">실제 사례: JDBC 드라이버와 블록킹 문제</span><a href="#silje-sarye-jdbc-deuraibeowa-beulrogking-munje" class="header-anchor">#</a></h2><p>다음은 JDBC 드라이버를 사용하는 페이징 쿼리 예제입니다. 아래 코드에서는 content와 totalCount 두 쿼리를 동시에 실행하도록 작성되었지만, <code>async()</code>에 별도의 디스패처를 지정하지 않아 모든 코루틴이 runBlocking의 컨텍스트를 상속받아 동일한 스레드에서 순차적으로 실행됩니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findPagingBy</span><span class="params">(pageable: <span class="type">Pageable</span>, address: <span class="type">String</span>)</span></span>: Page&lt;Order&gt; = runBlocking &#123;</span><br><span class="line">  log.info(<span class="string">&quot;findPagingBy thread : <span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> content: Deferred&lt;List&lt;Order&gt;&gt; = async() &#123;</span><br><span class="line">    log.info(<span class="string">&quot;content thread : <span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">    from(order)</span><br><span class="line">      .select(order)</span><br><span class="line">      .innerJoin(user).on(order.userId.eq(user.id))</span><br><span class="line">      .leftJoin(coupon).on(order.couponId.eq(coupon.id))</span><br><span class="line">      .<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">      .run &#123;</span><br><span class="line">        querydsl.applyPagination(pageable, <span class="keyword">this</span>).fetch()</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> totalCount: Deferred&lt;<span class="built_in">Long</span>&gt; = async() &#123;</span><br><span class="line">    log.info(<span class="string">&quot;count thread : <span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">    from(order)</span><br><span class="line">      .select(order.count())</span><br><span class="line">      .<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">      .fetchFirst()</span><br><span class="line">  &#125;</span><br><span class="line">  PageImpl(content.await(), pageable, totalCount.await())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>아래 이미지는 위 코드가 실행되었을 때의 로그를 보여줍니다.</p>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/refs/heads/master/kotlin-coroutine/images/00001.png"></p>
<p>여기서 특히 강조해야 할 점은, <strong>JDBC 드라이버가 기본적으로 블록킹 I&#x2F;O를 수행한다는 것입니다.</strong> JDBC 드라이버는 데이터베이스와의 통신 과정에서 네트워크 I&#x2F;O 및 쿼리 실행을 진행하는 동안 스레드를 블록킹합니다. 이로 인해 동일한 스레드에서 쿼리가 순차적으로 실행될 경우, 한 쿼리의 블록킹이 다른 쿼리의 실행까지 지연시키게 됩니다. 위 예제에서는 <code>async()</code>에 별도의 디스패처를 지정하지 않아, content와 totalCount 쿼리가 모두 runBlocking의 컨텍스트인 <strong>동일한 스레드에서 실행됩니다. 이로 인해 한 쿼리의 작업이 완료되어야만 다음 쿼리가 실행되므로 전체 성능 저하와 응답성 저하가 발생할 수 있습니다.</strong></p>
<p>이를 해결하기 위해, 아래와 같이 <code>async()</code> 호출 시 <code>Dispatchers.IO</code>와 같은 I&#x2F;O 전용 스레드 풀을 지정하면, 각 코루틴이 독립된 별도의 스레드에서 실행됩니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> content: Deferred&lt;List&lt;Order&gt;&gt; = async(Dispatchers.IO) &#123; ... &#125;</span><br><span class="line"><span class="keyword">val</span> totalCount: Deferred&lt;<span class="built_in">Long</span>&gt; = async(Dispatchers.IO) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>이렇게 하면 JDBC 드라이버의 블록킹 특성에도 불구하고, <strong>각 쿼리가 독립적으로 다른 스레드에서 병렬로 실행되므로, 한 쿼리의 블록킹이 다른 쿼리의 실행에 영향을 주지 않습니다.</strong> 실제로 이 방식으로 실행할 경우, 전체 성능이 크게 향상되어 병렬 처리의 이점을 얻을 수 있습니다.</p>
<p>새롭게 추가된 로그 이미지를 보면, Main 코루틴은 여전히 동일한 스레드에서 실행되지만, content와 totalCount 코루틴은 각각 “DefaultDispatcher-worker-1” 및 “DefaultDispatcher-worker-3”과 같은 별도의 스레드에서 실행되어, 동시에 작업을 수행할 수 있습니다. <strong>이와 같이, 블록킹 I&#x2F;O가 발생하는 환경에서는 <code>Dispatchers.IO</code>를 활용하여 각 작업을 독립적인 스레드에서 처리하는 것이 전체 시스템의 응답성과 성능 개선에 효과적입니다.</strong></p>
<h2><span id="gyeolron">결론</span><a href="#gyeolron" class="header-anchor">#</a></h2><p>이번 포스팅에서는 Kotlin 코루틴의 <code>Dispatchers.IO</code>가 어떻게 블록킹 I&#x2F;O 작업, 특히 JDBC 드라이버나 파일 입출력과 같은 상황에서 전체 애플리케이션의 성능과 반응성을 개선하는 데 기여하는지 살펴보았습니다. 기본적으로 <code>async()</code>를 호출할 때 별도의 디스패처를 지정하지 않으면, 상위 코루틴의 컨텍스트를 그대로 상속받아 동일한 스레드에서 순차적으로 실행되기 때문에, 블록킹 작업이 발생할 경우 전체 실행 시간이 크게 늘어나는 문제가 발생합니다. 그러나, <code>Dispatchers.IO</code>를 지정하면 각 코루틴이 I&#x2F;O 전용 스레드 풀의 독립된 스레드에서 실행되어, 한 작업의 블록킹이 다른 작업에 영향을 주지 않고 병렬 처리가 가능해집니다. 이를 통해 실제 작업에서는 전체 처리 시간이 단축되고, 시스템의 응답성이 크게 향상됨을 확인할 수 있습니다.</p>
<p>이와 같이 <code>Dispatchers.IO</code>를 적절히 활용하면, 블록킹 I&#x2F;O로 인한 성능 저하를 효과적으로 극복할 수 있으며, 효율적인 비동기 처리와 병렬 실행을 통해 더욱 안정적이고 반응성이 뛰어난 애플리케이션을 구현할 수 있습니다.</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">태그</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/Coroutines/" rel="tag">Coroutines</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a
                        class="post-action-btn btn btn--disabled"
                        aria-hidden="true"
                    >
                        
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/spring-data-mongodb-update-arrayFilters/"
                    data-tooltip="Spring Data MongoDB로 배열의 특정 요소 업데이트하기"
                    aria-label="다음: Spring Data MongoDB로 배열의 특정 요소 업데이트하기"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/coroutine-io/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/coroutine-io/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        

                
                    <!--  giscus comment -->

<script src="https://giscus.app/client.js"
        data-repo="cheese10yun/blog-comment"
        data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1MDM1OTk="
        data-category="Q&amp;A"
        data-category-id="DIC_kwDODD-8b84CT2XX"
        data-mapping="og:title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-input-position="top"
        data-theme="light"
        data-lang=""
        crossorigin="anonymous"
        async>
</script>


                

            
        
    </div>
</article>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Yun. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a
                        class="post-action-btn btn btn--disabled"
                        aria-hidden="true"
                    >
                        
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/spring-data-mongodb-update-arrayFilters/"
                    data-tooltip="Spring Data MongoDB로 배열의 특정 요소 업데이트하기"
                    aria-label="다음: Spring Data MongoDB로 배열의 특정 요소 업데이트하기"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/coroutine-io/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/coroutine-io/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="5">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/coroutine-io/"
                        aria-label="Facebook에 공유하기"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Facebook에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/coroutine-io/"
                        aria-label="Twitter에 공유하기"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Twitter에 공유하기</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
            <h4 id="about-card-name">Yun</h4>
        
            <div id="about-card-bio"><p>기술 블로그</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
