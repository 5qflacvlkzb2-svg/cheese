
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Yun Blog">
    <title>Spring Batch 간단 정리 - Yun Blog</title>
    <meta name="author" content="Yun">
    
        <meta name="keywords" content="Node,Spring,Spring Boot,Spring Batch,Kotlin,기술 블로그,JPA,Mongo,MySQL,OOP,">
    
    
    
        
            <link rel="alternate" type="application/rss+xml" title="RSS" href="/rss2.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg"},"articleBody":"\n출저 처음으로 배우는 스프링 부트 2을 보고 정리한 포스팅입니다. 배치 관련된 국내 서적 중에서 스프링 배치를 가장 잘 정리 한 거 같습니다.\n\n스프링 배치는 벡엔드의 배치처리 기능을 구현하는 데 사용하는 프레임워크입니다. 스프링 부트 배치는 스프링 배치 설정 요소들을 간편화시켜 스프링 배치를 빠르게 설정하는 데 도움을 줍니다.\n스프링 부트 배치의 장점\n대용량 데이터 처리에 최적화되어 고성능을 발휘합니다.\n효과적인 로깅, 통계 처리, 트랜잭션 관리 등 재사용 가능한 필수 기능을 지원합니다.\n수동으로 처리하지 않도록 자동화되어 있습니다.\n예외사항과 비정상 동작에 대한 방어 기능이 있습니다.\n스프링 부트 배치는 반복적인 작업 프로세스를 이해하면 비니지스로직에 집중할 수 있습니다.\n\n스프링 부트 배치 주의사항스프링 부트 배치는 스프링 배치를 간편하게 사용 할 수 있게 래핑한 프로젝트입니다. 따라서 스프링 부트 배치와 스프링 배치에 모두에서 다음과 같은 주의사항을 염두해야 합니다.\n\n가능하면 단순화해서 복잡한 구조와 로직을 피해야합니다.\n데이터를 직접 사용하는 편이 빈번하게 일어나므로 데이터 무결성을 우지하는데 유효성 검사 등의 방어책이 있어야합니다.\n배치 처리 시스템 I&#x2F;O 사용을 최소화해야합니다. 잦은 I&#x2F;O로 데이터베이스 커넥션과 네트워크 비용이 커지면 성능에 영향을 줄 수 있기 때문입니다. 따라서 가능하면 한번에 데이터를 조회하여 메모리에 저장해두고 처리를 한 다음. 그결과를 한번에 데이터베이스에 저장하는것이 좋습니다.\n일반적으로 같은 서비스에 사용되는 웹 API, 배치, 기타 프로젝트들을 서로 영향을 줍니다. 따라서 배치 처리가 진행되는 동안 다른 프로젝트 요소에 영향을 주는 경우가 없는지 주의를 기울여야합니다.\n스프링 부트는 배치 스케쥴러를 제공하지 않습니다. 따라서 배치 처리 기능만 제공하여 스케쥴링 기능은 스프링에서 제공하는 쿼치 프레임워크 등을 이용해야합니다. 리눅스 crontab 명령은 가장 간단히 사용 할 수 있지만 이는 추천하지 않습니다. crontab의 경우 각 서버마다 따로 스케쥴러를 관리해야 하며 무엇보다 클러스터링 기능이 제공되지 않습니다. 반면에 쿼츠 같은 스케쥴링은 프레임워크를 사용한다면 클러스터링뿐만 아니라 다양한 스케쥴링 기능, 실행 이력 관리 등 여러 이점을 얻을 수 있습니다.\n\n스프링 부트 배치 이해하기배치의 일반적인 시나리오는 다음과 같은 3단계로 이루어집니다.\n\n읽기(read) : 데이터 저장소(일반적으로 데이터베이스)에서 특정 데이터 레코드를 읽습니다.\n처리(processing) : 원하는 방식으로 데이터 가공&#x2F;처리 합니다.\n쓰기(write) : 수정된 데이터를 다시 저장소(데이터베이스)에 저장합니다.\n\n배치 처리는 읽기 -&gt; 처리 -&gt; 쓰기 흐름을 갖습니다. 다음 그림은 스프링에서 이러한 배치 처리를 어떻게 구현 했는지 배치 처리와 관련된 객체의 관계를 보여줍니다.\n\n  \n\n\n\nJob과 Step은 1:M\nStep과 ItemReader, ItemProcessor, ItemWriter 1:1\nJob이라는 하나의 큰 일감(Job)에 여러 단계(Step)을 두고, 각 단계를 배치의 기본 흐름대로 구성합니다.\n\nJob\nJob은 배치 처리 과정을 하나의 단위로 만들어 포현한 객체입니다. 또한 전체 배치 처리에 있어 항상 최상단 계층에 있습니다.\n위에서 하나의 Job(일감) 안에는 여러 Step(단계)이 있다고 설명했던 바와 같이 스프링 배치에서 Job 객체는 여러 Step 인스턴스를 포함하는 컨테이너 입니다\nJob 객체를 만드는 빌더는 여러 개 있습니다. 여러 빌더를 통합하여 처리하는 공장인 JobBuilderFactory로 원하는 Job을 쉽게 만들수 있습니다.\n\n123456789101112public class JobBuilderFactory &#123;    private JobRepostiroy jobrepository;    public JobBuilderFactory(JobRepository jobRepository)&#123;        this.jobrepository = jobrepository;    &#125;    public JobBuilder get(String name)&#123;        JobBuilder builder = new JobBuilder(name).repository(jobrepository);        return builder;    &#125;&#125;\n\nJobBuilderFactory는 JobBuilder를 생성할 수 있는 get() 메서드를 포함하고 있습니다. get()메서드는 새로운 JobBuilder를 생성해서 반환하는 것을 확인할 수있습니다.\nJobBuilderFactory에서 생성되는 모든 JobBulder가 레포지토리를 사용합니다.\nJobBuilderFactory는 JobBuilder를 생성하는 역할만 수행합니다. 이렇게 생성된 JobBuilder를 이용해서 Job을 생성해야 하는데, 그렇다면 JobBuilder의 역할은 무엇인지 JobBuilder의 메서드를 통해 기능을 알아보겠습니다.\n\n1234567891011121314151617public SimpleJobBuilder start(Step step)&#123;    //(1)    // Step을 추가해서 가장 기본이되는 SimpleJobBuilder를 생성합니다.    return new SimpleJobBuilder(tihs).start(step);&#125;public JobFlowBuilder start(Flow flow)&#123;    //(2)    // Flow를 실행할 JobFlowBuilder를 생성합니다.    return new JobFlowBuilder(tihs).start(flow);&#125;public JobFlowBuilder flow(Step step)&#123;    //(3)    // Step을 실행할 FlowJobBuilder를 생성합니다.    return new JobFlowBuilder(tihs).start(step);&#125;\n\nJobBuilder는 직접적으로 Job을 생성하는 것이 아니라 별도의 구체적 빌더를 생성하여 변환하여 경우에 따라 Job 생성 방법이 모두 다를 수 있는 점을 유연하게 처리할 수 있습니다.\n\nJobInstance\nJobInstance는 배치 처리에서 Job이 실행될 때 하나의 Job 실행 단위입니다. 만약 하루에 한 번 씩 배치의 Job이 실행된다면 어제와 오늘 실행 각각 Job을 JobInstance라고 부를 수 있습니다.\n각각의 JobInstance는 하나의 JobExecution을 갖는 것은아닙니다. 오늘 Job이 실행 했는데 실패했다면 다음날 동일한 JobInstance를 가지고 또 실행합니다.\nJob 실행이 실패하면 JobInstance가 끝난것으로 간주하지 않기 때문입니다. 그렇다면 JobInstance는 어제 실패한 JobExecution과 오늘의 성공한 JobExecution 두 개를 가지게 됩니다. 즉 JobExecution 는 여러 개 가질 수 있습니다.\n\nJobExecution\nJobExecution은 JobIstance에 대한 한 번의 실행을 나타내는 객체입니다.\n만약 오늘 Job이 실패해 내일 다시 동일한 Job을 실행하면 오늘&#x2F;내일의 실행 모두 같은 JobInstance를 사용합니다.\n실제로 JobExecution 인터페이스를 보면 Job 실행에 대한 정보를 담고 있는 도메인 객체가 있습니다. JobExecution은 JobInstance, 배치 실행 상태, 시작 시간, 끝난 시간, 실패했을 때 메시지 등의 정보를 담고 있습니다. JobExecution 객체 안에 어떤 실행 정보를 포함 하고 있습니다.\n\nJobParameters\nJobParameters는 Job이 실행될 때 필요한 파라미터들은 Map 타입으로 지정하는 객체 입니다.\nJobParameters는 JobInstance를 구분하는 기준이 되기도 합니다.\nJobParameters와 JobInstance는 1:1 관계입니다.\n\nStep\nStep은 실직적인 배치 처리를 정의하고 제어 하는데 필요한 모든 정보가 있는 도메인 객체입니다. Job을 처리하는 실질적인 단위로 쓰입니다.\n모든 Job에는 1개 이상의 Step이 있어야 합니다.\n\nStepExecution\nJob에 JobExecution Job실행 정보가 있다면 Step에는 StepExecution이라는 Step 실행 정보를 담는 객체가 있습니다.\n\nJobRepository\nJobRepository는 배치 처리 정보를 담고 있는 매커니즘입니다. 어떤 Job이 실행되었으면 몇 번 실행되었고 언제 끝났는지 등 배치 처리에 대한 메타데이터를 저장합니다.\n예를들어 Job 하나가 실행되면 JobRepository에서는 배치 실행에 관련된 정보를 담고 있는 도메인 JobExecution을 생성합니다.\nJobRepository는 Step의 실행 정보를 담고 있는 StepExecution도 저장소에 저장하여 전체 메타데이터를 저장&#x2F;관리하는 역할을 수행합니다.\n\nJobLauncher\nJobLauncher는 Job. JobParamerters와 함께 배치를 실행하는 인터페이스입니다.\n\nItemReader\nItemReader는 Step의 대상이 되는 배치 데이터를 읽어오는 인터페이스입니다. File, Xml Db등 여러 타입의 데이터를 읽어올 수 있습니다.\n\nItemProcessor\nItemProcessor는 ItemReader로 읽어 온 배치 데이터를 변환하는 역할을 수행합니다. 이것을 분리하는 이유는 다음과 같습니다.\n비즈니스 로직의 분리 : ItemWriter는 저장 수행하고, ItemProcessor는 로직 처리만 수행해 역할을 명확하게 분리합니다.\n읽어온 배치 데이터와 씌여질 데이터의 타입이 다를 경우에 대응할 수 있기 때문입니다.\n\nItemWriter\nItemWriter는 배치 데이터를 저장합니다. 일반적으로 DB나 파일에 저장합니다.\nItemWriter도 ItemReader와 비슷한 방식을 구현합니다. 제네릭으로 원하는 타입을 받고 write() 메서드는 List를 사용해서 저장한 타입의 리스트를 매게변수로 받습니다.\n\n휴면회원 배치 설계\n  \n\n\n가입한 회원 중 1년이 지나도록 상태 변화가 없는 회원을 휴면회원으로 전환하는 배치 처리\n\n(1) DB에 저장된 데이터 중 1년간 업데이트되지 않은 사용자를 찾는 로직 ItemReader 구현합니다.\n(2) 대상 사용자 데이터의 상탯값을 휴면으로 전환하는 프로세스를 ItemProcessor에 구현합니다.\n(3) 상태값이 변환된 휴면회원을 실제DB에 저장하는 ItemWriter를 구현합니다.\n\n휴면회원 배치 구현배치처리 순서는 다음과 같습니다.\n\n휴면 회원 Job 설정\n휴면 회원 Step 설정\n휴면 회원 Reader, Processor, Writer 설정\n\nJob 설정12345678910@Configurationpublic class InactiveUserJobConfig &#123;    ...    @Bean    public Job inactiveUserJob(JobBuilderFactory jobBuilderFactory, Step inactiveJobStep) &#123; //(1)        return jobBuilderFactory.get(&quot;inactiveUserJob&quot;)                .preventRestart() //(2)                .start(inactiveJobStep) //(3)                .build();    &#125;\n\n\n(1) Job 생성을 직관적이고 편리하게 도와주는 빌더 JobBuilderFactory를 주입받습니다.\n(2) inactiveUserJob 이라는 JobBuilder를 생성하며 preventRestart() 설정을 통해 재실행을 막았습니다.\n(3) start(inactiveJobStep)은 파라미터에서 주입받은 휴면회원 관련 Step인 inactiveJobStep을 제일 먼저 실행하도록 설정하는 부분입니다.\n\n기본적인 Job설정은 완료 했습니다. Step 설정을 진행하겠습니다.\nStep 설정12345678910...@Beanpublic Step inactiveJobStep(StepBuilderFactory stepBuilderFactory) &#123;    return stepBuilderFactory.get(&quot;inactiveUserStep&quot;) //(1)            .&lt;User, User&gt; chunk(10) //(2)            .reader(inactiveUserReader()) //(3)            .processor(inactiveUserProcessor())            .writer(inactiveUserWriter())            .build();&#125;\n\n(1) stepBuilderFactory.get(&quot;inactiveUserStep&quot;)로 inactiveUserStep 이라는 이름의 StepBuilder를 생성합니다.\n(2) 제네릭을 사용해서 chunk() 의 입력과 추력 타입을 User로 설정 했습니다. chunk의 인자값은 10으로 설정해서 쓰기 시에 청크 단위로 writer() 메서드를 실행시킬 단위를 지정했습니다. 즉 커밋단위가 10개입니다.\n(3) step의 reader, proccsor, writer를 각각 설정했습니다.\n\nReader설정1234567891011@Bean@StepScope //(1)public QueueItemReader&lt;User&gt; inactiveUserReader() &#123;    //(2)    List&lt;User&gt; oldUsers =            userRepository.findByUpdatedDateBeforeAndStatusEquals(                    LocalDateTime.now().minusYears(1),                    UserStatus.ACTIVE);    return new QueueItemReader&lt;&gt;(oldUsers); //(3)&#125;\n\n(1) 기본 빈 생성은 싱글턴이지만 @StepScope를 사용하면 해당 메서드는 Step의 주기에 따라 새로운 빈을 생성합니다. 즉, 각 Step의 실행마다 새로운 빈을 만들기 때문에 지연 생성이 가능합니다. 주의할 사항은 @StepScode는 기본 프록시 모드가 반환되는 클래스 타임을 참조하기 때문에 @StepScode를 사용하면 반드시 구현된 반환 타입을 명시해 변환해야합니다. 해당 예제는 QueueItemReader라고 명시했습니다.\n(2) findByUpdatedDateBeforeAndStatusEquals() 메서드를 통해서 휴면 회원 리스트를 가져옵니다.\n(3) QueueItemReader 객체를 생성하고 불러온 휴면회원 타깃 대상을 데이터 객체에 넣어 반환합니다.\n\n123456789101112public class QueueItemReader&lt;T&gt; implements ItemReader&lt;T&gt; &#123;    private Queue&lt;T&gt; queue;    public QueueItemReader(List&lt;T&gt; data) &#123;        this.queue = new LinkedList&lt;&gt;(data); //(1)    &#125;    @Override    public T read() throws Exception, UnexpectedInputException, ParseException, NonTransientResourceException &#123;        return queue.poll(); //(2)    &#125;&#125;\nQueueItemReader는 큐를 사용해서 자장하는 ItemReader 구현체입니다. ItemReader의 기본 반환 타입은 단수형인데 그 에 따라 구현하면 User 객체 1개씩 DB에 select 요청 하므로 매우 비효율적인 방식이 될 수 있습니다.\n\n(1) QueueItemReader를 사용해서 휴면회원으로 지정될 타깃 데이터를 한번에 불러와 큐에 담아 놓습니다.\n(2) reade() 메서드를 사용할 때 큐의 poll()메서드를 통해서 큐에서 데이터를 하나씩 반환합니다.\n\nProcessor 설정123public ItemProcessor&lt;User, User&gt; inactiveUserProcessor() &#123;    return user -&gt; user.setInactive();&#125;\n읽어온 타깃 데이터를 휴면 회원으로 전환시키는 Processor입니다. reader에서 읽은 User를 휴면 상태로 전환화는 Processor 메서드를 추가하는 예입니다.\nWriter 설정123public ItemWriter&lt;User&gt; inactiveUserWriter() &#123;    return ((List&lt;? extends User&gt; users) -&gt; userRepository.saveAll(users));&#125;\nItemWriter는 리스트 타입을 앞서 설정한 청크 단위로 받습니다. 청크 단위를 10으로 설정했기 때문에 users에게 휴면회원 10개가 주어지며 saveAll()메서드를 통해서 한번에 DB에 저장합니다.\n배치 심화\n다양한 ItemReader 구현 클래스\n다양한 ItemWriter 구현 클래스\nJobParameter 사용하기\n테스트 시에만 H2 DB를 사용 하도록 설정하기\n청크 지향 프로세싱\n배치 인터셉터 Listener 설정하기\n어노테이션 기반 Listener 설정하기\n\n다양한 ItemReader 구현 클래스기존에는 QueueItemReader 객체를 사용 해서 모든 데이터를 한번에 와서 배치처치를 진행했습니다. 하지만 수백, 수천 개 이상의 데이터를 한번에 가져와서 메모리에 올려놓게되면 좋지 않습니다. 이때 배치 프로젝트에서 제공하는 PagingItemRedaer 구현체를 사용 사용할 수있습니다. 구현체는 크게 JdbcPagingItemReader, JpaPagingItemRedaer, HibernatePagingItemRdaer가 있습니다. 해당 예쩨에서는 JpaPagingItemRedaer를 사용하겠습니다.\n12345678910111213141516@Bean(destroyMethod=&quot;&quot;) //(1)@StepScopepublic JpaPagingItemReader&lt;User&gt; inactiveUserJpaReader(@Value(&quot;#&#123;jobParameters[nowDate]&#125;&quot;) Date nowDate) &#123;    JpaPagingItemReader&lt;User&gt; jpaPagingItemReader = new JpaPagingItemReader&lt;&gt;();    jpaPagingItemReader.setQueryString(&quot;select u from User as u where u.createdDate &lt; :createdDate and u.status = :status&quot;); //(2)    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    LocalDateTime now = LocalDateTime.ofInstant(nowDate.toInstant(), ZoneId.systemDefault());    map.put(&quot;createdDate&quot;, now.minusYears(1));    map.put(&quot;status&quot;, UserStatus.ACTIVE);    jpaPagingItemReader.setParameterValues(map); //(3)    jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory); //(4)    jpaPagingItemReader.setPageSize(CHUNK_SIZE); //(5)    return jpaPagingItemReader;&#125;\n\n\n(1) 스프링에서 destroyMethod를 사용해서 삭제할 빈을 자동으로 추적합니다. destroyMethod&#x3D;””를 설정하면 warring 메세지를 제거할 수 있습니다.\n(2) JpaPagingItemReader를 사용하면 쿼리를 직접 짜거 실행 하는 방법밖에는 없습니다.\n(3) 쿼리리에서 사용된 updateDate, status 파라미터를 Mpa에 추가해서 사용할 파라미터를 설정합니다\n(4 )트랜잭션을 관리해줄 entityManagerFactory를 설정합니다.\n(5) 한번에 읽어올 크기를 CHUNK_SIZE 만큼 할당합니다.\n\n다양한 ItemWriter 구현 클래스ItemReader와 마찬가지로 상황에맞는 여러 구현 클래스를 제공합니다. JPA를 사용하고 있음으로 JpaItemWriter를 적용합니다.\n12345private JpaItemWriter&lt;User&gt; inactiveUserWriter() &#123;    JpaItemWriter&lt;User&gt; jpaItemWriter = new JpaItemWriter&lt;&gt;();    jpaItemWriter.setEntityManagerFactory(entityManagerFactory);    return jpaItemWriter;&#125;\nJobParameter 사용하기JobParameter를 사용해서 Step을 실행시킬 때 동적으로 파라미터를 주입시킬 수 있습니다.\n테스트 시에만 H2 데이터베이스를 사용하도록 설정123456@RunWith(SpringRunner.class)@SpringBootTest@AutoConfigureTestDatabase(connection = EmbeddedDatabaseConnection.H2)public class DemoApplication &#123;    ....&#125;\n@AutoConfigureTestDatabase(connection = EmbeddedDatabaseConnection.H2) 어노테이션으로 간단하세 설정 가능합니다\n청크 지향 프로세싱\n  \n\n청크 지향 프로세싱은 트랜잭션 경계 내에서 청크 단위로 데이터를 읽고 생성하는 프로그래밍 기법입니다. 청크란 아이템이 트랜잭션에 커밋되는 수를 말합니다. read한 데이터 수가 지정한 청크 단위와 칠치하면 write를 수행하고 트랜잭션을 커밋합니다. Step 설정에서 chunk()로 커밋 단위를 지정했던 부분입니다. 즉 기존에도 계속 사용해온 방법이 청크 지향 프로세싱입니다.\n\n청크 지향프러그래밍의 이점은 1000개 개의 데이터에 대해 배치 로직을 실행한다고 가정했을 때 청크로 나누지 않았을 때는 하나만 실패해도 다른 성공한 999개의 데이터가 롤백됩니다. 그런데 청크 단위를 10으로 해서 배치처리를 하면 도중에 배치 처리에 실패하더라도 다른 청크는 영향을 받지 않습니다. 이러한 이유로 스프링 배치에 청크 단위로 프로그래밍을 지향합니다.\n배치 인터셉터 Listener 설정하기배치 흐름에서 전후 처리를 하는 Listener를 설정할 수 있습니다. 구체적으로 Job의 전후 처리 Step의 전후 처리 각 청크 단위의 전후 처리 등 세세한 과정 실행시 특정 로직을 할당해 제어할 수있습니다. 가장 대표적인 예로는 로깅 작업이 있습니다.\n어노테이션 기반 Listener 설정하기배치 인터셉터 인터페이스를 활용해서 사용하는 방법도 있고 애노테이션을 사용해서 활용하는 방법도 있습니다. 대표적으로 @BeforeStep, @AsfterStep 등이 있습니다. 해당 어노테이션으로 시작 전후에 로그를 남기는 설정도 가능합니다.\nJobParameter 사용하기JapParameter를 사용해 Step을 실행시킬 때 동적으로 파라미터를 주입시클 수 있습니다.\nStep의 흐름을 제어하는 FlowStep의 가장 기본적은 흐름은 읽기-처리-쓰기 입니다. 여기서 세부적인 조건에 따라서 Step의 실행 여부를 정할 수 있습니다. 이런 흐름을 제어하는 Flow 제공 합니다.\n\n  \n\n\n흐름에 조건에 해당하는 부분을 JobExecutionDecider 인터페이스를 사용해 구현 할 수 있습니다. JobExecutionDecider 인터페이스는 decide() 메서드 하나만 제공합니다.\n123456789101112131415public interface JobExecutionDecider &#123;    FlowExecutionStatus decide(JobExecution jobExecution, @Nullable StepExecution stepExecution);&#125;public Class xxxJobExecutionDecider implements  JobExecutionDecider &#123;    @Override    public FlowExecutionStatus decide(JobExecution jobExecution, @Nullable StepExecution stepExecution)&#123;        if(특정 조건...)&#123; // (1)            return FlowExecutionsStatus.COMPLETED; // (2)        &#125;        return FlowExecutionsStatus.FAILED; // (3)    &#125;&#125;\n\n(1) 특정 조건에 대한 로직\n(2) 조건에 만족하고 JobStep을 실행 시킬 경우 COMPLETED 리턴\n(3) 조건에 만족하지 않고 JobStep을 실행 하지않을 경우  FAILED 리턴\n\nFlow 조건으로 사용될 경우 InactiveJobExceutionDecider 클래스를 구현 했습니다. 이를 사용할 Flow를 구현 해야합니다. Step 메서드가아닌 Flow를 주압 받고 주입받은 Flow를 빈으로 등록해야합니다.\n123456789@Beanpublic Flow xxxJobFlow(Step xxxJobStep)&#123;    FlowBuilder&lt;Flow&gt; flowBuilder = new FlowBuilder&lt;&gt;(&quot;xxxJobFlow&quot;); // (1)    return flowBuilder        .start(new xxxJobExcetuinDeicder()) // (2)        .on(FlowExecutionStatus.FAILED.getName()).end() // (3)        .on(FlowExecutionStatus.COMPLETED.getName()).to(xxxJobStep).end(); // (4)&#125;\n\n(1) FlowBuilder를 시용해서 Flow 객체를 생성합니다.\n(2) 위에서 작성한 xxxJobExecutionDecider 클래스를 start() 으로 설정해 맨 처음 시작하도록 합니다.\n(3) xxxJobExecutionDecider 클래스의 decide() 메서드를 통해 리턴 값이 FAILED 일 경우 end() 메서드를 사용해서 끝나도록 설정합니다.\n(4) xxxJobExecutionDecider 클래스의 decide() 메서드를 통해 리턴 값이 COMPLETED 일 경우 기존에 설정한 xxxJobStep을 실행하도록 설정합니다.\n\n재시도네트워크 접속이 끊어지거나 장비가 다운되는 등 실패 시나리오는 다양합니다. 시스템은 언젠가 복구 될테니 다시 한번 시도는 해볼 가치는 있습니다.\n스템 구성하기12345678910@Beanpublic Step step1() &#123;    return steps.get(&quot;user xxxxx&quot;)    .&lt;User, User&gt;chunk(10)        .faulTolerant()            .retryLimit(3).retry(XXXXXException.class)    .render(something())    .writer(something())    .build();&#125;\n자바 구성으로 재시도를 활성화 할 경우, 첫 번째 스텝은 오류를 허용하도록 만들어야 재시도 제한 횟수 및 재시도 대상 예외를 지정할 수 있습니다. 먼저 faulTolerant()로 오류 허용 스탭을 얻은후, retryLimit() 메서드로 재시도 제한 횟수를, retry() 메서드로 재시도 대상 예외를 발생합니다.\n재시도 템플릿\n스프링 배치가 제공하는 재시도 및 복구 서비스를 코드에 활용하는 다른 방법도 있습니다. 재시도 로직을 구현된 커스텀 ItemWriter를 작성하거나 아예 전체 서비스 인터페이스에 재시도 기능을 입힐 수 있습니다.\n스프링 배치 RetryTemplate은 바로 이런 용도로 만들어진 클래스입니다. 비니지스 로직과 재시도 로직을 분리해서 마치 재시도 없이 한 번만 시도하는 것처럼 코드를 작성할 수 있개 해줍니다.\n재시도 -&gt; 실패 -&gt; 복구 반복적인 과정을 간명한 하나의 API 메서드로 호출로 감싼 RetryTemplate는 여러 가지 유스 케이스를 지원합니다.\n\n12345678910111213141516171819202122232425262728293031323334353637383940public class RetryableUserRegistrationServiceItemWriter implements ItemWriter&lt;UserRegistration&gt; &#123;    private static final Logger logger = LoggerFactory.getLogger(RetryableUserRegistrationServiceItemWriter.class);    private final UserRegistrationService userRegistrationService;    private final RetryTemplate retryTemplate;    public RetryableUserRegistrationServiceItemWriter(UserRegistrationService userRegistrationService, RetryTemplate retryTemplate) &#123;        this.userRegistrationService = userRegistrationService;        this.retryTemplate = retryTemplate;    &#125;    /**     * takes aggregated input from the reader and &#x27;writes&#x27; them using a custom implementation.     */    public void write(List&lt;?extends UserRegistration&gt; items)        throws Exception &#123;        for (final UserRegistration userRegistration : items) &#123;            UserRegistration registeredUserRegistration = retryTemplate.execute(                    (RetryCallback&lt;UserRegistration, Exception&gt;) context -&gt; userRegistrationService.registerUser(userRegistration));            logger.debug(&quot;Registered: &#123;&#125;&quot;, registeredUserRegistration);        &#125;    &#125;&#125;  ....  @Bean    public RetryTemplate retryTemplate() &#123;        RetryTemplate retryTemplate = new RetryTemplate();        retryTemplate.setBackOffPolicy(backOffPolicy());        return retryTemplate;    &#125;    @Bean    public ExponentialBackOffPolicy backOffPolicy() &#123;        ExponentialBackOffPolicy backOffPolicy = new ExponentialBackOffPolicy();        backOffPolicy.setInitialInterval(1000);        backOffPolicy.setMaxInterval(10000);        backOffPolicy.setMultiplier(2);        return backOffPolicy;    &#125;\n\n재시도 시간 간격을 정하는 BackOffplicy는 RetryTemplate의 유용한 기능입니다. 실제로 실패 직후 재시도하는 시간 간격을 점점 늘려 여러 클라이언트가 같은 호출 할때 스텝이 잠기지 않도록 예방하는 수단으로 활용할 수있습니다.\n\nAOP 기반 재시도스프링 배치가 제공하는 AOP 어드바이저를 이용해서 RetryTempate 처럼 사용할 수 있습니다. 프록시 전체에 재시 로직 어드바이스를 추가하면 RetryTempate이 빠진 본래 코드로 그대로 사용가능합니다.\n12@Retryable(backoff = @Backoff(delay = 1000, maxDely = 10000, multiplier = 2))public User batchSomething()&#123;....&#125;\n구성 클래스에 반드시 @EnableRety 를추가 해야합니다.\nSpring Batch Table\n  \n\n\nBATCH_JOB_INSTANCE12345678CREATE TABLE `BATCH_JOB_INSTANCE` (  `JOB_INSTANCE_ID` bigint(20) NOT NULL,  `VERSION` bigint(20) DEFAULT NULL,  `JOB_NAME` varchar(100) NOT NULL,  `JOB_KEY` varchar(32) NOT NULL,  PRIMARY KEY (`JOB_INSTANCE_ID`),  UNIQUE KEY `JOB_INST_UN` (`JOB_NAME`,`JOB_KEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\n\n\nJOB_INSTANCE_ID\nVERSION\nJOB_NAME\nJOB_KEY\n\n\n\n1\n0\ninactiveUserJob\ndf9e59b818ab301226e71dcf67795b07\n\n\n2\n0\ninactiveUserJob\n34c2f2838f31f237450a6c7659e36995\n\n\n3\n0\norderDailySumJob\nd41d8cd98f00b204e9800998ecf8427e\n\n\n4\n0\norderDailySumJob\nd6832decf796311c39d3d934a9d7cfd5\n\n\n5\n0\norderDailySumJob\n212470e06656926b4b339a42dc5d64c3\n\n\nJOB_INSTANCE_ID는 BATCH_JOB_INSTANCE 테이블의 PK, JOB_NAME 수행한 Batch Job Name\nBATCH_JOB_INSTANCE 테이블은 Job Parameter에 따라 생성됩니다. Job Parameter는 Spring Batch가 실행될때 외부에서 받을 수 있는 파라미터 입니다. 같은 Batch Job 이라도 Job Parameter가 다르면 다른 BATCH_JOB_INSTANCE 에 기록됩니다. BATCH_JOB_EXECUTION_PARAMS 기반으로 JOB_KEY를 만들며 해당 값은 유니크 제약조건이 있기 때문에 같은 BATCH_JOB_EXECUTION_PARAMS을 넘기는 경우 생성되지 않습니다.\nBATCH_JOB_EXECUTION1234567891011121314151617181920212223CREATE TABLE `BATCH_STEP_EXECUTION` (  `STEP_EXECUTION_ID` bigint(20) NOT NULL,  `VERSION` bigint(20) NOT NULL,  `STEP_NAME` varchar(100) NOT NULL,  `JOB_EXECUTION_ID` bigint(20) NOT NULL,  `START_TIME` datetime NOT NULL,  `END_TIME` datetime DEFAULT NULL,  `STATUS` varchar(10) DEFAULT NULL,  `COMMIT_COUNT` bigint(20) DEFAULT NULL,  `READ_COUNT` bigint(20) DEFAULT NULL,  `FILTER_COUNT` bigint(20) DEFAULT NULL,  `WRITE_COUNT` bigint(20) DEFAULT NULL,  `READ_SKIP_COUNT` bigint(20) DEFAULT NULL,  `WRITE_SKIP_COUNT` bigint(20) DEFAULT NULL,  `PROCESS_SKIP_COUNT` bigint(20) DEFAULT NULL,  `ROLLBACK_COUNT` bigint(20) DEFAULT NULL,  `EXIT_CODE` varchar(2500) DEFAULT NULL,  `EXIT_MESSAGE` varchar(2500) DEFAULT NULL,  `LAST_UPDATED` datetime DEFAULT NULL,  PRIMARY KEY (`STEP_EXECUTION_ID`),  KEY `JOB_EXEC_STEP_FK` (`JOB_EXECUTION_ID`),  CONSTRAINT `JOB_EXEC_STEP_FK` FOREIGN KEY (`JOB_EXECUTION_ID`) REFERENCES `BATCH_JOB_EXECUTION` (`JOB_EXECUTION_ID`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\n\n\nJOB_EXECUTION_ID\nVERSION\nJOB_INSTANCE_ID\nCREATE_TIME\nSTART_TIME\nEND_TIME\nSTATUS\nEXIT_CODE\nEXIT_MESSAGE\nLAST_UPDATED\nJOB_CONFIGURATION_LOCATION\n\n\n\n1\n2\n1\n2019-07-02 06:51:22\n2019-07-02 06:51:22\n2019-07-02 06:51:23\nCOMPLETED\nCOMPLETED\n\n2019-07-02 06:51:23\nNULL\n\n\n2\n2\n2\n2019-07-02 07:14:00\n2019-07-02 07:14:00\n2019-07-02 07:14:01\nCOMPLETED\nCOMPLETED\n\n2019-07-02 07:14:01\nNULL\n\n\n3\n2\n3\n2020-01-13 11:00:50\n2020-01-13 11:00:50\n2020-01-13 11:00:50\nCOMPLETED\nCOMPLETED\n\n2020-01-13 11:00:50\nNULL\n\n\n4\n2\n4\n2020-01-13 11:59:15\n2020-01-13 11:59:15\n2020-01-13 11:59:15\nCOMPLETED\nCOMPLETED\n\n2020-01-13 11:59:15\nNULL\n\n\n5\n2\n5\n2020-01-13 12:48:53\n2020-01-13 12:48:53\n2020-01-13 12:48:54\nCOMPLETED\nCOMPLETED\n\n2020-01-13 12:48:54\nNULL\n\n\n\nJOB_EXECUTION_ID 칼럼은 BATCH_JOB_INSTANCE 테이블의 PK를 참조 하고 있습니다.\nBATCH_STEP_EXECUTION 와 BATCH_JOB_INSTANCE는 부모 자식관계입니다.\nBATCH_STEP_EXECUTION는 자신의 부모 BATCH_JOB_INSTANCE 성공&#x2F;실패 내역을 모두 갖고 있습니다.\njobParameters : Job 실행에 필요한 매개변수 데이터입니다.\njobInstance : Job 실행 단위가 되는 객체입니다.\nstepExecutuons : StepExecutuon을 여러개 가질 수 있는 Collection 타입입니다.\nstatus : Job 실행 상태를 나타내는 필드(Enum)입니다. 상태값으로는 COMPLETED, STARTING, STARTED, STOPPING, STOPPED, FAILED, ABANDONED, UNKNOWN 이 있습니다.\nstartTime : Job이 실행된 시간입니다. null이면 시작되지 않았다는 의미 입니다.\ncreateTime : JobExecution이 생성된 시간입니다.\nendTime: JobExecution이 끝난 시간입니다.\n\n\n  \n\n\n\nJob: 특정 잡, 2달이상 로그인안한 유저 휴면 회원 처리 등\nJob Instance: Job Parameter를 실행한 Job(Job Parameter 단위로 생성)\nJob Execution: Job Parameter로 실행한 Job의 실행, 1번 째 시도 혹은 그 다음 등\n\nBATCH_JOB_EXECUTION_PARAMS\n\n\nJOB_EXECUTION_ID\nTYPE_CD\nKEY_NAME\nSTRING_VAL\nDATE_VAL\nLONG_VAL\nDOUBLE_VAL\nIDENTIFYING\n\n\n\n5\nSTRING\nrequestDate\n2019-10-13\n1970-01-01 00:00:00\n0\n0\nN\n\n\n5\nLONG\nrun.id\n\n1970-01-01 00:00:00\n2\n0\nY\n\n\n5\nSTRING\nversion\n12\n1970-01-01 00:00:00\n0\n0\nY\n\n\n5\nSTRING\n-job.name\norderDailySumJob\n1970-01-01 00:00:00\n0\n0\nN\n\n\nBATCH_JOB_EXECUTION에 대한 Parameter정보들이 저장되는 곳이다 BATCH_JOB_EXECUTION, BATCH_JOB_EXECUTION_PARAMS 1:N 관계이며 위 테이블은 ID 5번에 들어가는 parameter 정보들이 저장된다\n참고\n처음으로 배우는 스프링 부트 2를 정리한 글입니다.\n기억보단 기록을 - spring-batch-in-action\n\n","dateCreated":"2018-11-20T01:12:00+09:00","dateModified":"2025-01-31T04:41:33+09:00","datePublished":"2018-11-20T01:12:00+09:00","description":"스프링 배치는 벡엔드의 배치처리 기능을 구현하는 데 사용하는 프레임워크입니다. 스프링 부트 배치는 스프링 배치 설정 요소들을 간편화시켜 스프링 배치를 빠르게 설정하는 데 도움을 줍니다.","headline":"Spring Batch 간단 정리","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://cheese10yun.github.io/spring-batch-basic/"},"publisher":{"@type":"Organization","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg","logo":{"@type":"ImageObject","url":"yun-icon.jpg"}},"url":"https://cheese10yun.github.io/spring-batch-basic/","keywords":"Spring Batch"}</script>
    <meta name="description" content="스프링 배치는 벡엔드의 배치처리 기능을 구현하는 데 사용하는 프레임워크입니다. 스프링 부트 배치는 스프링 배치 설정 요소들을 간편화시켜 스프링 배치를 빠르게 설정하는 데 도움을 줍니다.">
<meta property="og:type" content="blog">
<meta property="og:title" content="Spring Batch 간단 정리">
<meta property="og:url" content="https://cheese10yun.github.io/spring-batch-basic/index.html">
<meta property="og:site_name" content="Yun Blog">
<meta property="og:description" content="스프링 배치는 벡엔드의 배치처리 기능을 구현하는 데 사용하는 프레임워크입니다. 스프링 부트 배치는 스프링 배치 설정 요소들을 간편화시켜 스프링 배치를 빠르게 설정하는 데 도움을 줍니다.">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="https://github.com/cheese10yun/TIL/raw/master/assets/batch-obejct-relrationship.png">
<meta property="og:image" content="https://github.com/cheese10yun/TIL/raw/master/assets/bach-process.png">
<meta property="og:image" content="https://github.com/cheese10yun/TIL/raw/master/assets/chun-process.png">
<meta property="og:image" content="https://github.com/cheese10yun/TIL/raw/master/assets/batch-flow.png">
<meta property="og:image" content="https://github.com/cheese10yun/TIL/raw/master/assets/meta-data-erd.png">
<meta property="og:image" content="https://github.com/cheese10yun/TIL/raw/master/assets/job-job-instance-job-execution.png">
<meta property="article:published_time" content="2018-11-19T16:12:00.000Z">
<meta property="article:modified_time" content="2025-01-30T19:41:33.756Z">
<meta property="article:author" content="Yun">
<meta property="article:tag" content="Spring Batch">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/cheese10yun/TIL/raw/master/assets/batch-obejct-relrationship.png">
    
    
        
    
    
        <meta property="og:image" content="https://cheese10yun.github.io/assets/images/yun-icon.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90907312-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-90907312-1');
    </script>


    

    
        
    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5813739623204880" crossorigin="anonymous"></script>
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="5">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Yun Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="링크 열기: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="5">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="저자에 대해 더 알아보기"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
                </a>
                <h4 class="sidebar-profile-name">Yun</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기술 블로그</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="카테고리"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">카테고리</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="태그"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="아카이브"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">아카이브</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="검색"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">검색</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/cheese10yun"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/rss2.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="5"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Spring Batch 간단 정리
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-11-20T01:12:00+09:00">
	
		    2018/11/20
    	
    </time>
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <blockquote>
<p>출저 <a target="_blank" rel="noopener" href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791162241264&orderClick=LAA&Kc=">처음으로 배우는 스프링 부트 2</a>을 보고 정리한 포스팅입니다. 배치 관련된 국내 서적 중에서 스프링 배치를 가장 잘 정리 한 거 같습니다.</p>
</blockquote>
<p>스프링 배치는 벡엔드의 배치처리 기능을 구현하는 데 사용하는 프레임워크입니다. 스프링 부트 배치는 스프링 배치 설정 요소들을 간편화시켜 스프링 배치를 빠르게 설정하는 데 도움을 줍니다.</p>
<h2 id="스프링-부트-배치의-장점"><a href="#스프링-부트-배치의-장점" class="headerlink" title="스프링 부트 배치의 장점"></a>스프링 부트 배치의 장점</h2><ul>
<li>대용량 데이터 처리에 최적화되어 고성능을 발휘합니다.</li>
<li>효과적인 로깅, 통계 처리, 트랜잭션 관리 등 재사용 가능한 필수 기능을 지원합니다.</li>
<li>수동으로 처리하지 않도록 자동화되어 있습니다.</li>
<li>예외사항과 비정상 동작에 대한 방어 기능이 있습니다.</li>
<li>스프링 부트 배치는 반복적인 작업 프로세스를 이해하면 비니지스로직에 집중할 수 있습니다.</li>
</ul>
<h2 id="스프링-부트-배치-주의사항"><a href="#스프링-부트-배치-주의사항" class="headerlink" title="스프링 부트 배치 주의사항"></a>스프링 부트 배치 주의사항</h2><p>스프링 부트 배치는 스프링 배치를 간편하게 사용 할 수 있게 래핑한 프로젝트입니다. 따라서 스프링 부트 배치와 스프링 배치에 모두에서 다음과 같은 주의사항을 염두해야 합니다.</p>
<ul>
<li>가능하면 단순화해서 복잡한 구조와 로직을 피해야합니다.</li>
<li>데이터를 직접 사용하는 편이 빈번하게 일어나므로 데이터 무결성을 우지하는데 유효성 검사 등의 방어책이 있어야합니다.</li>
<li>배치 처리 시스템 I&#x2F;O 사용을 최소화해야합니다. 잦은 I&#x2F;O로 데이터베이스 커넥션과 네트워크 비용이 커지면 성능에 영향을 줄 수 있기 때문입니다. 따라서 가능하면 한번에 데이터를 조회하여 메모리에 저장해두고 처리를 한 다음. 그결과를 한번에 데이터베이스에 저장하는것이 좋습니다.</li>
<li>일반적으로 같은 서비스에 사용되는 웹 API, 배치, 기타 프로젝트들을 서로 영향을 줍니다. 따라서 배치 처리가 진행되는 동안 다른 프로젝트 요소에 영향을 주는 경우가 없는지 주의를 기울여야합니다.</li>
<li>스프링 부트는 배치 스케쥴러를 제공하지 않습니다. 따라서 배치 처리 기능만 제공하여 스케쥴링 기능은 스프링에서 제공하는 쿼치 프레임워크 등을 이용해야합니다. <strong>리눅스 crontab 명령은 가장 간단히 사용 할 수 있지만 이는 추천하지 않습니다.</strong> crontab의 경우 각 서버마다 따로 스케쥴러를 관리해야 하며 무엇보다 클러스터링 기능이 제공되지 않습니다. 반면에 쿼츠 같은 스케쥴링은 프레임워크를 사용한다면 클러스터링뿐만 아니라 다양한 스케쥴링 기능, 실행 이력 관리 등 여러 이점을 얻을 수 있습니다.</li>
</ul>
<h2 id="스프링-부트-배치-이해하기"><a href="#스프링-부트-배치-이해하기" class="headerlink" title="스프링 부트 배치 이해하기"></a>스프링 부트 배치 이해하기</h2><p>배치의 일반적인 시나리오는 다음과 같은 3단계로 이루어집니다.</p>
<ol>
<li>읽기(read) : 데이터 저장소(일반적으로 데이터베이스)에서 특정 데이터 레코드를 읽습니다.</li>
<li>처리(processing) : 원하는 방식으로 데이터 가공&#x2F;처리 합니다.</li>
<li>쓰기(write) : 수정된 데이터를 다시 저장소(데이터베이스)에 저장합니다.</li>
</ol>
<p>배치 처리는 읽기 -&gt; 처리 -&gt; 쓰기 흐름을 갖습니다. 다음 그림은 스프링에서 이러한 배치 처리를 어떻게 구현 했는지 배치 처리와 관련된 객체의 관계를 보여줍니다.</p>
<p align="center">
  <img src="https://github.com/cheese10yun/TIL/raw/master/assets/batch-obejct-relrationship.png">
</p>

<ul>
<li>Job과 Step은 1:M</li>
<li>Step과 ItemReader, ItemProcessor, ItemWriter 1:1</li>
<li>Job이라는 하나의 큰 일감(Job)에 여러 단계(Step)을 두고, 각 단계를 배치의 기본 흐름대로 구성합니다.</li>
</ul>
<h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><ul>
<li>Job은 배치 처리 과정을 하나의 단위로 만들어 포현한 객체입니다. 또한 전체 배치 처리에 있어 항상 최상단 계층에 있습니다.</li>
<li>위에서 하나의 Job(일감) 안에는 여러 Step(단계)이 있다고 설명했던 바와 같이 <strong>스프링 배치에서 Job 객체는 여러 Step 인스턴스를 포함하는 컨테이너 입니다</strong></li>
<li>Job 객체를 만드는 빌더는 여러 개 있습니다. 여러 빌더를 통합하여 처리하는 공장인 JobBuilderFactory로 원하는 Job을 쉽게 만들수 있습니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JobBuilderFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> JobRepostiroy jobrepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JobBuilderFactory</span><span class="params">(JobRepository jobRepository)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.jobrepository = jobrepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> JobBuilder <span class="title function_">get</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="type">JobBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JobBuilder</span>(name).repository(jobrepository);</span><br><span class="line">        <span class="keyword">return</span> builder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JobBuilderFactory는 JobBuilder를 생성할 수 있는 get() 메서드를 포함하고 있습니다. get()메서드는 새로운 JobBuilder를 생성해서 반환하는 것을 확인할 수있습니다.</li>
<li>JobBuilderFactory에서 생성되는 모든 JobBulder가 레포지토리를 사용합니다.</li>
<li>JobBuilderFactory는 JobBuilder를 생성하는 역할만 수행합니다. 이렇게 생성된 JobBuilder를 이용해서 Job을 생성해야 하는데, 그렇다면 JobBuilder의 역할은 무엇인지 JobBuilder의 메서드를 통해 기능을 알아보겠습니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SimpleJobBuilder <span class="title function_">start</span><span class="params">(Step step)</span>&#123;</span><br><span class="line">    <span class="comment">//(1)</span></span><br><span class="line">    <span class="comment">// Step을 추가해서 가장 기본이되는 SimpleJobBuilder를 생성합니다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleJobBuilder</span>(tihs).start(step);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> JobFlowBuilder <span class="title function_">start</span><span class="params">(Flow flow)</span>&#123;</span><br><span class="line">    <span class="comment">//(2)</span></span><br><span class="line">    <span class="comment">// Flow를 실행할 JobFlowBuilder를 생성합니다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JobFlowBuilder</span>(tihs).start(flow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> JobFlowBuilder <span class="title function_">flow</span><span class="params">(Step step)</span>&#123;</span><br><span class="line">    <span class="comment">//(3)</span></span><br><span class="line">    <span class="comment">// Step을 실행할 FlowJobBuilder를 생성합니다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JobFlowBuilder</span>(tihs).start(step);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JobBuilder는 직접적으로 Job을 생성하는 것이 아니라 별도의 구체적 빌더를 생성하여 변환하여 경우에 따라 Job 생성 방법이 모두 다를 수 있는 점을 유연하게 처리할 수 있습니다.</li>
</ul>
<h3 id="JobInstance"><a href="#JobInstance" class="headerlink" title="JobInstance"></a>JobInstance</h3><ul>
<li><strong>JobInstance는 배치 처리에서 Job이 실행될 때 하나의 Job 실행 단위입니다.</strong> 만약 하루에 한 번 씩 배치의 Job이 실행된다면 어제와 오늘 실행 각각 Job을 JobInstance라고 부를 수 있습니다.</li>
<li>각각의 JobInstance는 하나의 JobExecution을 갖는 것은아닙니다. 오늘 Job이 실행 했는데 실패했다면 다음날 동일한 JobInstance를 가지고 또 실행합니다.</li>
<li>Job 실행이 실패하면 JobInstance가 끝난것으로 간주하지 않기 때문입니다. 그렇다면 JobInstance는 어제 실패한 JobExecution과 오늘의 성공한 JobExecution 두 개를 가지게 됩니다. <strong>즉 JobExecution 는 여러 개 가질 수 있습니다.</strong></li>
</ul>
<h3 id="JobExecution"><a href="#JobExecution" class="headerlink" title="JobExecution"></a>JobExecution</h3><ul>
<li>JobExecution은 JobIstance에 대한 한 번의 실행을 나타내는 객체입니다.</li>
<li>만약 오늘 Job이 실패해 내일 다시 동일한 Job을 실행하면 오늘&#x2F;내일의 실행 모두 같은 JobInstance를 사용합니다.</li>
<li>실제로 JobExecution 인터페이스를 보면 Job 실행에 대한 정보를 담고 있는 도메인 객체가 있습니다. <em>JobExecution은 JobInstance, 배치 실행 상태, 시작 시간, 끝난 시간, 실패했을 때 메시지 등의 정보를 담고 있습니다. JobExecution 객체 안에 어떤 실행 정보를 포함 하고 있습니다.</em></li>
</ul>
<h3 id="JobParameters"><a href="#JobParameters" class="headerlink" title="JobParameters"></a>JobParameters</h3><ul>
<li>JobParameters는 Job이 실행될 때 필요한 파라미터들은 Map 타입으로 지정하는 객체 입니다.</li>
<li>JobParameters는 JobInstance를 구분하는 기준이 되기도 합니다.</li>
<li>JobParameters와 JobInstance는 1:1 관계입니다.</li>
</ul>
<h3 id="Step"><a href="#Step" class="headerlink" title="Step"></a>Step</h3><ul>
<li>Step은 실직적인 배치 처리를 정의하고 제어 하는데 필요한 모든 정보가 있는 도메인 객체입니다. Job을 처리하는 실질적인 단위로 쓰입니다.</li>
<li>모든 Job에는 1개 이상의 Step이 있어야 합니다.</li>
</ul>
<h4 id="StepExecution"><a href="#StepExecution" class="headerlink" title="StepExecution"></a>StepExecution</h4><ul>
<li>Job에 JobExecution Job실행 정보가 있다면 Step에는 StepExecution이라는 Step 실행 정보를 담는 객체가 있습니다.</li>
</ul>
<h3 id="JobRepository"><a href="#JobRepository" class="headerlink" title="JobRepository"></a>JobRepository</h3><ul>
<li>JobRepository는 배치 처리 정보를 담고 있는 매커니즘입니다. 어떤 Job이 실행되었으면 몇 번 실행되었고 언제 끝났는지 등 배치 처리에 대한 메타데이터를 저장합니다.</li>
<li>예를들어 Job 하나가 실행되면 JobRepository에서는 배치 실행에 관련된 정보를 담고 있는 도메인 JobExecution을 생성합니다.</li>
<li>JobRepository는 Step의 실행 정보를 담고 있는 StepExecution도 저장소에 저장하여 전체 메타데이터를 저장&#x2F;관리하는 역할을 수행합니다.</li>
</ul>
<h3 id="JobLauncher"><a href="#JobLauncher" class="headerlink" title="JobLauncher"></a>JobLauncher</h3><ul>
<li>JobLauncher는 Job. JobParamerters와 함께 배치를 실행하는 인터페이스입니다.</li>
</ul>
<h3 id="ItemReader"><a href="#ItemReader" class="headerlink" title="ItemReader"></a>ItemReader</h3><ul>
<li>ItemReader는 Step의 대상이 되는 배치 데이터를 읽어오는 인터페이스입니다. File, Xml Db등 여러 타입의 데이터를 읽어올 수 있습니다.</li>
</ul>
<h3 id="ItemProcessor"><a href="#ItemProcessor" class="headerlink" title="ItemProcessor"></a>ItemProcessor</h3><ul>
<li>ItemProcessor는 ItemReader로 읽어 온 배치 데이터를 변환하는 역할을 수행합니다. 이것을 분리하는 이유는 다음과 같습니다.</li>
<li>비즈니스 로직의 분리 : ItemWriter는 저장 수행하고, ItemProcessor는 로직 처리만 수행해 역할을 명확하게 분리합니다.</li>
<li>읽어온 배치 데이터와 씌여질 데이터의 타입이 다를 경우에 대응할 수 있기 때문입니다.</li>
</ul>
<h3 id="ItemWriter"><a href="#ItemWriter" class="headerlink" title="ItemWriter"></a>ItemWriter</h3><ul>
<li>ItemWriter는 배치 데이터를 저장합니다. 일반적으로 DB나 파일에 저장합니다.</li>
<li>ItemWriter도 ItemReader와 비슷한 방식을 구현합니다. 제네릭으로 원하는 타입을 받고 write() 메서드는 List를 사용해서 저장한 타입의 리스트를 매게변수로 받습니다.</li>
</ul>
<h2 id="휴면회원-배치-설계"><a href="#휴면회원-배치-설계" class="headerlink" title="휴면회원 배치 설계"></a>휴면회원 배치 설계</h2><p align="center">
  <img src="https://github.com/cheese10yun/TIL/raw/master/assets/bach-process.png">
</p>

<p><strong>가입한 회원 중 1년이 지나도록 상태 변화가 없는 회원을 휴면회원으로 전환하는 배치 처리</strong></p>
<ul>
<li>(1) DB에 저장된 데이터 중 1년간 업데이트되지 않은 사용자를 찾는 로직 ItemReader 구현합니다.</li>
<li>(2) 대상 사용자 데이터의 상탯값을 휴면으로 전환하는 프로세스를 ItemProcessor에 구현합니다.</li>
<li>(3) 상태값이 변환된 휴면회원을 실제DB에 저장하는 ItemWriter를 구현합니다.</li>
</ul>
<h2 id="휴면회원-배치-구현"><a href="#휴면회원-배치-구현" class="headerlink" title="휴면회원 배치 구현"></a>휴면회원 배치 구현</h2><p>배치처리 순서는 다음과 같습니다.</p>
<ol>
<li>휴면 회원 Job 설정</li>
<li>휴면 회원 Step 설정</li>
<li>휴면 회원 Reader, Processor, Writer 설정</li>
</ol>
<h3 id="Job-설정"><a href="#Job-설정" class="headerlink" title="Job 설정"></a>Job 설정</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InactiveUserJobConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Job <span class="title function_">inactiveUserJob</span><span class="params">(JobBuilderFactory jobBuilderFactory, Step inactiveJobStep)</span> &#123; <span class="comment">//(1)</span></span><br><span class="line">        <span class="keyword">return</span> jobBuilderFactory.get(<span class="string">&quot;inactiveUserJob&quot;</span>)</span><br><span class="line">                .preventRestart() <span class="comment">//(2)</span></span><br><span class="line">                .start(inactiveJobStep) <span class="comment">//(3)</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>(1) Job 생성을 직관적이고 편리하게 도와주는 빌더 JobBuilderFactory를 주입받습니다.</li>
<li>(2) inactiveUserJob 이라는 JobBuilder를 생성하며 <code>preventRestart()</code> 설정을 통해 재실행을 막았습니다.</li>
<li>(3) <code>start(inactiveJobStep)</code>은 파라미터에서 주입받은 휴면회원 관련 Step인 inactiveJobStep을 제일 먼저 실행하도록 설정하는 부분입니다.</li>
</ul>
<p>기본적인 Job설정은 완료 했습니다. Step 설정을 진행하겠습니다.</p>
<h3 id="Step-설정"><a href="#Step-설정" class="headerlink" title="Step 설정"></a>Step 설정</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Step <span class="title function_">inactiveJobStep</span><span class="params">(StepBuilderFactory stepBuilderFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> stepBuilderFactory.get(<span class="string">&quot;inactiveUserStep&quot;</span>) <span class="comment">//(1)</span></span><br><span class="line">            .&lt;User, User&gt; chunk(<span class="number">10</span>) <span class="comment">//(2)</span></span><br><span class="line">            .reader(inactiveUserReader()) <span class="comment">//(3)</span></span><br><span class="line">            .processor(inactiveUserProcessor())</span><br><span class="line">            .writer(inactiveUserWriter())</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>(1) <code>stepBuilderFactory.get(&quot;inactiveUserStep&quot;)</code>로 inactiveUserStep 이라는 이름의 StepBuilder를 생성합니다.</li>
<li>(2) 제네릭을 사용해서 <code>chunk()</code> 의 입력과 추력 타입을 User로 설정 했습니다. chunk의 인자값은 10으로 설정해서 <strong>쓰기 시에 청크 단위로 writer() 메서드를 실행시킬 단위를 지정했습니다. 즉 커밋단위가 10개입니다.</strong></li>
<li>(3) step의 reader, proccsor, writer를 각각 설정했습니다.</li>
</ul>
<h3 id="Reader설정"><a href="#Reader설정" class="headerlink" title="Reader설정"></a>Reader설정</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@StepScope</span> <span class="comment">//(1)</span></span><br><span class="line"><span class="keyword">public</span> QueueItemReader&lt;User&gt; <span class="title function_">inactiveUserReader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//(2)</span></span><br><span class="line">    List&lt;User&gt; oldUsers =</span><br><span class="line">            userRepository.findByUpdatedDateBeforeAndStatusEquals(</span><br><span class="line">                    LocalDateTime.now().minusYears(<span class="number">1</span>),</span><br><span class="line">                    UserStatus.ACTIVE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">QueueItemReader</span>&lt;&gt;(oldUsers); <span class="comment">//(3)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>(1) 기본 빈 생성은 싱글턴이지만 @StepScope를 사용하면 해당 메서드는 Step의 주기에 따라 새로운 빈을 생성합니다. <strong>즉, 각 Step의 실행마다 새로운 빈을 만들기 때문에 지연 생성이 가능합니다. 주의할 사항은 @StepScode는 기본 프록시 모드가 반환되는 클래스 타임을 참조하기 때문에 @StepScode를 사용하면 반드시 구현된 반환 타입을 명시해 변환해야합니다.</strong> 해당 예제는 QueueItemReader<User>라고 명시했습니다.</li>
<li>(2) <code>findByUpdatedDateBeforeAndStatusEquals()</code> 메서드를 통해서 휴면 회원 리스트를 가져옵니다.</li>
<li>(3) QueueItemReader 객체를 생성하고 불러온 휴면회원 타깃 대상을 데이터 객체에 넣어 반환합니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueItemReader</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">ItemReader</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;T&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QueueItemReader</span><span class="params">(List&lt;T&gt; data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(data); <span class="comment">//(1)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> Exception, UnexpectedInputException, ParseException, NonTransientResourceException &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll(); <span class="comment">//(2)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>QueueItemReader는 큐를 사용해서 자장하는 ItemReader 구현체입니다. ItemReader의 기본 반환 타입은 단수형인데 그 에 따라 구현하면 User 객체 1개씩 DB에 select 요청 하므로 매우 비효율적인 방식이 될 수 있습니다.</p>
<ul>
<li>(1) QueueItemReader를 사용해서 휴면회원으로 지정될 타깃 데이터를 한번에 불러와 큐에 담아 놓습니다.</li>
<li>(2) reade() 메서드를 사용할 때 큐의 <code>poll()</code>메서드를 통해서 큐에서 데이터를 하나씩 반환합니다.</li>
</ul>
<h3 id="Processor-설정"><a href="#Processor-설정" class="headerlink" title="Processor 설정"></a>Processor 설정</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ItemProcessor&lt;User, User&gt; <span class="title function_">inactiveUserProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> user -&gt; user.setInactive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>읽어온 타깃 데이터를 휴면 회원으로 전환시키는 Processor입니다. reader에서 읽은 User를 휴면 상태로 전환화는 Processor 메서드를 추가하는 예입니다.</p>
<h3 id="Writer-설정"><a href="#Writer-설정" class="headerlink" title="Writer 설정"></a>Writer 설정</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ItemWriter&lt;User&gt; <span class="title function_">inactiveUserWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((List&lt;? <span class="keyword">extends</span> <span class="title class_">User</span>&gt; users) -&gt; userRepository.saveAll(users));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ItemWriter는 리스트 타입을 앞서 설정한 청크 단위로 받습니다. 청크 단위를 10으로 설정했기 때문에 users에게 휴면회원 10개가 주어지며 saveAll()메서드를 통해서 한번에 DB에 저장합니다.</p>
<h2 id="배치-심화"><a href="#배치-심화" class="headerlink" title="배치 심화"></a>배치 심화</h2><ul>
<li>다양한 ItemReader 구현 클래스</li>
<li>다양한 ItemWriter 구현 클래스</li>
<li>JobParameter 사용하기</li>
<li>테스트 시에만 H2 DB를 사용 하도록 설정하기</li>
<li>청크 지향 프로세싱</li>
<li>배치 인터셉터 Listener 설정하기</li>
<li>어노테이션 기반 Listener 설정하기</li>
</ul>
<h3 id="다양한-ItemReader-구현-클래스"><a href="#다양한-ItemReader-구현-클래스" class="headerlink" title="다양한 ItemReader 구현 클래스"></a>다양한 ItemReader 구현 클래스</h3><p>기존에는 QueueItemReader 객체를 사용 해서 모든 데이터를 한번에 와서 배치처치를 진행했습니다. <strong>하지만 수백, 수천 개 이상의 데이터를 한번에 가져와서 메모리에 올려놓게되면 좋지 않습니다.</strong> 이때 배치 프로젝트에서 제공하는 PagingItemRedaer 구현체를 사용 사용할 수있습니다. 구현체는 크게 JdbcPagingItemReader, JpaPagingItemRedaer, HibernatePagingItemRdaer가 있습니다. 해당 예쩨에서는 JpaPagingItemRedaer를 사용하겠습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(destroyMethod=&quot;&quot;)</span> <span class="comment">//(1)</span></span><br><span class="line"><span class="meta">@StepScope</span></span><br><span class="line"><span class="keyword">public</span> JpaPagingItemReader&lt;User&gt; <span class="title function_">inactiveUserJpaReader</span><span class="params">(<span class="meta">@Value(&quot;#&#123;jobParameters[nowDate]&#125;&quot;)</span> Date nowDate)</span> &#123;</span><br><span class="line">    JpaPagingItemReader&lt;User&gt; jpaPagingItemReader = <span class="keyword">new</span> <span class="title class_">JpaPagingItemReader</span>&lt;&gt;();</span><br><span class="line">    jpaPagingItemReader.setQueryString(<span class="string">&quot;select u from User as u where u.createdDate &lt; :createdDate and u.status = :status&quot;</span>); <span class="comment">//(2)</span></span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.ofInstant(nowDate.toInstant(), ZoneId.systemDefault());</span><br><span class="line">    map.put(<span class="string">&quot;createdDate&quot;</span>, now.minusYears(<span class="number">1</span>));</span><br><span class="line">    map.put(<span class="string">&quot;status&quot;</span>, UserStatus.ACTIVE);</span><br><span class="line"></span><br><span class="line">    jpaPagingItemReader.setParameterValues(map); <span class="comment">//(3)</span></span><br><span class="line">    jpaPagingItemReader.setEntityManagerFactory(entityManagerFactory); <span class="comment">//(4)</span></span><br><span class="line">    jpaPagingItemReader.setPageSize(CHUNK_SIZE); <span class="comment">//(5)</span></span><br><span class="line">    <span class="keyword">return</span> jpaPagingItemReader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>(1) 스프링에서 destroyMethod를 사용해서 삭제할 빈을 자동으로 추적합니다. destroyMethod&#x3D;””를 설정하면 warring 메세지를 제거할 수 있습니다.</li>
<li>(2) JpaPagingItemReader를 사용하면 쿼리를 직접 짜거 실행 하는 방법밖에는 없습니다.</li>
<li>(3) 쿼리리에서 사용된 updateDate, status 파라미터를 Mpa에 추가해서 사용할 파라미터를 설정합니다</li>
<li>(4 )트랜잭션을 관리해줄 entityManagerFactory를 설정합니다.</li>
<li>(5) 한번에 읽어올 크기를 CHUNK_SIZE 만큼 할당합니다.</li>
</ul>
<h3 id="다양한-ItemWriter-구현-클래스"><a href="#다양한-ItemWriter-구현-클래스" class="headerlink" title="다양한 ItemWriter 구현 클래스"></a>다양한 ItemWriter 구현 클래스</h3><p>ItemReader와 마찬가지로 상황에맞는 여러 구현 클래스를 제공합니다. JPA를 사용하고 있음으로 JpaItemWriter를 적용합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> JpaItemWriter&lt;User&gt; <span class="title function_">inactiveUserWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    JpaItemWriter&lt;User&gt; jpaItemWriter = <span class="keyword">new</span> <span class="title class_">JpaItemWriter</span>&lt;&gt;();</span><br><span class="line">    jpaItemWriter.setEntityManagerFactory(entityManagerFactory);</span><br><span class="line">    <span class="keyword">return</span> jpaItemWriter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JobParameter-사용하기"><a href="#JobParameter-사용하기" class="headerlink" title="JobParameter 사용하기"></a>JobParameter 사용하기</h3><p>JobParameter를 사용해서 Step을 실행시킬 때 동적으로 파라미터를 주입시킬 수 있습니다.</p>
<h3 id="테스트-시에만-H2-데이터베이스를-사용하도록-설정"><a href="#테스트-시에만-H2-데이터베이스를-사용하도록-설정" class="headerlink" title="테스트 시에만 H2 데이터베이스를 사용하도록 설정"></a>테스트 시에만 H2 데이터베이스를 사용하도록 설정</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureTestDatabase(connection = EmbeddedDatabaseConnection.H2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@AutoConfigureTestDatabase(connection = EmbeddedDatabaseConnection.H2)</code> 어노테이션으로 간단하세 설정 가능합니다</p>
<h3 id="청크-지향-프로세싱"><a href="#청크-지향-프로세싱" class="headerlink" title="청크 지향 프로세싱"></a>청크 지향 프로세싱</h3><p align="center">
  <img src="https://github.com/cheese10yun/TIL/raw/master/assets/chun-process.png">
</p>
청크 지향 프로세싱은 트랜잭션 경계 내에서 청크 단위로 데이터를 읽고 생성하는 프로그래밍 기법입니다. 청크란 아이템이 트랜잭션에 커밋되는 수를 말합니다. read한 데이터 수가 지정한 청크 단위와 칠치하면 write를 수행하고 트랜잭션을 커밋합니다. Step 설정에서 chunk()로 커밋 단위를 지정했던 부분입니다. 즉 기존에도 계속 사용해온 방법이 청크 지향 프로세싱입니다.

<p>청크 지향프러그래밍의 이점은 1000개 개의 데이터에 대해 배치 로직을 실행한다고 가정했을 때 청크로 나누지 않았을 때는 하나만 실패해도 다른 성공한 999개의 데이터가 롤백됩니다. 그런데 청크 단위를 10으로 해서 배치처리를 하면 도중에 배치 처리에 실패하더라도 다른 청크는 영향을 받지 않습니다. 이러한 이유로 스프링 배치에 청크 단위로 프로그래밍을 지향합니다.</p>
<h3 id="배치-인터셉터-Listener-설정하기"><a href="#배치-인터셉터-Listener-설정하기" class="headerlink" title="배치 인터셉터 Listener 설정하기"></a>배치 인터셉터 Listener 설정하기</h3><p>배치 흐름에서 전후 처리를 하는 Listener를 설정할 수 있습니다. 구체적으로 Job의 전후 처리 Step의 전후 처리 각 청크 단위의 전후 처리 등 세세한 과정 실행시 특정 로직을 할당해 제어할 수있습니다. 가장 대표적인 예로는 로깅 작업이 있습니다.</p>
<h3 id="어노테이션-기반-Listener-설정하기"><a href="#어노테이션-기반-Listener-설정하기" class="headerlink" title="어노테이션 기반 Listener 설정하기"></a>어노테이션 기반 Listener 설정하기</h3><p>배치 인터셉터 인터페이스를 활용해서 사용하는 방법도 있고 애노테이션을 사용해서 활용하는 방법도 있습니다. 대표적으로 <code>@BeforeStep, @AsfterStep</code> 등이 있습니다. 해당 어노테이션으로 시작 전후에 로그를 남기는 설정도 가능합니다.</p>
<h3 id="JobParameter-사용하기-1"><a href="#JobParameter-사용하기-1" class="headerlink" title="JobParameter 사용하기"></a>JobParameter 사용하기</h3><p>JapParameter를 사용해 Step을 실행시킬 때 동적으로 파라미터를 주입시클 수 있습니다.</p>
<h3 id="Step의-흐름을-제어하는-Flow"><a href="#Step의-흐름을-제어하는-Flow" class="headerlink" title="Step의 흐름을 제어하는 Flow"></a>Step의 흐름을 제어하는 Flow</h3><p>Step의 가장 기본적은 흐름은 <code>읽기-처리-쓰기</code> 입니다. 여기서 세부적인 조건에 따라서 Step의 실행 여부를 정할 수 있습니다. 이런 흐름을 제어하는 <code>Flow</code> 제공 합니다.</p>
<p align="center">
  <img src="https://github.com/cheese10yun/TIL/raw/master/assets/batch-flow.png">
</p>

<p>흐름에 조건에 해당하는 부분을 <code>JobExecutionDecider</code> 인터페이스를 사용해 구현 할 수 있습니다. <code>JobExecutionDecider</code> 인터페이스는 <code>decide()</code> 메서드 하나만 제공합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JobExecutionDecider</span> &#123;</span><br><span class="line">    FlowExecutionStatus <span class="title function_">decide</span><span class="params">(JobExecution jobExecution, <span class="meta">@Nullable</span> StepExecution stepExecution)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Class xxxJobExecutionDecider <span class="keyword">implements</span>  <span class="title class_">JobExecutionDecider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FlowExecutionStatus <span class="title function_">decide</span><span class="params">(JobExecution jobExecution, <span class="meta">@Nullable</span> StepExecution stepExecution)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(특정 조건...)&#123; <span class="comment">// (1)</span></span><br><span class="line">            <span class="keyword">return</span> FlowExecutionsStatus.COMPLETED; <span class="comment">// (2)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FlowExecutionsStatus.FAILED; <span class="comment">// (3)</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>(1) 특정 조건에 대한 로직</li>
<li>(2) 조건에 만족하고 JobStep을 실행 시킬 경우 <code>COMPLETED</code> 리턴</li>
<li>(3) 조건에 만족하지 않고 JobStep을 <strong>실행 하지않을 경우</strong>  <code>FAILED</code> 리턴</li>
</ul>
<p><code>Flow</code> 조건으로 사용될 경우 InactiveJobExceutionDecider 클래스를 구현 했습니다. 이를 사용할 Flow를 구현 해야합니다. <code>Step</code> 메서드가아닌 <code>Flow</code>를 주압 받고 주입받은 <code>Flow</code>를 빈으로 등록해야합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Flow <span class="title function_">xxxJobFlow</span><span class="params">(Step xxxJobStep)</span>&#123;</span><br><span class="line">    FlowBuilder&lt;Flow&gt; flowBuilder = <span class="keyword">new</span> <span class="title class_">FlowBuilder</span>&lt;&gt;(<span class="string">&quot;xxxJobFlow&quot;</span>); <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flowBuilder</span><br><span class="line">        .start(<span class="keyword">new</span> <span class="title class_">xxxJobExcetuinDeicder</span>()) <span class="comment">// (2)</span></span><br><span class="line">        .on(FlowExecutionStatus.FAILED.getName()).end() <span class="comment">// (3)</span></span><br><span class="line">        .on(FlowExecutionStatus.COMPLETED.getName()).to(xxxJobStep).end(); <span class="comment">// (4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>(1) <code>FlowBuilder</code>를 시용해서 Flow 객체를 생성합니다.</li>
<li>(2) 위에서 작성한 <code>xxxJobExecutionDecider</code> 클래스를 <code>start()</code> 으로 설정해 맨 처음 시작하도록 합니다.</li>
<li>(3) <code>xxxJobExecutionDecider</code> 클래스의 decide() 메서드를 통해 리턴 값이 <code>FAILED</code> 일 경우 <code>end()</code> 메서드를 사용해서 끝나도록 설정합니다.</li>
<li>(4) <code>xxxJobExecutionDecider</code> 클래스의 decide() 메서드를 통해 리턴 값이 <code>COMPLETED</code> 일 경우 기존에 설정한 <code>xxxJobStep</code>을 실행하도록 설정합니다.</li>
</ul>
<h2 id="재시도"><a href="#재시도" class="headerlink" title="재시도"></a>재시도</h2><p>네트워크 접속이 끊어지거나 장비가 다운되는 등 실패 시나리오는 다양합니다. 시스템은 언젠가 복구 될테니 다시 한번 시도는 해볼 가치는 있습니다.</p>
<h3 id="스템-구성하기"><a href="#스템-구성하기" class="headerlink" title="스템 구성하기"></a>스템 구성하기</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Step <span class="title function_">step1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> steps.get(<span class="string">&quot;user xxxxx&quot;</span>)</span><br><span class="line">    .&lt;User, User&gt;chunk(<span class="number">10</span>)</span><br><span class="line">        .faulTolerant()</span><br><span class="line">            .retryLimit(<span class="number">3</span>).retry(XXXXXException.class)</span><br><span class="line">    .render(something())</span><br><span class="line">    .writer(something())</span><br><span class="line">    .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>자바 구성으로 재시도를 활성화 할 경우, 첫 번째 스텝은 오류를 허용하도록 만들어야 재시도 제한 횟수 및 재시도 대상 예외를 지정할 수 있습니다. 먼저 <code>faulTolerant()</code>로 오류 허용 스탭을 얻은후, <code>retryLimit()</code> 메서드로 재시도 제한 횟수를, <code>retry()</code> 메서드로 재시도 대상 예외를 발생합니다.</p>
<h3 id="재시도-템플릿"><a href="#재시도-템플릿" class="headerlink" title="재시도 템플릿"></a>재시도 템플릿</h3><ul>
<li>스프링 배치가 제공하는 재시도 및 복구 서비스를 코드에 활용하는 다른 방법도 있습니다. 재시도 로직을 구현된 커스텀 ItemWriter<T>를 작성하거나 아예 전체 서비스 인터페이스에 재시도 기능을 입힐 수 있습니다.</li>
<li>스프링 배치 RetryTemplate은 바로 이런 용도로 만들어진 클래스입니다. 비니지스 로직과 재시도 로직을 분리해서 마치 재시도 없이 한 번만 시도하는 것처럼 코드를 작성할 수 있개 해줍니다.</li>
<li>재시도 -&gt; 실패 -&gt; 복구 반복적인 과정을 간명한 하나의 API 메서드로 호출로 감싼 <code>RetryTemplate</code>는 여러 가지 유스 케이스를 지원합니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetryableUserRegistrationServiceItemWriter</span> <span class="keyword">implements</span> <span class="title class_">ItemWriter</span>&lt;UserRegistration&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(RetryableUserRegistrationServiceItemWriter.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRegistrationService userRegistrationService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RetryTemplate retryTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RetryableUserRegistrationServiceItemWriter</span><span class="params">(UserRegistrationService userRegistrationService, RetryTemplate retryTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRegistrationService = userRegistrationService;</span><br><span class="line">        <span class="built_in">this</span>.retryTemplate = retryTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * takes aggregated input from the reader and &#x27;writes&#x27; them using a custom implementation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(List&lt;?extends UserRegistration&gt; items)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> UserRegistration userRegistration : items) &#123;</span><br><span class="line">            <span class="type">UserRegistration</span> <span class="variable">registeredUserRegistration</span> <span class="operator">=</span> retryTemplate.execute(</span><br><span class="line">                    (RetryCallback&lt;UserRegistration, Exception&gt;) context -&gt; userRegistrationService.registerUser(userRegistration));</span><br><span class="line"></span><br><span class="line">            logger.debug(<span class="string">&quot;Registered: &#123;&#125;&quot;</span>, registeredUserRegistration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  ....</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RetryTemplate <span class="title function_">retryTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RetryTemplate</span> <span class="variable">retryTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RetryTemplate</span>();</span><br><span class="line">        retryTemplate.setBackOffPolicy(backOffPolicy());</span><br><span class="line">        <span class="keyword">return</span> retryTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ExponentialBackOffPolicy <span class="title function_">backOffPolicy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ExponentialBackOffPolicy</span> <span class="variable">backOffPolicy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackOffPolicy</span>();</span><br><span class="line">        backOffPolicy.setInitialInterval(<span class="number">1000</span>);</span><br><span class="line">        backOffPolicy.setMaxInterval(<span class="number">10000</span>);</span><br><span class="line">        backOffPolicy.setMultiplier(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> backOffPolicy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>재시도 시간 간격을 정하는 BackOffplicy는 RetryTemplate의 유용한 기능입니다. 실제로 실패 직후 재시도하는 시간 간격을 점점 늘려 여러 클라이언트가 같은 호출 할때 스텝이 잠기지 않도록 예방하는 수단으로 활용할 수있습니다.</li>
</ul>
<h3 id="AOP-기반-재시도"><a href="#AOP-기반-재시도" class="headerlink" title="AOP 기반 재시도"></a>AOP 기반 재시도</h3><p>스프링 배치가 제공하는 AOP 어드바이저를 이용해서 RetryTempate 처럼 사용할 수 있습니다. 프록시 전체에 재시 로직 어드바이스를 추가하면 RetryTempate이 빠진 본래 코드로 그대로 사용가능합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retryable(backoff = @Backoff(delay = 1000, maxDely = 10000, multiplier = 2))</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">batchSomething</span><span class="params">()</span>&#123;....&#125;</span><br></pre></td></tr></table></figure>
<p><strong>구성 클래스에 반드시 @EnableRety 를추가 해야합니다.</strong></p>
<h2 id="Spring-Batch-Table"><a href="#Spring-Batch-Table" class="headerlink" title="Spring Batch Table"></a>Spring Batch Table</h2><p align="center">
  <img src="https://github.com/cheese10yun/TIL/raw/master/assets/meta-data-erd.png">
</p>

<h3 id="BATCH-JOB-INSTANCE"><a href="#BATCH-JOB-INSTANCE" class="headerlink" title="BATCH_JOB_INSTANCE"></a>BATCH_JOB_INSTANCE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `BATCH_JOB_INSTANCE` (</span><br><span class="line">  `JOB_INSTANCE_ID` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `VERSION` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `JOB_NAME` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `JOB_KEY` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`JOB_INSTANCE_ID`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `JOB_INST_UN` (`JOB_NAME`,`JOB_KEY`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>JOB_INSTANCE_ID</th>
<th>VERSION</th>
<th>JOB_NAME</th>
<th>JOB_KEY</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
<td>inactiveUserJob</td>
<td>df9e59b818ab301226e71dcf67795b07</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>inactiveUserJob</td>
<td>34c2f2838f31f237450a6c7659e36995</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>orderDailySumJob</td>
<td>d41d8cd98f00b204e9800998ecf8427e</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>orderDailySumJob</td>
<td>d6832decf796311c39d3d934a9d7cfd5</td>
</tr>
<tr>
<td>5</td>
<td>0</td>
<td>orderDailySumJob</td>
<td>212470e06656926b4b339a42dc5d64c3</td>
</tr>
</tbody></table>
<p>JOB_INSTANCE_ID는 BATCH_JOB_INSTANCE 테이블의 PK, JOB_NAME 수행한 Batch Job Name</p>
<p><strong>BATCH_JOB_INSTANCE 테이블은 Job Parameter에 따라 생성됩니다.</strong> Job Parameter는 Spring Batch가 실행될때 외부에서 받을 수 있는 파라미터 입니다. <strong>같은 Batch Job 이라도 Job Parameter가 다르면 다른 BATCH_JOB_INSTANCE 에 기록됩니다.</strong> BATCH_JOB_EXECUTION_PARAMS 기반으로 JOB_KEY를 만들며 해당 값은 유니크 제약조건이 있기 때문에 같은 BATCH_JOB_EXECUTION_PARAMS을 넘기는 경우 생성되지 않습니다.</p>
<h3 id="BATCH-JOB-EXECUTION"><a href="#BATCH-JOB-EXECUTION" class="headerlink" title="BATCH_JOB_EXECUTION"></a>BATCH_JOB_EXECUTION</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `BATCH_STEP_EXECUTION` (</span><br><span class="line">  `STEP_EXECUTION_ID` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `VERSION` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `STEP_NAME` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `JOB_EXECUTION_ID` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `START_TIME` datetime <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `END_TIME` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `STATUS` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `COMMIT_COUNT` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `READ_COUNT` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `FILTER_COUNT` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `WRITE_COUNT` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `READ_SKIP_COUNT` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `WRITE_SKIP_COUNT` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `PROCESS_SKIP_COUNT` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ROLLBACK_COUNT` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `EXIT_CODE` <span class="type">varchar</span>(<span class="number">2500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `EXIT_MESSAGE` <span class="type">varchar</span>(<span class="number">2500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `LAST_UPDATED` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`STEP_EXECUTION_ID`),</span><br><span class="line">  KEY `JOB_EXEC_STEP_FK` (`JOB_EXECUTION_ID`),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `JOB_EXEC_STEP_FK` <span class="keyword">FOREIGN KEY</span> (`JOB_EXECUTION_ID`) <span class="keyword">REFERENCES</span> `BATCH_JOB_EXECUTION` (`JOB_EXECUTION_ID`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>JOB_EXECUTION_ID</th>
<th>VERSION</th>
<th>JOB_INSTANCE_ID</th>
<th>CREATE_TIME</th>
<th>START_TIME</th>
<th>END_TIME</th>
<th>STATUS</th>
<th>EXIT_CODE</th>
<th>EXIT_MESSAGE</th>
<th>LAST_UPDATED</th>
<th>JOB_CONFIGURATION_LOCATION</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>1</td>
<td>2019-07-02 06:51:22</td>
<td>2019-07-02 06:51:22</td>
<td>2019-07-02 06:51:23</td>
<td>COMPLETED</td>
<td>COMPLETED</td>
<td></td>
<td>2019-07-02 06:51:23</td>
<td>NULL</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2019-07-02 07:14:00</td>
<td>2019-07-02 07:14:00</td>
<td>2019-07-02 07:14:01</td>
<td>COMPLETED</td>
<td>COMPLETED</td>
<td></td>
<td>2019-07-02 07:14:01</td>
<td>NULL</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>3</td>
<td>2020-01-13 11:00:50</td>
<td>2020-01-13 11:00:50</td>
<td>2020-01-13 11:00:50</td>
<td>COMPLETED</td>
<td>COMPLETED</td>
<td></td>
<td>2020-01-13 11:00:50</td>
<td>NULL</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>4</td>
<td>2020-01-13 11:59:15</td>
<td>2020-01-13 11:59:15</td>
<td>2020-01-13 11:59:15</td>
<td>COMPLETED</td>
<td>COMPLETED</td>
<td></td>
<td>2020-01-13 11:59:15</td>
<td>NULL</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>5</td>
<td>2020-01-13 12:48:53</td>
<td>2020-01-13 12:48:53</td>
<td>2020-01-13 12:48:54</td>
<td>COMPLETED</td>
<td>COMPLETED</td>
<td></td>
<td>2020-01-13 12:48:54</td>
<td>NULL</td>
</tr>
</tbody></table>
<ul>
<li><code>JOB_EXECUTION_ID</code> 칼럼은 <code>BATCH_JOB_INSTANCE</code> 테이블의 PK를 참조 하고 있습니다.</li>
<li><code>BATCH_STEP_EXECUTION</code> 와 <code>BATCH_JOB_INSTANCE</code>는 부모 자식관계입니다.</li>
<li>BATCH_STEP_EXECUTION는 자신의 부모 BATCH_JOB_INSTANCE 성공&#x2F;실패 내역을 모두 갖고 있습니다.</li>
<li>jobParameters : Job 실행에 필요한 매개변수 데이터입니다.</li>
<li>jobInstance : Job 실행 단위가 되는 객체입니다.</li>
<li>stepExecutuons : StepExecutuon을 여러개 가질 수 있는 Collection 타입입니다.</li>
<li>status : Job 실행 상태를 나타내는 필드(Enum)입니다. 상태값으로는 <code>COMPLETED, STARTING, STARTED, STOPPING, STOPPED, FAILED, ABANDONED, UNKNOWN</code> 이 있습니다.</li>
<li>startTime : Job이 실행된 시간입니다. null이면 시작되지 않았다는 의미 입니다.</li>
<li>createTime : JobExecution이 생성된 시간입니다.</li>
<li>endTime: JobExecution이 끝난 시간입니다.</li>
</ul>
<p align="center">
  <img src="https://github.com/cheese10yun/TIL/raw/master/assets/job-job-instance-job-execution.png">
</p>

<ul>
<li><code>Job</code>: 특정 잡, 2달이상 로그인안한 유저 휴면 회원 처리 등</li>
<li><code>Job Instance</code>: Job Parameter를 실행한 Job(Job Parameter 단위로 생성)</li>
<li><code>Job Execution</code>: Job Parameter로 실행한 Job의 실행, 1번 째 시도 혹은 그 다음 등</li>
</ul>
<h3 id="BATCH-JOB-EXECUTION-PARAMS"><a href="#BATCH-JOB-EXECUTION-PARAMS" class="headerlink" title="BATCH_JOB_EXECUTION_PARAMS"></a>BATCH_JOB_EXECUTION_PARAMS</h3><table>
<thead>
<tr>
<th>JOB_EXECUTION_ID</th>
<th>TYPE_CD</th>
<th>KEY_NAME</th>
<th>STRING_VAL</th>
<th>DATE_VAL</th>
<th>LONG_VAL</th>
<th>DOUBLE_VAL</th>
<th>IDENTIFYING</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>STRING</td>
<td>requestDate</td>
<td>2019-10-13</td>
<td>1970-01-01 00:00:00</td>
<td>0</td>
<td>0</td>
<td>N</td>
</tr>
<tr>
<td>5</td>
<td>LONG</td>
<td>run.id</td>
<td></td>
<td>1970-01-01 00:00:00</td>
<td>2</td>
<td>0</td>
<td>Y</td>
</tr>
<tr>
<td>5</td>
<td>STRING</td>
<td>version</td>
<td>12</td>
<td>1970-01-01 00:00:00</td>
<td>0</td>
<td>0</td>
<td>Y</td>
</tr>
<tr>
<td>5</td>
<td>STRING</td>
<td>-job.name</td>
<td>orderDailySumJob</td>
<td>1970-01-01 00:00:00</td>
<td>0</td>
<td>0</td>
<td>N</td>
</tr>
</tbody></table>
<p><strong>BATCH_JOB_EXECUTION에 대한 Parameter정보들이 저장되는 곳이다</strong> BATCH_JOB_EXECUTION, BATCH_JOB_EXECUTION_PARAMS 1:N 관계이며 위 테이블은 ID 5번에 들어가는 parameter 정보들이 저장된다</p>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a target="_blank" rel="noopener" href="https://kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9791162241264&orderClick=JAj">처음으로 배우는 스프링 부트 2</a>를 정리한 글입니다.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/jojoldu/spring-batch-in-action/blob/master/3_%EB%A9%94%ED%83%80%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%BF%EB%B3%B4%EA%B8%B0.md">기억보단 기록을 - spring-batch-in-action</a></li>
</ul>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">태그</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/Spring-Batch/" rel="tag">Spring Batch</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/spring-oauth2-provider/"
                    data-tooltip="Spring OAuth2 Provider 정리"
                    aria-label="이전: Spring OAuth2 Provider 정리"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/spring-solid-srp/"
                    data-tooltip="Spring 예제로 보는 SOLID SRP"
                    aria-label="다음: Spring 예제로 보는 SOLID SRP"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/spring-batch-basic/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/spring-batch-basic/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cheese10yun.github.io/spring-batch-basic/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>


<!-- Comment -->
<!--  utteranc comment -->

<script src="https://utteranc.es/client.js"
        repo="cheese10yun/blog-comment"
        issue-term="title"
        label="Comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Yun. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/spring-oauth2-provider/"
                    data-tooltip="Spring OAuth2 Provider 정리"
                    aria-label="이전: Spring OAuth2 Provider 정리"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/spring-solid-srp/"
                    data-tooltip="Spring 예제로 보는 SOLID SRP"
                    aria-label="다음: Spring 예제로 보는 SOLID SRP"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/spring-batch-basic/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/spring-batch-basic/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cheese10yun.github.io/spring-batch-basic/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="5">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/spring-batch-basic/"
                        aria-label="Facebook에 공유하기"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Facebook에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/spring-batch-basic/"
                        aria-label="Twitter에 공유하기"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Twitter에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://cheese10yun.github.io/spring-batch-basic/"
                        aria-label="Google+에 공유하기"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Google+에 공유하기</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
            <h4 id="about-card-name">Yun</h4>
        
            <div id="about-card-bio"><p>기술 블로그</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
