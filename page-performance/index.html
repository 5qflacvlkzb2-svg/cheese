
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="naver-site-verification" content="a37ea649edf26e70c3de94f9cb034f9d6e11de3f" />
    <meta name="generator" content="Yun Blog">
    <title>JPA 페이징 Performance 향상 방법 - Yun Blog</title>
    <meta name="author" content="Yun">
    
        <meta name="keywords" content="Node,Spring,Spring Boot,Spring Batch,Kotlin,기술 블로그,JPA,Mongo,MySQL,OOP,">
    
    
    
        
            <link rel="alternate" type="application/rss+xml" title="RSS" href="/rss2.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg"},"articleBody":"일반적으로 어드민 페이지와 같이 데이터를 테이블 뷰 형식으로 제공할 때, 페이징 기법을 사용하여 현재 페이지의 내용과 페이지 정보를 표시합니다. JPA를 활용하면 이러한 반복적인 코드 작성을 보다 쉽게 처리할 수 있습니다.\n데이터 모수가 적고 단순한 구조로 데이터를 보여주는 경우라면 JPA에서 제공해 주는 방식으로 처리하는 것이 효율적일 수 있으나 데이터 모수가 많고 여러 테이블을 조인해서 표현해야 하는 데이터 구조라면 성능적인 이슈가 발생할 수 있습니다. 이러한 이슈와 성능 개선 방법에 대해 알아보겠습니다.\nQuerydsl 페이징 처리 방식\n데이터 모수가 적고 간단한 조회 구조를 가질 때, Querydsl의 applyPagination 메서드를 활용하면 페이징 로직을 더 쉽게 작성할 수 있습니다.\n123456789101112class OrderCustomRepositoryImpl : QuerydslRepositorySupport(Order::class.java), OrderCustomRepository &#123;    override fun findPagingBy(        pageable: Pageable,        address: String    ): Page&lt;Order&gt; &#123;        val query: JPAQuery&lt;Order&gt; = from(order).select(order).where(order.address.eq(address))        val content: List&lt;Order&gt; = querydsl.applyPagination(pageable, query).fetch()        val totalCount: Long = query.fetchCount()        return PageImpl(content, pageable, totalCount)    &#125;&#125;\nSpring-JPA Best Practices step-15 - Querydsl를 이용해서 Repository 확장하기 (1)에서 공유드린 QuerydslRepositorySupport를 기반으로 JpaRepository 확장시켜 페이징 로직을 구현했습니다.\n세부 구현체에서는 조회 로직을 살펴보겠습니다. 이 과정에서 Querydsl를 기반으로 JPAQuery를 생성하며 필요한 조회 조건을 작성합니다. 그런 다음 해당 쿼리 객체를 이용하여 Content 조회와 전체 레코드 수 조회를 수행합니다. 마지막으로 각각의 실제 쿼리를 확인하게 됩니다.\n123456789101112select order0_.id           as id1_4_,       ...       order0_.address      as address4_4_,       order0_.created_at   as created_2_4_,       order0_.updated_at   as updated_3_4_,from orders order0_where order0_.address = ?limit ?, ?select count(order0_.id) as col_0_0_from orders order0_where order0_.address = ?\nContent 조회에 필요하 조회 쿼리와, 전체 레코드 조회에 필요한 쿼리를 JPAQuery를 통해 동일하게 사용이 가능하며, Querydsl의 applyPagination 메서드를 활용하여 offset 및 limit 관련 페이징 로직을 간단하게 구현할 수 있다는 큰 장점이 있습니다.\nQuerydsl의 applyPagination을 활용하면 페이징 조회 관련 로직을 간단하게 구현할 수 있어서 개발 생산성 측면에서 큰 이점이 있습니다. 그러나 모든 개발 결정 과정에서는 트레이드오프가 발생합니다. 편리한 기능을 즉시 활용할 수 있지만, 나중에는 추가 비용을 지불해야 하며 이 비용은 이자를 포함하여 청구될 수 있습니다.\n어떤 문제가 발생하는지 살펴보겠습니다.\nCount 쿼리의 성능 문제\nCount 쿼리는 특정 조건에 해당하는 전체 레코드 수를 조회하는 구조로, 데이터 총량이 증가하면 성능 저하가 발생할 수 있습니다. Content를 조회하는 limit 및 offset 쿼리는 빠르게 처리되는(offset 비교적 크지 않은 초반 구간) 반면 Count 쿼리는 시간이 오래 걸려 병목 현상이 발생할 수 있습니다. 또한, 여러 테이블을 조인하여 데이터를 조회하는 경우에는 조회 조건이 복잡해져 정확한 인덱스를 타겟팅하기 어려운 이슈가 발생할 수 있습니다. 이는 조회 조건에 부합하는 전체 레코드를 Count 하는 구조에서 필연적으로 발생할 수밖에 없는 문제입니다.\nCount 쿼리의 최적화 문제\n이러한 문제 외에도 다른 문제가 있습니다. JPAQuery를 사용하여 Content 조회 쿼리와 레코드 Count 조회 쿼리를 동일하게 처리하면 성능적인 손해가 발생할 수 있습니다. 특히 여러 테이블을 조인하여 데이터를 조회하는 경우에 이 문제가 더 두드러집니다.\n\n주문 조회 시에 사용자 및 쿠폰 정보와 함께 내려줘야 하는 경우, 조회 필터에 주문 정보만 있는 상황에서 Count 쿼리를 실행할 때, 다른 테이블의 조인 없이 주문에 대한 Count 쿼리를 작성하는 것이 효율적입니다.\n1234567891011121314151617181920212223-- Content 조회 쿼리select o.*,       u.*,       c.*from orders o         left join coupon c on o.coupon_id = c.id         inner join user u on o.user_id = u.idwhere o.address = ? limit ?, ?;-- Content 조회 쿼리를 그대로 사용하는 경우select count(o.id)from orders o         left join coupon c on o.coupon_id = c.id         inner join user u on o.user_id = u.idwhere o.address = ?;-- Content 쿼리를 사용하지 않고 별도의 Count 조회 쿼리select count(o.id) ascountfrom orders owhere o.address = ?;\n주문 조회에서 address 필드만 조회 조건에 해당된다면, 사용자 및 쿠폰 테이블과의 조인은 필요하지 않습니다. 이 경우, Count 쿼리를 간단하게 주문 테이블만을 대상으로 작성하는 것이 효율적입니다. 조회 조건이 복잡해질 때, Count 쿼리를 별도로 작성하는 것은 성능적으로 장점을 가질 수 있습니다.\nQuerydsl 페이징 성능 최적화 방법\nSlice 기반으로 Count 쿼리를 사용하지 않는 방법\nJPA Slice 방식은 Page 방식과는 다르게 Total Count를 조회하는 count 쿼리를 실행하지 않는 방식입니다. 따라서 Total Count를 조회하는데 드는 시간을 절약하여 성능적인 이점을 얻을 수 있습니다. 페이지네이션 된 데이터를 불러올 때, 전체 데이터의 총개수를 파악하지 않고도 일부 데이터를 가져올 수 있기 때문에, Total Count가 필요 없는 상황에서 사용하면 성능을 향상시킬 수 있습니다. Slice 방식은 특히 대용량 데이터의 페이징 처리에 유용합니다. 이렇게 Slice 방식은 Total Count를 구하지 않고도 효율적인 페이징 처리를 가능하게 합니다. Total Count가 꼭 필요한 데이터인지 비즈니스 적으로 확인해 보고 꼭 필요한 데이터가 아니라면 사용하지 않는 것을 권장 드립니다.\nSlice 페이징 처리 방법\nSpring Data에서는 Slice를 통해 Total Count를 조회하지 않는 형태의 페이징 처리를 지원하고 있습니다.\n123456789class OrderCustomRepositoryImpl : QuerydslRepositorySupport(Order::class.java), OrderCustomRepository &#123;    override fun findSliceBy(pageable: Pageable, address: String): Slice&lt;Order&gt; &#123;        val query: JPAQuery&lt;Order&gt; = from(order).select(order).where(order.address.eq(address))        val content: List&lt;Order&gt; = querydsl.applyPagination(pageable, query).fetch()        val hasNext: Boolean = content.size &gt;= pageable.pageSize        return SliceImpl(content, pageable, hasNext)    &#125;&#125;\nTotal Count가 필요 없기 때문에 생략 가능하며, 페이징 로직은 동일하게 applyPagination으로 진행하며 중요한 부분은 hasNext로 앞으로 더 읽을 데이터가 남아 있는지를 결정하는 변수입니다.\nOrder 데이터가 총 22개 있다고 가정하고 Page 0 ~ 4까지 Size 5개를 기준으로 조회한다고 가정해 보겠습니다.\n\n\n\nPage\nSize\nContent\nLast\n\n\n\n\n0\n5\n5\nF\n\n\n1\n5\n5\nF\n\n\n2\n5\n5\nF\n\n\n3\n5\n5\nF\n\n\n4\n5\n3\nT\n\n\n\nPage 3까지는 Content가 설정한 크기만큼 반환되어 Last가 False 상태입니다. 그러나 Page 4에서는 남은 Content가 3개만 남아 있기 때문에 3개의 Content를 반환하고 Last가 True 상태로 변경됩니다. 이 방식은 코드로 작성하면 content.size &gt;= pageable.pageSize로 표현됩니다.\n이 방식은 Total Count를 알 수 없기 때문에 Last 여부를 확인하기 위해서는 끝까지 데이터를 읽어봐야 정확히 판단할 수 있습니다. 반면에 Slice가 아닌 Page 방식에서는 Total Count를 알고 있어 다음 페이지를 읽지 않아도 Last 여부를 정확히 판단할 수 있습니다.\nOrder 데이터가 총 22개 있다고 가정하고 동일한 Size를 가지는 Page 방식과 Slice 방식을 비교해 보겠습니다.\n\n\n\n방식\nPage\nSize\nContent\nTotal Count\nLast\n\n\n\n\nPage 방식\n0\n22\n22\n22\nT\n\n\nSlice 방식\n0\n22\n22\n알 수 없음\nF\n\n\nSlice 방식\n0\n23\n22\n알 수 없음\nT\n\n\n\nPage 방식에서는 Total Count를 알고 있기 때문에 Content Size가 동일하다면 Last가 True로 판단할 수 있습니다. 반면에 Total Count을 모르는 Slice 방식에서는 다음 페이지까지 읽어보고 Content Size가 0인 것을 확인해야 Last가 True로 판단할 수 있습니다. Size를 23으로 조회하면 응답하는 Content는 22개로, 요청한 Size보다 Content가 작게 응답되므로 Last를 True로 판단할 수 있습니다.\n이로 인해 발생하는 성능적인 차이를 언급하는 것은 아니며, Page 방식과 Slice 방식 간의 구조적인 차이를 설명하기 위해 이를 언급한 것입니다.\nSlice 사용이 용이한 구간\n테이블 뷰 형식으로 페이징 처리를 할 때, Total Count가 반드시 필요하지 않은 경우에는 대부분 Slice 방식을 활용하는 것이 효율적입니다. 예를 들어, 최근 주문 정보를 기반으로 회원 등급을 업데이트하는 배치 기능을 개발한다고 가정해 보겠습니다. 이 경우에는 Count 쿼리를 사용할 필요가 없습니다. 단순히 필요한 데이터를 offset과 limit 방식으로 읽고 처리하기 때문에 Count 쿼리를 수행하지 않아도 됩니다. 더불어 Count 쿼리는 데이터양에 상관없이 일정 시간이 걸리는데, 데이터양이 많은 경우 Content 조회 쿼리보다 더 많은 시간이 소요됩니다. 그러므로 이 Count 쿼리를 계속 사용하는 것은 성능상의 부담을 가중시킬 수 있습니다.\nSpring Batch HTTP Page Item Reader처럼 대량의 데이터를 처리하는 배치 애플리케이션에 API를 제공할 때는 Slice 기반으로 제공하는 것이 성능적으로 이점이 있습니다.\nCount 쿼리의 최적화 하여 개선\nTotal Count가 반드시 필요한 경우에는 Slice 방식을 사용할 수 없으므로 Page 방식을 사용해야 합니다. 또한, 위에서 언급한 대로 여러 테이블을 조인해서 복잡한 데이터를 조회하는 경우에는 Count 쿼리를 별도로 구현하는 것이 성능적인 이점을 가져올 수 있습니다.\n이는 AbstractJPAQuery의 fetchCount()가 Deprecated된 이유 중 하나입니다. 조인이 많거나 복잡한 쿼리에서 fetchCount를 사용하면 성능 저하가 발생할 수 있기 때문에 다른 방식으로 count 쿼리를 실행하도록 권장하고 있습니다.\nCount 쿼리를 별도로 구현하면 다음과 같이 구현할 수 있습니다.\n123456789101112131415161718class OrderCustomRepositoryImpl : QuerydslRepositorySupport(Order::class.java), OrderCustomRepository &#123;    override fun findPagingBy(pageable: Pageable, address: String): Page&lt;Order&gt; &#123;        val content: List&lt;Order&gt; = from(order)            .select(order)            .innerJoin(user).on(order.userId.eq(user.id))            .leftJoin(coupon).on(order.couponId.eq(coupon.id))            .where(order.address.eq(address))            .run &#123;                querydsl.applyPagination(pageable, this).fetch()            &#125;        val totalCount: Long = from(order)            .select(order.count())            .where(order.address.eq(address))            .fetchFirst()        return PageImpl(content, pageable, totalCount)    &#125;&#125;\nPageImpl을 사용하여 Page 객체를 생성할 때, totalCount를 Content 쿼리와 별도로 구현하여 작성합니다. totalCount를 구할 때 SimpleExpression의 count()를 사용하여 질의합니다. 이러한 최종 쿼리를 살펴보겠습니다.\n12345678910111213141516171819-- Content 쿼리select order0_.id           as id1_4_,       order0_.created_at   as created_2_4_,       order0_.updated_at   as updated_3_4_,       order0_.address      as address4_4_,       order0_.coupon_id    as coupon_i5_4_,       order0_.order_number as order_nu6_4_,       order0_.user_id      as user_id7_4_from orders order0_         inner join user user1_ on (order0_.user_id = user1_.id)         left outer join coupon coupon2_ on (order0_.coupon_id = coupon2_.id)where order0_.address = ? limit ?, ?;-- Count 쿼리select count(order0_.id) as col_0_0_from orders order0_where order0_.address = ? limit ?;\nContent 쿼리는 Content에 필요한 정보를 여러 테이블의 조인을 통해 가져오며, Count 쿼리는 조회 조건에 필요한 정보만 가져옵니다. 이때 fetchCount()가 Deprecated 되었기 때문에 fetchFirst()로 대체합니다. 이렇게 Count 쿼리를 따로 구현하면 Count 조건에 맞는 방식으로 최적화하여 성능적인 이점을 얻을 수 있습니다.\nCount 쿼리와 Content 쿼리 병렬 처리하여 개선 방법\n\nCount 쿼리가 1,000ms가 소요되고, 이후 Content 쿼리가 500ms 소요된다고 가정하면 총 1,500ms가 소요됩니다. 이 작업을 전체 데이터를 읽을 때마다 반복하면 성능상 문제가 발생할 수 있습니다. 그러나 이 두 작업은 서로 의존성이 없기 때문에 병렬로 처리할 수 있습니다.\n\nCount 쿼리와 Content 쿼리를 병렬로 처리하면 Count 쿼리가 소요 시간이 더 길더라도 1,000ms에 작업을 완료할 수 있습니다. 병렬 처리를 코루틴을 활용하여 구현해 보겠습니다.\n코루틴을 이용한 Count 쿼리와 Content 쿼리 병렬 처리\n12345678910111213141516171819202122232425class OrderCustomRepositoryImpl : QuerydslRepositorySupport(Order::class.java), OrderCustomRepository &#123;    override fun findPagingBy(pageable: Pageable, address: String): Page&lt;Order&gt; = runBlocking &#123;        log.info(&quot;findPagingBy thread : $&#123;Thread.currentThread()&#125;&quot;)        val content: Deferred&lt;List&lt;Order&gt;&gt; = async &#123;            log.info(&quot;content thread : $&#123;Thread.currentThread()&#125;&quot;)            from(order)                .select(order)                .innerJoin(user).on(order.userId.eq(user.id))                .leftJoin(coupon).on(order.couponId.eq(coupon.id))                .where(order.address.eq(address))                .run &#123;                    querydsl.applyPagination(pageable, this).fetch()                &#125;        &#125;        val totalCount: Deferred&lt;Long&gt; = async &#123;            log.info(&quot;count thread : $&#123;Thread.currentThread()&#125;&quot;)            from(order)                .select(order.count())                .where(order.address.eq(address))                .fetchFirst()        &#125;        PageImpl(content.await(), pageable, totalCount.await())    &#125;&#125;\n코루틴의 async와 await를 활용하여 Content 쿼리와 Count 쿼리를 병렬로 처리하였습니다. 이 과정에서 스레드 정보를 확인하기 위해 Thread.currentThread()를 사용하여 현재 스레드 정보를 출력합니다.\n1234INFO [nio-8080-exec-1] repository.order.OrderApi  : thread api : Thread[http-nio-8080-exec-1,5,main]INFO [-1 @coroutine#1] OrderCustomRepositoryImpl  : findPagingBy thread : Thread[http-nio-8080-exec-1 @coroutine#1,5,main]INFO [-1 @coroutine#2] OrderCustomRepositoryImpl  : content thread : Thread[http-nio-8080-exec-1 @coroutine#2,5,main]INFO [-1 @coroutine#3] OrderCustomRepositoryImpl  : count thread : Thread[http-nio-8080-exec-1 @coroutine#3,5,main]\nOrderApi의 exec-1 요청 스레드를 기준으로 findPagingBy, content, count 스레드가 동일한 스레드를 사용하는 것을 확인할 수 있습니다. 이것은 @coroutine# 주석에서 볼 수 있듯이 한 스레드 내에서 여러 코루틴을 실행할 수 있는 구조를 의미합니다.\n\nVM Option에 -Dkotlinx.coroutines.debug을 추가하면 실행 중인 코루틴이 어떤 스레드에서 실행되는지를 확인할 수 있습니다.\n코루틴을 이용한 Count 쿼리와 Content 쿼리 병렬 처리 테스트\nCount 쿼리에는 delay(1_000)을 지정하여 1초 동안 대기하고, Content 쿼리에는 delay(500)을 지정하여 0.5초 동안 대기하며 테스트를 진행합니다.\n12345678910@Testfun `count 1,000ms, content 500ms delay test`() = runBlocking &#123;        val time = measureTimeMillis &#123;            orderRepository.findPagingBy(                pageable = PageRequest.of(0, 10),                address = &quot;address&quot;            )        &#125;        println(&quot;$&#123;time&#125;ms&quot;) // 1,037ms    &#125;\n소요 시간은 1,037ms으로 정상적으로 병렬 처리가 되는 것을 확인할 수 있습니다.\nSupport 객체를 통한 Querydsl 페이징 로직 개선\nSlice, Page 등과 같은 페이징 처리를 위한 중복 로직을 피하고 편리하게 사용하기 위해 해당 기능을 Support 객체에 관련 로직을 위임 시키겠습니다. Querydsl Repository Support 활용에서 소개한 QuerydslRepositorySupport를 기반으로 해당 기능을 한 번 더 감싸는 QuerydslCustomRepositorySupport 클래스에서 페이징 로직을 작성하겠습니다.\n1234567891011121314151617181920212223242526272829303132333435363738394041424344abstract class QuerydslCustomRepositorySupport(domainClass: Class&lt;*&gt;) : QuerydslRepositorySupport(domainClass) &#123;    protected var queryFactory: JPAQueryFactory by Delegates.notNull()    @PersistenceContext    override fun setEntityManager(entityManager: EntityManager) &#123;        super.setEntityManager(entityManager)        this.queryFactory = JPAQueryFactory(entityManager)    &#125;    protected fun &lt;T&gt; select(expr: Expression&lt;T&gt;): JPAQuery&lt;T&gt; &#123;        return queryFactory.select(expr)    &#125;    protected fun &lt;T&gt; selectFrom(from: EntityPath&lt;T&gt;): JPAQuery&lt;T&gt; &#123;        return queryFactory.selectFrom(from)    &#125;    protected fun from(path: EntityPath&lt;*&gt;): JPAQuery&lt;*&gt; &#123;        return queryFactory.from(path)    &#125;    protected fun &lt;T&gt; applyPagination(        pageable: Pageable,        contentQuery: Function&lt;JPAQueryFactory, JPAQuery&lt;T&gt;&gt;,        countQuery: Function&lt;JPAQueryFactory, JPAQuery&lt;Long&gt;&gt;    ): Page&lt;T&gt; = runBlocking &#123;        val jpaContentQuery = contentQuery.apply(queryFactory)        val content = async &#123; querydsl!!.applyPagination(pageable, jpaContentQuery).fetch() as List&lt;T&gt; &#125;        val count = async &#123; countQuery.apply(queryFactory).fetchFirst() &#125;        PageImpl(content.await(), pageable, count.await())    &#125;    protected fun &lt;T&gt; applySlicePagination(        pageable: Pageable,        query: Function&lt;JPAQueryFactory, JPAQuery&lt;T&gt;&gt;    ): Slice&lt;T&gt; &#123;        val jpaContentQuery = query.apply(queryFactory)        val content = querydsl!!.applyPagination(pageable, jpaContentQuery).fetch()        val hasNext = content.size &gt;= pageable.pageSize        return SliceImpl(content, pageable, hasNext)    &#125;&#125;\n\nqueryFactory에서 제공하는 selectFrom 및 select 기능도 제공하여 DSL 표현을 보다 다양하게 활용할 수 있도록 합니다.\napplyPagination 메서드는 페이징 처리를 위해 Pageable 객체와, Content 쿼리를 위한 contentQuery, Count 쿼리를 위한 countQuery 객체를 입력으로 받아서 코루틴을 활용하여 병렬 처리를 수행합니다.\napplySlicePagination 메서드는 Content 쿼리만을 수행하기 때문에 query 객체만을 입력으로 받고, content 조회와 hasNext 로직을 작성합니다.\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class OrderCustomRepositoryImpl : QuerydslCustomRepositorySupport(Order::class.java), OrderCustomRepository &#123;    // Slice 로직 AS-IS    override fun findSliceBy(        pageable: Pageable,        address: String    ): Slice&lt;Order&gt; &#123;        val query: JPAQuery&lt;Order&gt; = from(order).select(order).where(order.address.eq(address))        val content: List&lt;Order&gt; = querydsl!!.applyPagination(pageable, query).fetch()        val hasNext: Boolean = content.size &gt;= pageable.pageSize        return SliceImpl(content, pageable, hasNext)    &#125;    // Slice 로직 TO-BE    override fun findSliceBy(        pageable: Pageable,        address: String    ): Slice&lt;Order&gt; &#123;        return applySlicePagination(            pageable = pageable,            query = &#123;                selectFrom(order).where(order.address.eq(address))            &#125;        )    &#125;    // Page 로직 AS-IS    override fun findPagingBy(        pageable: Pageable,        address: String    ): Page&lt;Order&gt; = runBlocking &#123;        val content: Deferred&lt;List&lt;Order&gt;&gt; = async &#123;            from(order)                .select(order)                .innerJoin(user).on(order.userId.eq(user.id))                .leftJoin(coupon).on(order.couponId.eq(coupon.id))                .where(order.address.eq(address))                .run &#123;                    querydsl!!.applyPagination(pageable, this).fetch()                &#125;        &#125;        val totalCount: Deferred&lt;Long&gt; = async &#123;            from(order)                .select(order.count())                .where(order.address.eq(address))                .fetchFirst()        &#125;        PageImpl(content.await(), pageable, totalCount.await())    &#125;    // Page 로직 TO-BE    override fun findPaging(        pageable: Pageable,        address: String    ): Page&lt;Order&gt; &#123;        return applyPagination(            pageable = pageable,            contentQuery = &#123; selectFrom(order).where(order.userId.isNotNull) &#125;,            countQuery = &#123; select(order.count()).from(order).where(order.userId.isNotNull) &#125;,        )    &#125;&#125;\nQuerydslCustomRepositorySupport 객체를 상속받아 applyPagination과 applySlicePagination 로직을 작성합니다. 페이징 로직에 대한 처리는 모두 QuerydslCustomRepositorySupport로 위임되며, 각 Repository에서는 해당하는 쿼리만 작성하면 되는 구조로 코드가 훨씬 더 간결해졌습니다.\n","dateCreated":"2023-09-05T00:00:00+09:00","dateModified":"2025-01-31T20:24:39+09:00","datePublished":"2023-09-05T00:00:00+09:00","description":"일반적으로 어드민 페이지와 같이 데이터를 테이블 뷰 형식으로 제공할 때, 페이징 기법을 사용하여 현재 페이지의 내용과 페이지 정보를 표시합니다. JPA를 활용하면 이러한 반복적인 코드 작성을 보다 쉽게 처리할 수 있습니다.","headline":"JPA 페이징 Performance 향상 방법","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://cheese10yun.github.io/page-performance/"},"publisher":{"@type":"Organization","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg","logo":{"@type":"ImageObject","url":"yun-icon.jpg"}},"url":"https://cheese10yun.github.io/page-performance/","keywords":"JPA, Performance, Querydsl, Coroutines"}</script>
    <meta name="description" content="일반적으로 어드민 페이지와 같이 데이터를 테이블 뷰 형식으로 제공할 때, 페이징 기법을 사용하여 현재 페이지의 내용과 페이지 정보를 표시합니다. JPA를 활용하면 이러한 반복적인 코드 작성을 보다 쉽게 처리할 수 있습니다.">
<meta property="og:type" content="blog">
<meta property="og:title" content="JPA 페이징 Performance 향상 방법">
<meta property="og:url" content="https://cheese10yun.github.io/page-performance/index.html">
<meta property="og:site_name" content="Yun Blog">
<meta property="og:description" content="일반적으로 어드민 페이지와 같이 데이터를 테이블 뷰 형식으로 제공할 때, 페이징 기법을 사용하여 현재 페이지의 내용과 페이지 정보를 표시합니다. JPA를 활용하면 이러한 반복적인 코드 작성을 보다 쉽게 처리할 수 있습니다.">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/query-dsl/docs/images/001.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/query-dsl/docs/images/002.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/query-dsl/docs/images/003.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/query-dsl/docs/images/004.png">
<meta property="article:published_time" content="2023-09-04T15:00:00.000Z">
<meta property="article:modified_time" content="2025-01-31T11:24:39.782Z">
<meta property="article:author" content="Yun">
<meta property="article:tag" content="JPA">
<meta property="article:tag" content="Performance">
<meta property="article:tag" content="Querydsl">
<meta property="article:tag" content="Coroutines">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/query-dsl/docs/images/001.png">
    
    
        
    
    
        <meta property="og:image" content="https://cheese10yun.github.io/assets/images/yun-icon.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90907312-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-90907312-1');
    </script>


    

    
        
    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5813739623204880" crossorigin="anonymous"></script>
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="5">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Yun Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="링크 열기: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="5">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="저자에 대해 더 알아보기"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
                </a>
                <h4 class="sidebar-profile-name">Yun</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기술 블로그</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="카테고리"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">카테고리</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="태그"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="아카이브"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">아카이브</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="검색"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">검색</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/cheese10yun"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/rss2.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="5"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            JPA 페이징 Performance 향상 방법
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2023-09-05T00:00:00+09:00">
	
		    2023/09/05
    	
    </time>
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>일반적으로 어드민 페이지와 같이 데이터를 테이블 뷰 형식으로 제공할 때, 페이징 기법을 사용하여 현재 페이지의 내용과 페이지 정보를 표시합니다. JPA를 활용하면 이러한 반복적인 코드 작성을 보다 쉽게 처리할 수 있습니다.</p>
<p>데이터 모수가 적고 단순한 구조로 데이터를 보여주는 경우라면 JPA에서 제공해 주는 방식으로 처리하는 것이 효율적일 수 있으나 데이터 모수가 많고 여러 테이블을 조인해서 표현해야 하는 데이터 구조라면 성능적인 이슈가 발생할 수 있습니다. 이러한 이슈와 성능 개선 방법에 대해 알아보겠습니다.</p>
<h2 id="Querydsl-페이징-처리-방식">Querydsl 페이징 처리 방식</h2>
<p>데이터 모수가 적고 간단한 조회 구조를 가질 때, Querydsl의 applyPagination 메서드를 활용하면 페이징 로직을 더 쉽게 작성할 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrderCustomRepositoryImpl</span> : <span class="type">QuerydslRepositorySupport</span>(Order::<span class="keyword">class</span>.java), OrderCustomRepository &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findPagingBy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        address: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Page&lt;Order&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> query: JPAQuery&lt;Order&gt; = from(order).select(order).<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">        <span class="keyword">val</span> content: List&lt;Order&gt; = querydsl.applyPagination(pageable, query).fetch()</span><br><span class="line">        <span class="keyword">val</span> totalCount: <span class="built_in">Long</span> = query.fetchCount()</span><br><span class="line">        <span class="keyword">return</span> PageImpl(content, pageable, totalCount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cheese10yun.github.io/spring-jpa-best-15/">Spring-JPA Best Practices step-15 - Querydsl를 이용해서 Repository 확장하기 (1)</a>에서 공유드린 QuerydslRepositorySupport를 기반으로 JpaRepository 확장시켜 페이징 로직을 구현했습니다.</p>
<p>세부 구현체에서는 조회 로직을 살펴보겠습니다. 이 과정에서 Querydsl를 기반으로 JPAQuery를 생성하며 필요한 조회 조건을 작성합니다. 그런 다음 해당 쿼리 객체를 이용하여 Content 조회와 전체 레코드 수 조회를 수행합니다. 마지막으로 각각의 실제 쿼리를 확인하게 됩니다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> order0_.id           <span class="keyword">as</span> id1_4_,</span><br><span class="line">       ...</span><br><span class="line">       order0_.address      <span class="keyword">as</span> address4_4_,</span><br><span class="line">       order0_.created_at   <span class="keyword">as</span> created_2_4_,</span><br><span class="line">       order0_.updated_at   <span class="keyword">as</span> updated_3_4_,</span><br><span class="line"><span class="keyword">from</span> orders order0_</span><br><span class="line"><span class="keyword">where</span> order0_.address <span class="operator">=</span> ?</span><br><span class="line">limit ?, ?</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(order0_.id) <span class="keyword">as</span> col_0_0_</span><br><span class="line"><span class="keyword">from</span> orders order0_</span><br><span class="line"><span class="keyword">where</span> order0_.address <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure>
<p>Content 조회에 필요하 조회 쿼리와, 전체 레코드 조회에 필요한 쿼리를 JPAQuery를 통해 동일하게 사용이 가능하며, Querydsl의 applyPagination 메서드를 활용하여 offset 및 limit 관련 페이징 로직을 간단하게 구현할 수 있다는 큰 장점이 있습니다.</p>
<p>Querydsl의 applyPagination을 활용하면 페이징 조회 관련 로직을 간단하게 구현할 수 있어서 개발 생산성 측면에서 큰 이점이 있습니다. 그러나 모든 개발 결정 과정에서는 트레이드오프가 발생합니다. 편리한 기능을 즉시 활용할 수 있지만, 나중에는 추가 비용을 지불해야 하며 이 비용은 이자를 포함하여 청구될 수 있습니다.</p>
<p>어떤 문제가 발생하는지 살펴보겠습니다.</p>
<h3 id="Count-쿼리의-성능-문제">Count 쿼리의 성능 문제</h3>
<p>Count 쿼리는 특정 조건에 해당하는 전체 레코드 수를 조회하는 구조로, 데이터 총량이 증가하면 성능 저하가 발생할 수 있습니다. Content를 조회하는 limit 및 offset 쿼리는 빠르게 처리되는(offset 비교적 크지 않은 초반 구간) <strong>반면 Count 쿼리는 시간이 오래 걸려 병목 현상이 발생할 수 있습니다.</strong> 또한, 여러 테이블을 조인하여 데이터를 조회하는 경우에는 조회 조건이 복잡해져 정확한 인덱스를 타겟팅하기 어려운 이슈가 발생할 수 있습니다. <strong>이는 조회 조건에 부합하는 전체 레코드를 Count 하는 구조에서 필연적으로 발생할 수밖에 없는 문제입니다.</strong></p>
<h3 id="Count-쿼리의-최적화-문제">Count 쿼리의 최적화 문제</h3>
<p>이러한 문제 외에도 다른 문제가 있습니다. <strong>JPAQuery를 사용하여 Content 조회 쿼리와 레코드 Count 조회 쿼리를 동일하게 처리하면 성능적인 손해가 발생할 수 있습니다.</strong> 특히 여러 테이블을 조인하여 데이터를 조회하는 경우에 이 문제가 더 두드러집니다.</p>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/query-dsl/docs/images/001.png" alt=""></p>
<p>주문 조회 시에 사용자 및 쿠폰 정보와 함께 내려줘야 하는 경우, 조회 필터에 주문 정보만 있는 상황에서 Count 쿼리를 실행할 때, 다른 테이블의 조인 없이 주문에 대한 Count 쿼리를 작성하는 것이 효율적입니다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Content 조회 쿼리</span></span><br><span class="line"><span class="keyword">select</span> o.<span class="operator">*</span>,</span><br><span class="line">       u.<span class="operator">*</span>,</span><br><span class="line">       c.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> orders o</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">join</span> coupon c <span class="keyword">on</span> o.coupon_id <span class="operator">=</span> c.id</span><br><span class="line">         <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> o.user_id <span class="operator">=</span> u.id</span><br><span class="line"><span class="keyword">where</span> o.address <span class="operator">=</span> ? limit ?, ?</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Content 조회 쿼리를 그대로 사용하는 경우</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(o.id)</span><br><span class="line"><span class="keyword">from</span> orders o</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">join</span> coupon c <span class="keyword">on</span> o.coupon_id <span class="operator">=</span> c.id</span><br><span class="line">         <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> o.user_id <span class="operator">=</span> u.id</span><br><span class="line"><span class="keyword">where</span> o.address <span class="operator">=</span> ?</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Content 쿼리를 사용하지 않고 별도의 Count 조회 쿼리</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(o.id) ascount</span><br><span class="line"><span class="keyword">from</span> orders o</span><br><span class="line"><span class="keyword">where</span> o.address <span class="operator">=</span> ?</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p>주문 조회에서 address 필드만 조회 조건에 해당된다면, 사용자 및 쿠폰 테이블과의 조인은 필요하지 않습니다. 이 경우, Count 쿼리를 간단하게 주문 테이블만을 대상으로 작성하는 것이 효율적입니다. 조회 조건이 복잡해질 때, Count 쿼리를 별도로 작성하는 것은 성능적으로 장점을 가질 수 있습니다.</p>
<h2 id="Querydsl-페이징-성능-최적화-방법">Querydsl 페이징 성능 최적화 방법</h2>
<h3 id="Slice-기반으로-Count-쿼리를-사용하지-않는-방법">Slice 기반으로 Count 쿼리를 사용하지 않는 방법</h3>
<p>JPA Slice 방식은 Page 방식과는 다르게 Total Count를 조회하는 count 쿼리를 실행하지 않는 방식입니다. 따라서 Total Count를 조회하는데 드는 시간을 절약하여 성능적인 이점을 얻을 수 있습니다. 페이지네이션 된 데이터를 불러올 때, 전체 데이터의 총개수를 파악하지 않고도 일부 데이터를 가져올 수 있기 때문에, Total Count가 필요 없는 상황에서 사용하면 성능을 향상시킬 수 있습니다. Slice 방식은 특히 대용량 데이터의 페이징 처리에 유용합니다. 이렇게 Slice 방식은 Total Count를 구하지 않고도 효율적인 페이징 처리를 가능하게 합니다. Total Count가 꼭 필요한 데이터인지 비즈니스 적으로 확인해 보고 꼭 필요한 데이터가 아니라면 사용하지 않는 것을 권장 드립니다.</p>
<h4 id="Slice-페이징-처리-방법">Slice 페이징 처리 방법</h4>
<p>Spring Data에서는 Slice를 통해 Total Count를 조회하지 않는 형태의 페이징 처리를 지원하고 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrderCustomRepositoryImpl</span> : <span class="type">QuerydslRepositorySupport</span>(Order::<span class="keyword">class</span>.java), OrderCustomRepository &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findSliceBy</span><span class="params">(pageable: <span class="type">Pageable</span>, address: <span class="type">String</span>)</span></span>: Slice&lt;Order&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> query: JPAQuery&lt;Order&gt; = from(order).select(order).<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">        <span class="keyword">val</span> content: List&lt;Order&gt; = querydsl.applyPagination(pageable, query).fetch()</span><br><span class="line">        <span class="keyword">val</span> hasNext: <span class="built_in">Boolean</span> = content.size &gt;= pageable.pageSize</span><br><span class="line">        <span class="keyword">return</span> SliceImpl(content, pageable, hasNext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Total Count가 필요 없기 때문에 생략 가능하며, 페이징 로직은 동일하게 <code>applyPagination</code>으로 진행하며 중요한 부분은 <code>hasNext</code>로 앞으로 더 읽을 데이터가 남아 있는지를 결정하는 변수입니다.</p>
<p>Order 데이터가 총 22개 있다고 가정하고 Page 0 ~ 4까지 Size 5개를 기준으로 조회한다고 가정해 보겠습니다.</p>
<table>
<thead>
<tr>
<th>Page</th>
<th>Size</th>
<th>Content</th>
<th style="text-align:left">Last</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>5</td>
<td>5</td>
<td style="text-align:left">F</td>
</tr>
<tr>
<td>1</td>
<td>5</td>
<td>5</td>
<td style="text-align:left">F</td>
</tr>
<tr>
<td>2</td>
<td>5</td>
<td>5</td>
<td style="text-align:left">F</td>
</tr>
<tr>
<td>3</td>
<td>5</td>
<td>5</td>
<td style="text-align:left">F</td>
</tr>
<tr>
<td>4</td>
<td>5</td>
<td>3</td>
<td style="text-align:left">T</td>
</tr>
</tbody>
</table>
<p>Page 3까지는 Content가 설정한 크기만큼 반환되어 Last가 False 상태입니다. 그러나 Page 4에서는 남은 Content가 3개만 남아 있기 때문에 3개의 Content를 반환하고 Last가 True 상태로 변경됩니다. 이 방식은 코드로 작성하면 <code>content.size &gt;= pageable.pageSize</code>로 표현됩니다.</p>
<p>이 방식은 Total Count를 알 수 없기 때문에 Last 여부를 확인하기 위해서는 끝까지 데이터를 읽어봐야 정확히 판단할 수 있습니다. 반면에 Slice가 아닌 Page 방식에서는 Total Count를 알고 있어 다음 페이지를 읽지 않아도 Last 여부를 정확히 판단할 수 있습니다.</p>
<p>Order 데이터가 총 22개 있다고 가정하고 동일한 Size를 가지는 Page 방식과 Slice 방식을 비교해 보겠습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:left">방식</th>
<th>Page</th>
<th>Size</th>
<th>Content</th>
<th style="text-align:left">Total Count</th>
<th style="text-align:left">Last</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Page 방식</td>
<td>0</td>
<td>22</td>
<td>22</td>
<td style="text-align:left">22</td>
<td style="text-align:left">T</td>
</tr>
<tr>
<td style="text-align:left">Slice 방식</td>
<td>0</td>
<td>22</td>
<td>22</td>
<td style="text-align:left">알 수 없음</td>
<td style="text-align:left">F</td>
</tr>
<tr>
<td style="text-align:left">Slice 방식</td>
<td>0</td>
<td>23</td>
<td>22</td>
<td style="text-align:left">알 수 없음</td>
<td style="text-align:left">T</td>
</tr>
</tbody>
</table>
<p>Page 방식에서는 Total Count를 알고 있기 때문에 Content Size가 동일하다면 Last가 True로 판단할 수 있습니다. 반면에 Total Count을 모르는 Slice 방식에서는 다음 페이지까지 읽어보고 Content Size가 0인 것을 확인해야 Last가 True로 판단할 수 있습니다. Size를 23으로 조회하면 응답하는 Content는 22개로, 요청한 Size보다 Content가 작게 응답되므로 Last를 True로 판단할 수 있습니다.</p>
<p>이로 인해 발생하는 성능적인 차이를 언급하는 것은 아니며, Page 방식과 Slice 방식 간의 구조적인 차이를 설명하기 위해 이를 언급한 것입니다.</p>
<h4 id="Slice-사용이-용이한-구간">Slice 사용이 용이한 구간</h4>
<p>테이블 뷰 형식으로 페이징 처리를 할 때, Total Count가 반드시 필요하지 않은 경우에는 대부분 Slice 방식을 활용하는 것이 효율적입니다. 예를 들어, 최근 주문 정보를 기반으로 회원 등급을 업데이트하는 배치 기능을 개발한다고 가정해 보겠습니다. 이 경우에는 Count 쿼리를 사용할 필요가 없습니다. 단순히 필요한 데이터를 offset과 limit 방식으로 읽고 처리하기 때문에 Count 쿼리를 수행하지 않아도 됩니다. 더불어 Count 쿼리는 데이터양에 상관없이 일정 시간이 걸리는데, 데이터양이 많은 경우 Content 조회 쿼리보다 더 많은 시간이 소요됩니다. 그러므로 이 Count 쿼리를 계속 사용하는 것은 성능상의 부담을 가중시킬 수 있습니다.</p>
<p><a href="https://cheese10yun.github.io/spring-batch-http-page-item-reader/">Spring Batch HTTP Page Item Reader</a>처럼 대량의 데이터를 처리하는 배치 애플리케이션에 API를 제공할 때는 Slice 기반으로 제공하는 것이 성능적으로 이점이 있습니다.</p>
<h3 id="Count-쿼리의-최적화-하여-개선">Count 쿼리의 최적화 하여 개선</h3>
<p>Total Count가 반드시 필요한 경우에는 Slice 방식을 사용할 수 없으므로 Page 방식을 사용해야 합니다. 또한, 위에서 언급한 대로 여러 테이블을 조인해서 복잡한 데이터를 조회하는 경우에는 Count 쿼리를 별도로 구현하는 것이 성능적인 이점을 가져올 수 있습니다.</p>
<p><strong>이는 AbstractJPAQuery의 <code>fetchCount()</code>가 Deprecated된 이유 중 하나입니다.</strong> 조인이 많거나 복잡한 쿼리에서 fetchCount를 사용하면 성능 저하가 발생할 수 있기 때문에 다른 방식으로 count 쿼리를 실행하도록 권장하고 있습니다.</p>
<p>Count 쿼리를 별도로 구현하면 다음과 같이 구현할 수 있습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrderCustomRepositoryImpl</span> : <span class="type">QuerydslRepositorySupport</span>(Order::<span class="keyword">class</span>.java), OrderCustomRepository &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findPagingBy</span><span class="params">(pageable: <span class="type">Pageable</span>, address: <span class="type">String</span>)</span></span>: Page&lt;Order&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> content: List&lt;Order&gt; = from(order)</span><br><span class="line">            .select(order)</span><br><span class="line">            .innerJoin(user).on(order.userId.eq(user.id))</span><br><span class="line">            .leftJoin(coupon).on(order.couponId.eq(coupon.id))</span><br><span class="line">            .<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">            .run &#123;</span><br><span class="line">                querydsl.applyPagination(pageable, <span class="keyword">this</span>).fetch()</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">val</span> totalCount: <span class="built_in">Long</span> = from(order)</span><br><span class="line">            .select(order.count())</span><br><span class="line">            .<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">            .fetchFirst()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> PageImpl(content, pageable, totalCount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PageImpl을 사용하여 Page 객체를 생성할 때, totalCount를 Content 쿼리와 별도로 구현하여 작성합니다. totalCount를 구할 때 SimpleExpression의 <code>count()</code>를 사용하여 질의합니다. 이러한 최종 쿼리를 살펴보겠습니다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Content 쿼리</span></span><br><span class="line"><span class="keyword">select</span> order0_.id           <span class="keyword">as</span> id1_4_,</span><br><span class="line">       order0_.created_at   <span class="keyword">as</span> created_2_4_,</span><br><span class="line">       order0_.updated_at   <span class="keyword">as</span> updated_3_4_,</span><br><span class="line">       order0_.address      <span class="keyword">as</span> address4_4_,</span><br><span class="line">       order0_.coupon_id    <span class="keyword">as</span> coupon_i5_4_,</span><br><span class="line">       order0_.order_number <span class="keyword">as</span> order_nu6_4_,</span><br><span class="line">       order0_.user_id      <span class="keyword">as</span> user_id7_4_</span><br><span class="line"><span class="keyword">from</span> orders order0_</span><br><span class="line">         <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">user</span> user1_ <span class="keyword">on</span> (order0_.user_id <span class="operator">=</span> user1_.id)</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> coupon coupon2_ <span class="keyword">on</span> (order0_.coupon_id <span class="operator">=</span> coupon2_.id)</span><br><span class="line"><span class="keyword">where</span> order0_.address <span class="operator">=</span> ? limit ?, ?</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Count 쿼리</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(order0_.id) <span class="keyword">as</span> col_0_0_</span><br><span class="line"><span class="keyword">from</span> orders order0_</span><br><span class="line"><span class="keyword">where</span> order0_.address <span class="operator">=</span> ? limit ?</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p>Content 쿼리는 Content에 필요한 정보를 여러 테이블의 조인을 통해 가져오며, Count 쿼리는 조회 조건에 필요한 정보만 가져옵니다. 이때 <code>fetchCount()</code>가 Deprecated 되었기 때문에 <code>fetchFirst()</code>로 대체합니다. 이렇게 Count 쿼리를 따로 구현하면 Count 조건에 맞는 방식으로 최적화하여 성능적인 이점을 얻을 수 있습니다.</p>
<h3 id="Count-쿼리와-Content-쿼리-병렬-처리하여-개선-방법">Count 쿼리와 Content 쿼리 병렬 처리하여 개선 방법</h3>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/query-dsl/docs/images/002.png" alt=""></p>
<p>Count 쿼리가 1,000ms가 소요되고, 이후 Content 쿼리가 500ms 소요된다고 가정하면 총 1,500ms가 소요됩니다. 이 작업을 전체 데이터를 읽을 때마다 반복하면 성능상 문제가 발생할 수 있습니다. <strong>그러나 이 두 작업은 서로 의존성이 없기 때문에 병렬로 처리할 수 있습니다.</strong></p>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/query-dsl/docs/images/003.png" alt=""></p>
<p>Count 쿼리와 Content 쿼리를 병렬로 처리하면 Count 쿼리가 소요 시간이 더 길더라도 1,000ms에 작업을 완료할 수 있습니다. 병렬 처리를 코루틴을 활용하여 구현해 보겠습니다.</p>
<h4 id="코루틴을-이용한-Count-쿼리와-Content-쿼리-병렬-처리">코루틴을 이용한 Count 쿼리와 Content 쿼리 병렬 처리</h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrderCustomRepositoryImpl</span> : <span class="type">QuerydslRepositorySupport</span>(Order::<span class="keyword">class</span>.java), OrderCustomRepository &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findPagingBy</span><span class="params">(pageable: <span class="type">Pageable</span>, address: <span class="type">String</span>)</span></span>: Page&lt;Order&gt; = runBlocking &#123;</span><br><span class="line">        log.info(<span class="string">&quot;findPagingBy thread : <span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> content: Deferred&lt;List&lt;Order&gt;&gt; = async &#123;</span><br><span class="line">            log.info(<span class="string">&quot;content thread : <span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">            from(order)</span><br><span class="line">                .select(order)</span><br><span class="line">                .innerJoin(user).on(order.userId.eq(user.id))</span><br><span class="line">                .leftJoin(coupon).on(order.couponId.eq(coupon.id))</span><br><span class="line">                .<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">                .run &#123;</span><br><span class="line">                    querydsl.applyPagination(pageable, <span class="keyword">this</span>).fetch()</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> totalCount: Deferred&lt;<span class="built_in">Long</span>&gt; = async &#123;</span><br><span class="line">            log.info(<span class="string">&quot;count thread : <span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">            from(order)</span><br><span class="line">                .select(order.count())</span><br><span class="line">                .<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">                .fetchFirst()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PageImpl(content.await(), pageable, totalCount.await())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>코루틴의 <code>async</code>와 <code>await</code>를 활용하여 Content 쿼리와 Count 쿼리를 병렬로 처리하였습니다. 이 과정에서 스레드 정보를 확인하기 위해 <code>Thread.currentThread()</code>를 사용하여 현재 스레드 정보를 출력합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INFO [nio-8080-exec-1] repository.order.OrderApi  : thread api : Thread[http-nio-8080-exec-1,5,main]</span><br><span class="line">INFO [-1 @coroutine#1] OrderCustomRepositoryImpl  : findPagingBy thread : Thread[http-nio-8080-exec-1 @coroutine#1,5,main]</span><br><span class="line">INFO [-1 @coroutine#2] OrderCustomRepositoryImpl  : content thread : Thread[http-nio-8080-exec-1 @coroutine#2,5,main]</span><br><span class="line">INFO [-1 @coroutine#3] OrderCustomRepositoryImpl  : count thread : Thread[http-nio-8080-exec-1 @coroutine#3,5,main]</span><br></pre></td></tr></table></figure>
<p>OrderApi의 <code>exec-1</code> 요청 스레드를 기준으로 <code>findPagingBy</code>, <code>content</code>, <code>count</code> 스레드가 동일한 스레드를 사용하는 것을 확인할 수 있습니다. 이것은 <code>@coroutine#</code> 주석에서 볼 수 있듯이 한 스레드 내에서 여러 코루틴을 실행할 수 있는 구조를 의미합니다.</p>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/query-dsl/docs/images/004.png" alt=""></p>
<p>VM Option에 <code>-Dkotlinx.coroutines.debug</code>을 추가하면 실행 중인 코루틴이 어떤 스레드에서 실행되는지를 확인할 수 있습니다.</p>
<h4 id="코루틴을-이용한-Count-쿼리와-Content-쿼리-병렬-처리-테스트">코루틴을 이용한 Count 쿼리와 Content 쿼리 병렬 처리 테스트</h4>
<p>Count 쿼리에는 <code>delay(1_000)</code>을 지정하여 1초 동안 대기하고, Content 쿼리에는 <code>delay(500)</code>을 지정하여 0.5초 동안 대기하며 테스트를 진행합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `count 1,000ms, content 500ms delay test`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">            orderRepository.findPagingBy(</span><br><span class="line">                pageable = PageRequest.of(<span class="number">0</span>, <span class="number">10</span>),</span><br><span class="line">                address = <span class="string">&quot;address&quot;</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;time&#125;</span>ms&quot;</span>) <span class="comment">// 1,037ms</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>소요 시간은 1,037ms으로 정상적으로 병렬 처리가 되는 것을 확인할 수 있습니다.</p>
<h2 id="Support-객체를-통한-Querydsl-페이징-로직-개선">Support 객체를 통한 Querydsl 페이징 로직 개선</h2>
<p>Slice, Page 등과 같은 페이징 처리를 위한 중복 로직을 피하고 편리하게 사용하기 위해 해당 기능을 Support 객체에 관련 로직을 위임 시키겠습니다. <a href="https://cheese10yun.github.io/querydsl-support/">Querydsl Repository Support 활용</a>에서 소개한 QuerydslRepositorySupport를 기반으로 해당 기능을 한 번 더 감싸는 QuerydslCustomRepositorySupport 클래스에서 페이징 로직을 작성하겠습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">QuerydslCustomRepositorySupport</span>(domainClass: Class&lt;*&gt;) : QuerydslRepositorySupport(domainClass) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> queryFactory: JPAQueryFactory <span class="keyword">by</span> Delegates.notNull()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PersistenceContext</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setEntityManager</span><span class="params">(entityManager: <span class="type">EntityManager</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setEntityManager(entityManager)</span><br><span class="line">        <span class="keyword">this</span>.queryFactory = JPAQueryFactory(entityManager)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">select</span><span class="params">(expr: <span class="type">Expression</span>&lt;<span class="type">T</span>&gt;)</span></span>: JPAQuery&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> queryFactory.select(expr)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">selectFrom</span><span class="params">(from: <span class="type">EntityPath</span>&lt;<span class="type">T</span>&gt;)</span></span>: JPAQuery&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> queryFactory.selectFrom(from)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">from</span><span class="params">(path: <span class="type">EntityPath</span>&lt;*&gt;)</span></span>: JPAQuery&lt;*&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> queryFactory.from(path)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">applyPagination</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        contentQuery: <span class="type">Function</span>&lt;<span class="type">JPAQueryFactory</span>, JPAQuery&lt;T&gt;&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        countQuery: <span class="type">Function</span>&lt;<span class="type">JPAQueryFactory</span>, JPAQuery&lt;<span class="built_in">Long</span>&gt;&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Page&lt;T&gt; = runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> jpaContentQuery = contentQuery.apply(queryFactory)</span><br><span class="line">        <span class="keyword">val</span> content = async &#123; querydsl!!.applyPagination(pageable, jpaContentQuery).fetch() <span class="keyword">as</span> List&lt;T&gt; &#125;</span><br><span class="line">        <span class="keyword">val</span> count = async &#123; countQuery.apply(queryFactory).fetchFirst() &#125;</span><br><span class="line"></span><br><span class="line">        PageImpl(content.await(), pageable, count.await())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">applySlicePagination</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        query: <span class="type">Function</span>&lt;<span class="type">JPAQueryFactory</span>, JPAQuery&lt;T&gt;&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Slice&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> jpaContentQuery = query.apply(queryFactory)</span><br><span class="line">        <span class="keyword">val</span> content = querydsl!!.applyPagination(pageable, jpaContentQuery).fetch()</span><br><span class="line">        <span class="keyword">val</span> hasNext = content.size &gt;= pageable.pageSize</span><br><span class="line">        <span class="keyword">return</span> SliceImpl(content, pageable, hasNext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>queryFactory</code>에서 제공하는 <code>selectFrom</code> 및 <code>select</code> 기능도 제공하여 DSL 표현을 보다 다양하게 활용할 수 있도록 합니다.</li>
<li><code>applyPagination</code> 메서드는 페이징 처리를 위해 <code>Pageable</code> 객체와, Content 쿼리를 위한 <code>contentQuery</code>, Count 쿼리를 위한 <code>countQuery</code> 객체를 입력으로 받아서 코루틴을 활용하여 병렬 처리를 수행합니다.</li>
<li><code>applySlicePagination</code> 메서드는 Content 쿼리만을 수행하기 때문에 <code>query</code> 객체만을 입력으로 받고, content 조회와 <code>hasNext</code> 로직을 작성합니다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderCustomRepositoryImpl</span> : <span class="type">QuerydslCustomRepositorySupport</span>(Order::<span class="keyword">class</span>.java), OrderCustomRepository &#123;</span><br><span class="line">    <span class="comment">// Slice 로직 AS-IS</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findSliceBy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        address: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Slice&lt;Order&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> query: JPAQuery&lt;Order&gt; = from(order).select(order).<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">        <span class="keyword">val</span> content: List&lt;Order&gt; = querydsl!!.applyPagination(pageable, query).fetch()</span><br><span class="line">        <span class="keyword">val</span> hasNext: <span class="built_in">Boolean</span> = content.size &gt;= pageable.pageSize</span><br><span class="line">        <span class="keyword">return</span> SliceImpl(content, pageable, hasNext)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Slice 로직 TO-BE</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findSliceBy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        address: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Slice&lt;Order&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> applySlicePagination(</span><br><span class="line">            pageable = pageable,</span><br><span class="line">            query = &#123;</span><br><span class="line">                selectFrom(order).<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Page 로직 AS-IS</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findPagingBy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        address: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Page&lt;Order&gt; = runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> content: Deferred&lt;List&lt;Order&gt;&gt; = async &#123;</span><br><span class="line">            from(order)</span><br><span class="line">                .select(order)</span><br><span class="line">                .innerJoin(user).on(order.userId.eq(user.id))</span><br><span class="line">                .leftJoin(coupon).on(order.couponId.eq(coupon.id))</span><br><span class="line">                .<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">                .run &#123;</span><br><span class="line">                    querydsl!!.applyPagination(pageable, <span class="keyword">this</span>).fetch()</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> totalCount: Deferred&lt;<span class="built_in">Long</span>&gt; = async &#123;</span><br><span class="line">            from(order)</span><br><span class="line">                .select(order.count())</span><br><span class="line">                .<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">                .fetchFirst()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PageImpl(content.await(), pageable, totalCount.await())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Page 로직 TO-BE</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findPaging</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        address: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Page&lt;Order&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> applyPagination(</span><br><span class="line">            pageable = pageable,</span><br><span class="line">            contentQuery = &#123; selectFrom(order).<span class="keyword">where</span>(order.userId.isNotNull) &#125;,</span><br><span class="line">            countQuery = &#123; select(order.count()).from(order).<span class="keyword">where</span>(order.userId.isNotNull) &#125;,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>QuerydslCustomRepositorySupport</code> 객체를 상속받아 <code>applyPagination</code>과 <code>applySlicePagination</code> 로직을 작성합니다. 페이징 로직에 대한 처리는 모두 <code>QuerydslCustomRepositorySupport</code>로 위임되며, 각 Repository에서는 해당하는 쿼리만 작성하면 되는 구조로 코드가 훨씬 더 간결해졌습니다.</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">태그</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/Coroutines/" rel="tag">Coroutines</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/JPA/" rel="tag">JPA</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/Performance/" rel="tag">Performance</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/Querydsl/" rel="tag">Querydsl</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/spring-data-mongo-repository/"
                    data-tooltip="Spring Data MongoDB Repository 확장"
                    aria-label="이전: Spring Data MongoDB Repository 확장"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/exposed-3/"
                    data-tooltip="Kotlin 기반 경량 ORM Exposed 추가 정리 part 3"
                    aria-label="다음: Kotlin 기반 경량 ORM Exposed 추가 정리 part 3"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/page-performance/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/page-performance/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cheese10yun.github.io/page-performance/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>


<!-- Comment -->
<!--  utteranc comment -->

<script src="https://utteranc.es/client.js"
        repo="cheese10yun/blog-comment"
        issue-term="title"
        label="Comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Yun. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/spring-data-mongo-repository/"
                    data-tooltip="Spring Data MongoDB Repository 확장"
                    aria-label="이전: Spring Data MongoDB Repository 확장"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/exposed-3/"
                    data-tooltip="Kotlin 기반 경량 ORM Exposed 추가 정리 part 3"
                    aria-label="다음: Kotlin 기반 경량 ORM Exposed 추가 정리 part 3"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/page-performance/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/page-performance/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cheese10yun.github.io/page-performance/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="5">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/page-performance/"
                        aria-label="Facebook에 공유하기"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Facebook에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/page-performance/"
                        aria-label="Twitter에 공유하기"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Twitter에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://cheese10yun.github.io/page-performance/"
                        aria-label="Google+에 공유하기"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Google+에 공유하기</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
            <h4 id="about-card-name">Yun</h4>
        
            <div id="about-card-bio"><p>기술 블로그</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
