
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="naver-site-verification" content="a37ea649edf26e70c3de94f9cb034f9d6e11de3f" />
    <meta name="generator" content="Yun Blog">
    <title>Spring Batch 업데이트 성능 최적화 및 분석 - Yun Blog</title>
    <meta name="author" content="Yun">
    
        <meta name="keywords" content="Node,Spring,Spring Boot,Spring Batch,Kotlin,기술 블로그,JPA,Mongo,MySQL,OOP,">
    
    
    
        
            <link rel="alternate" type="application/rss+xml" title="RSS" href="/rss2.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg"},"articleBody":"아래와 같은 시나리오의 경우 배치 애플리케이션 성능을 높이기 위한 방법에 대한 내용을 정리했습니다.\n시나리오해당 배치 애플리케이션은 등록되어 있는 가맹점(Store)에 대한 상태를 외부 API를 단건으로 조회하여(단건 API만 존재) 가맹점 상태를 OPEN(&quot;오픈&quot;),, CLOSE(&quot;폐업&quot;), 업데이트하는 애플리케이션입니다.\n\n\nReader에서 Store(Item)을 ChunkSize 만큼 읽어 옵니다.\n읽어온 Store(Item)을 한 건씩 Processor에서 외부 API를 호출하여 최신 가맹점 상태를 응답받아 가공 처리합니다.\n가공된 데이터를 Chunk 단위만큼 쌓이면 Writer에 전달하고 Writer는 업데이트 작업을 진행합니다.\n\n위와 같은 Step의 Job이 있는 경우 단일 스레드 기반의 가장 직관적인 JpaWriter 방법, RxKotlin을 이용한 멀티 스레드 방식의 RxWriter, 마지막으로 RxKotlin과 BulkUpdate를 진행하는 RxAndBulkWriter 방식에 대한 Step 코드 샘플과, 실제 성능 측정 정리 하였습니다.\nBatch CodeEntity &amp; 외부 API12345678910111213141516171819202122232425262728293031323334353637383940@Entity@Table(    name = &quot;store&quot;,    indexes = [        Index(columnList = &quot;created_at&quot;, name = &quot;idx_created_at&quot;)    ])class Store(    @Enumerated(EnumType.STRING)    @Column(name = &quot;status&quot;, nullable = false)    var status: StoreStatus = StoreStatus.EXAMINATION) &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    var id: Long? = null        internal set    @CreationTimestamp    @Column(name = &quot;created_at&quot;, nullable = false, updatable = false)    lateinit var createdAt: LocalDateTime        internal set    @UpdateTimestamp    @Column(name = &quot;updated_at&quot;, nullable = false)    lateinit var updatedAt: LocalDateTime        internal set    override fun toString(): String &#123;        return &quot;Store(status=$status, id=$id)&quot;    &#125;&#125;enum class StoreStatus(    val description: String) &#123;    OPEN(&quot;오픈&quot;),    CLOSE(&quot;폐업&quot;),    EXAMINATION(&quot;검토중&quot;)&#125;\n\n초기 데이터는 모두 EXAMINATION(&quot;검토중&quot;)으로 들어갑니다.\n1234567891011121314@Serviceclass LatestStoreStatusObtainer &#123;    /**     * 외부 통신을 통해서 최신 가맹점의 상태를 가져온다. 150 ms가 걸린다고 가정한다.     * @return 해당 조건으로 [StoreStatus.CLOSE] or StoreStatus.OPEN 응답 한다.     */    fun getLatestStoreStatus(storeId: Long): StoreStatus &#123;        runBlocking &#123; delay(150) &#125;        return when &#123;            storeId % 2 == 0L -&gt; StoreStatus.CLOSE            else -&gt; StoreStatus.OPEN        &#125;    &#125;&#125;\n\n이 외부 API는 평균 응답 속도는 150ms라고 가정하고 하고 성능 측정 시에는 150ms으로 고정하고 진행하겠습니다.\nReader1234567891011121314151617@Configurationclass UpdatePerformanceJobConfiguration(    ...    ...) &#123;    @Bean    @StepScope    fun updatePerformanceReader(        entityManagerFactory: EntityManagerFactory    ) = JpaCursorItemReaderBuilder&lt;StoreProjection&gt;()        .name(&quot;updatePerformanceReader&quot;)        .entityManagerFactory(entityManagerFactory)        .queryString(&quot;SELECT NEW com.batch.payment.domain.store.StoreProjection(s.id, s.status) FROM Store s where s.createdAt &gt;= :createdAt ORDER BY s.id DESC&quot;)        .parameterValues(mapOf(&quot;createdAt&quot; to localDateTime))        .build()&#125;\n\nJpaCursorItemReader 기반으로 성능 측정에서 모드 동일한 리더를 사용했습니다. JPA를 사용한다면 배치 애플리케이션에는 대량 처리 시 Entity 객체를 리턴하는 것이 아니라 Projections 객체를 리턴하는 것을 권장합니다. JPA에서 지원해 주는 Dirty Checking 기반으로 업데이트를 진행할 이는 거의 없으며, 있더라도 merger 기능이 동작할 때 select 쿼리가 한 번 더 발생할 위험도 있으며 Lazy Loading으로 추가 조회를 하는 경우도 거의 없습니다. 무엇보다도 처리할 데이터 rows가 많고 해당 테이블에 칼럼이 맞은 경우 JPA에서 이전에 언급한 기능들 및 다른 기타 기능들을 사용하기 위해서 더 많은 메모리를 사용하게 되기 때문에 성능적인 측면에 유의미한 차이가 있어 가능하면 Projections 객체를 리턴하는 것이 좋습니다.\nCursorItemReader와 Reader에 대한 성능 분석은 Spring Batch Reader 성능 분석 및 측정 part 1, Spring Batch Reader 성능 분석 및 측정 part 2를 참고해 주세요. 본 포스팅에서는 Reader에 대해서는 깊게 다루지 않겠습니다.\n단건 처리 Processor, Writer123456789101112131415161718192021222324252627282930313233@Configurationclass UpdatePerformanceJobConfiguration(    ...    ...) &#123;    private fun processor(): ItemProcessor&lt;StoreProjection, StoreProjection&gt; &#123;        return ItemProcessor &#123;            // 사업자 최산 상태 조회 150ms 이후 응답            it.status = latestStoreStatusObtainer.getLatestStoreStatus(it.id)            it        &#125;    &#125;    private fun jpaWriter(): ItemWriter&lt;StoreProjection&gt; &#123;        return ItemWriter &#123; stores -&gt;            for (store in stores) &#123;                storeRepository.updateStatus(store.id, store.status)            &#125;        &#125;    &#125;&#125;class StoreCustomRepositoryImpl :    StoreCustomRepository,    QuerydslRepositorySupport(Store::class.java) &#123;    // Query DSL 기반 업데이트     override fun updateStatus(id: Long, status: StoreStatus) =        update(qStore)            .set(qStore.status, status)            .where(qStore.id.eq(id))            .execute()&#125;\n\n가장 일반적이고 직관적인 배치 흐름입니다. Processor에서 단건 조회 API를 조회하여 데이터를 가공하고 Writer에서 Query DSL 기반으로 업데이트를 진행합니다. 이렇게 처리하면 total rows * 150ms만큼 소요 시 간이 발생하게 되기 때문에 데이터 모수에 큰 영향을 받습니다.\nRx 기반 멀티 스레드 Writer 처리total rows * 150ms만큼 소요되기 때문에 처리할 수 있는 스레드 수만큼 작업 시간이 줄어들며 이론 상 rows 1,000 * 150ms &#x2F; 10 Thread(Parallel(10)) 만큼 처리 시간을 단축시킬 수 있습니다. 해당 포스팅은 RxKotlin 기반으로 스레드 처리를 진행합니다.\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Configurationclass UpdatePerformanceJobConfiguration(    ...    ...) &#123;    private fun rxWriter(): ItemWriter&lt;StoreProjection&gt; &#123;        return ItemWriter &#123; stores -&gt;            stores                .toFlowable()                .parallel() // (1)                .runOn(Schedulers.io()) // (2)                .map &#123; store -&gt;                    // 속도 특정 시에는 주석                    log.info(&quot;Mapping Thread: $&#123;Thread.currentThread().name&#125;, store: $store&quot;)                    // 사업자 최산 상태 조회 150ms 이후 응답                    Pair(store, latestStoreStatusObtainer.getLatestStoreStatus(store.id))                &#125;                .sequential() // (3)                .blockingSubscribe( // (4)                    &#123; store -&gt;                        // 속도 특정 시에는 주석                        log.info(&quot;Received Thread: $&#123;Thread.currentThread().name&#125;&quot;)                        val second = store.second                        store.first.status = second                    &#125;,                    &#123;                        log.error(it.message, it)                    &#125;,                    &#123;                        // (5)                        for (store in stores) &#123;                            storeRepository.updateStatus(                                id = store.id,                                status = store.status                            )                        &#125;                    &#125;                )        &#125;    &#125;&#125;class StoreCustomRepositoryImpl :    StoreCustomRepository,    QuerydslRepositorySupport(Store::class.java) &#123;    override fun updateStatus(id: Long, status: StoreStatus) =        update(qStore)            .set(qStore.status, status)            .where(qStore.id.eq(id))            .execute()&#125;\n\n\n(1): stores를 병렬화하여 위 이미지처럼 레일을 만들며 레일에게 발송할 수 있게 합니다.\n(2): Schedulers.io()를 통해서 ParallelFlowable의 병렬 처리 수준만큼 Scheduler.createWorker를 호출해서 스레드를 생성합니다.\n(3): sequential를 통해서 parallel에서 여러 레일을 생성하는 것을 다시 단일 시퀀스로 병합합니다.\n(4): 해당 레일이 정상 종료, 오류가 발생하기 전까지 Blocking 합니다.\n(5): 단일 시퀀스로 병합이 완료되고 Query DSL 기반으로 업데이트를 진행합니다.\n\nWriter에서 넘겨받은 stores 객체를 병렬 처리하기 때문에 더 이상 Proccsor가 필요하지 않습니다. 배치 애플리케이션에서 Proccsor에서 데이터 가공 처리하는 것은 역할 책임의 분리로는 적절하나 I&#x2F;O 작업처럼 상대적으로 느린 작업이 있으면 Proccsor에서 처리하지 않고 가능하면 Writer에서 벌크(병렬) 처리하는 것이 성능적으로 큰 이점이 있습니다.\n\nRxCachedThreadScheduler-1~10으로 10개의 스레드로 데이터를 사업자 최산 상태 조회를 하고 있으며 이후 blockingSubscribe의 onNext는 메인 스레드로 다시 전달받는 것을 확인할 수 있습니다. runOn()에 각자 환경에 맞는 Schedulers를 적절하게 사용하면 되며 모든 테스트는 10개의 스케줄러 스레드 기반으로 테스트를 진행했습니다.\nRx 기반 멀티 스레드 &amp; Bulk Update Writer 처리123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Configurationclass UpdatePerformanceJobConfiguration(    ...    ...) &#123;    private fun rxAndBulkWriter(): ItemWriter&lt;StoreProjection&gt; &#123;        return ItemWriter &#123; stores -&gt;            stores                .toFlowable()                .parallel()                .runOn(Schedulers.io())                .map &#123; store -&gt;                    // 속도 특정 시에는 주석                    log.info(&quot;Mapping Thread: $&#123;Thread.currentThread().name&#125;, store: $store&quot;)                    // 사업자 최산 상태 조회 150ms 이후 응답                    Pair(store, latestStoreStatusObtainer.getLatestStoreStatus(store.id))                &#125;                .sequential()                .blockingSubscribe(                    &#123; store -&gt;                        // 속도 특정 시에는 주석                        log.info(&quot;Received Thread: $&#123;Thread.currentThread().name&#125;&quot;)                        val second = store.second                        store.first.status = second                    &#125;,                    &#123;                        log.error(it.message, it)                    &#125;,                    &#123;                        // 속도 특정 시에는 주석                        log.info(&quot;onComplete Thread: $&#123;Thread.currentThread().name&#125;&quot;)                        // (1)                        val groups = stores.groupBy(&#123; it.status &#125;, &#123; it.id &#125;)                        // (2)                        val closeIds = groups[StoreStatus.CLOSE] ?: emptyList()                        val openIds = groups[StoreStatus.OPEN] ?: emptyList()                        // (3)                        if (closeIds.isNotEmpty()) &#123;                            storeRepository.updateStatus(ids = closeIds, status = StoreStatus.CLOSE)                        &#125;                        if (openIds.isNotEmpty()) &#123;                            storeRepository.updateStatus(ids = openIds, status = StoreStatus.OPEN)                        &#125;                    &#125;                )        &#125;    &#125;&#125;class StoreCustomRepositoryImpl :    StoreCustomRepository,    QuerydslRepositorySupport(Store::class.java) &#123;    // (4)    override fun updateStatus(ids: List&lt;Long&gt;, status: StoreStatus) =        update(qStore)            .set(qStore.status, status)            .where(qStore.id.`in`(ids))            .execute()&#125;\n\n\n(1): 단일 시퀀스로 병합된 stores를 StoreStatus 값으로 그룹화 진행\n(2): OPEN(&quot;오픈&quot;),, CLOSE(&quot;폐업&quot;), 기반으로 ids 객체 생성\n(3): ids 객체 기반으로 업데이트 진행\n(4): Query DSL where id in 기반으로 일괄 업데이트, 디비 서버와 네트워크 I&#x2F;O 최소화\n\n\nonComplete으로 최종 결과를 main Thread로 받는 것을 확인했습니다.\n\n이전 Rx과 거의 동일하며 Query DSL 업데이트 처리하는 방식만 달라졌습니다. Chunk 단위로 데이터를 모아서 가맹점 상태를 기준으로 그룹화를 진행하며, 그룹화를 통해서 ids 통해서 DB 업데이트를 진행합니다. Chunk 단위로는 DB 서버와 최대 2번의 통신을 하기 때문에 기존 방식 대비 네트워크 I&#x2F;O가 크게 줄어들게 됩니다. 모든 테스트는 로컬 DB 서버와 통신을 했기 때문에 JpaWriter, RxWriter 방식에서 네트워크 I&#x2F;O에 비용이 크게 발생하지 않았지만 실제 운영 환경에서는 네트워크 I&#x2F;O 비용이 커짐에 따라 더 안 좋은 성능을 보여주게 되며, RxAndBulkWriter와의 차이는 더 발생할 것으로 보입니다.\n12345678910#실제 SQL log, where id in 절로 업데이트 진행Time                 Id Command    Argument2022-11-12T05:33:58.608788Z\t 4242 Queryupdate storeset status=&#x27;CLOSE&#x27;where id in (600, 598, 596, 594, 592, 590, 588, 586, 584, 582, 580, 578, 576, 574, 572, 570, 568, 566, 564, 562, 560, 558, 556, 554, 552, 550, 548, 546, 544, 542, 540, 538, 536, 534, 532, 530, 528, 526, 524, 522, 520, 518, 516, 514, 512, 510, 508, 506, 504, 502) 2022-11-12T05:33:58.614597Z\t 4242 Queryupdate storeset status=&#x27;OPEN&#x27;where id in (599, 597, 595, 593, 591, 589, 587, 585, 583, 581, 579, 577, 575, 573, 571, 569, 567, 565, 563, 561, 559, 557, 555, 553, 551, 549, 547, 545, 543, 541, 539, 537, 535, 533, 531, 529, 527, 525, 523, 521, 519, 517, 515, 513, 511, 509, 507, 505, 503, 501)\n\nPerformance 측정 및 분석\n\n\n\nRows\nChunkSize\nJpaWriter\nRxWriter\nRxAndBulkWriter\n\n\n\n50\n10\n8,252 ms\n1,406 ms\n1,258 ms\n\n\n100\n20\n16,207 ms\n2,357 ms\n2,078 ms\n\n\n500\n100\n78,738 ms\n9,106 ms\n8,268 ms\n\n\n1,000\n200\n156,420 ms\n17,751 ms\n1,6001 ms\n\n\n5,000\n1,000\n776,786 ms(12 min)\n83,670 ms(1.3 min)\n77,732 ms(1.2 min)\n\n\n10,000\n1,000\n1,556,775 ms(25 min)\n169,473 ms(2.8 min)\n155,777 ms(2.5 min)\n\n\n50,000\n1,000\n7,781,424 ms(129 min)\n881,320 ms(14 min)\n774,789 ms(12 min)\n\n\n100,000\n1,000\n15,622,542 ms(260 min)\n1,699,994 ms(28 min)\n1,581,545 ms(26 min)\n\n\nJpaWriter는 단일 스레드, RxWriter는 10 스레드로 진행하여 대략적인 수치는 스레드 차이만큼의 결과를 보여주는 것을 확인할 수 있습니다. RxWriter와 RxAndBulkWriter의 차이는 대략 10% 정도 차이가 있습니다. 이 차이는 배치 애플리케이션과 DB 서버가 로컬에 있어 루프백으로 통신을 진행하여 차이가 크게 발생하지 않았으나 실제 환경에서는 더 유의미한 차이가 있을 것으로 보입니다. 네트워크 I&#x2F;O 비용뿐만 아니라 트랜잭션을 점유하는 시간, 커넥션을 맺고 있는 시간 등등 그룹화하여 where in 절로 처리가 가능하다면 이렇게 처리하는 것이 훨씬 더 효율적이라고 판단됩니다.\n또 RxAndBulkWriter 경우 where in으로 처리하기 때문에 ChunkSize를 늘리면 더 성능이 좋을 것으로 생각했지만 5,000 보다 1,000 Chunk가 더 좋은 성능이 좋았습니다. 아마 Rx에서 스레드를 알맞게 나누고 그것을 다시 병합하는 과정의 비용이 비싸기 때문이라고 추정됩니다. 대량 처리를 진행하는 경우는 각 환경에 맞는 ChunkSize를 측정하여 사용하는 것이 바람직해 보입니다.\n","dateCreated":"2022-11-12T23:41:19+09:00","dateModified":"2025-01-31T04:41:33+09:00","datePublished":"2022-11-12T23:41:19+09:00","description":"아래와 같은 시나리오의 경우 배치 애플리케이션 성능을 높이기 위한 방법에 대한 내용을 정리했습니다.","headline":"Spring Batch 업데이트 성능 최적화 및 분석","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://cheese10yun.github.io/spring-batch-update-performance/"},"publisher":{"@type":"Organization","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg","logo":{"@type":"ImageObject","url":"yun-icon.jpg"}},"url":"https://cheese10yun.github.io/spring-batch-update-performance/","keywords":"JPA, ORM, Performance, Spring Batch"}</script>
    <meta name="description" content="아래와 같은 시나리오의 경우 배치 애플리케이션 성능을 높이기 위한 방법에 대한 내용을 정리했습니다.">
<meta property="og:type" content="blog">
<meta property="og:title" content="Spring Batch 업데이트 성능 최적화 및 분석">
<meta property="og:url" content="https://cheese10yun.github.io/spring-batch-update-performance/index.html">
<meta property="og:site_name" content="Yun Blog">
<meta property="og:description" content="아래와 같은 시나리오의 경우 배치 애플리케이션 성능을 높이기 위한 방법에 대한 내용을 정리했습니다.">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/update-batch-1.png">
<meta property="og:image" content="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/parallelflowable.sequential.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/update-batch-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/update-batch-3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/update-batch-4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/update-batch-5.png">
<meta property="article:published_time" content="2022-11-12T14:41:19.000Z">
<meta property="article:modified_time" content="2025-01-30T19:41:33.792Z">
<meta property="article:author" content="Yun">
<meta property="article:tag" content="JPA">
<meta property="article:tag" content="ORM">
<meta property="article:tag" content="Performance">
<meta property="article:tag" content="Spring Batch">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/update-batch-1.png">
    
    
        
    
    
        <meta property="og:image" content="https://cheese10yun.github.io/assets/images/yun-icon.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90907312-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-90907312-1');
    </script>


    

    
        
    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5813739623204880" crossorigin="anonymous"></script>
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="5">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Yun Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="링크 열기: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="5">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="저자에 대해 더 알아보기"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
                </a>
                <h4 class="sidebar-profile-name">Yun</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기술 블로그</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="카테고리"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">카테고리</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="태그"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="아카이브"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">아카이브</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="검색"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">검색</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/cheese10yun"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/rss2.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="5"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Spring Batch 업데이트 성능 최적화 및 분석
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2022-11-12T23:41:19+09:00">
	
		    2022/11/12
    	
    </time>
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>아래와 같은 시나리오의 경우 배치 애플리케이션 성능을 높이기 위한 방법에 대한 내용을 정리했습니다.</p>
<h2 id="시나리오"><a href="#시나리오" class="headerlink" title="시나리오"></a>시나리오</h2><p>해당 배치 애플리케이션은 등록되어 있는 가맹점(Store)에 대한 상태를 외부 API를 단건으로 조회하여(단건 API만 존재) 가맹점 상태를 <code>OPEN(&quot;오픈&quot;),</code>, <code>CLOSE(&quot;폐업&quot;),</code> 업데이트하는 애플리케이션입니다.</p>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/update-batch-1.png"></p>
<ol>
<li>Reader에서 Store(Item)을 ChunkSize 만큼 읽어 옵니다.</li>
<li>읽어온 Store(Item)을 한 건씩 Processor에서 외부 API를 호출하여 최신 가맹점 상태를 응답받아 가공 처리합니다.</li>
<li>가공된 데이터를 Chunk 단위만큼 쌓이면 Writer에 전달하고 Writer는 업데이트 작업을 진행합니다.</li>
</ol>
<p>위와 같은 Step의 Job이 있는 경우 단일 스레드 기반의 가장 직관적인 JpaWriter 방법, RxKotlin을 이용한 멀티 스레드 방식의 RxWriter, 마지막으로 RxKotlin과 BulkUpdate를 진행하는 RxAndBulkWriter 방식에 대한 Step 코드 샘플과, 실제 성능 측정 정리 하였습니다.</p>
<h2 id="Batch-Code"><a href="#Batch-Code" class="headerlink" title="Batch Code"></a>Batch Code</h2><h3 id="Entity-외부-API"><a href="#Entity-외부-API" class="headerlink" title="Entity &amp; 외부 API"></a>Entity &amp; 외부 API</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(</span></span><br><span class="line"><span class="meta">    name = <span class="string">&quot;store&quot;</span>,</span></span><br><span class="line"><span class="meta">    indexes = [</span></span><br><span class="line"><span class="meta">        Index(columnList = <span class="string">&quot;created_at&quot;</span>, name = <span class="string">&quot;idx_created_at&quot;</span>)</span></span><br><span class="line"><span class="meta">    ]</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span>(</span><br><span class="line">    <span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line">    <span class="meta">@Column(name = <span class="string">&quot;status&quot;</span>, nullable = false)</span></span><br><span class="line">    <span class="keyword">var</span> status: StoreStatus = StoreStatus.EXAMINATION</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreationTimestamp</span></span><br><span class="line">    <span class="meta">@Column(name = <span class="string">&quot;created_at&quot;</span>, nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> createdAt: LocalDateTime</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@UpdateTimestamp</span></span><br><span class="line">    <span class="meta">@Column(name = <span class="string">&quot;updated_at&quot;</span>, nullable = false)</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> updatedAt: LocalDateTime</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Store(status=<span class="variable">$status</span>, id=<span class="variable">$id</span>)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">StoreStatus</span>(</span><br><span class="line">    <span class="keyword">val</span> description: String</span><br><span class="line">) &#123;</span><br><span class="line">    OPEN(<span class="string">&quot;오픈&quot;</span>),</span><br><span class="line">    CLOSE(<span class="string">&quot;폐업&quot;</span>),</span><br><span class="line">    EXAMINATION(<span class="string">&quot;검토중&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>초기 데이터는 모두 <code>EXAMINATION(&quot;검토중&quot;)</code>으로 들어갑니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LatestStoreStatusObtainer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 외부 통신을 통해서 최신 가맹점의 상태를 가져온다. 150 ms가 걸린다고 가정한다.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 해당 조건으로 [StoreStatus.CLOSE] or StoreStatus.OPEN 응답 한다.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getLatestStoreStatus</span><span class="params">(storeId: <span class="type">Long</span>)</span></span>: StoreStatus &#123;</span><br><span class="line">        runBlocking &#123; delay(<span class="number">150</span>) &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">            storeId % <span class="number">2</span> == <span class="number">0L</span> -&gt; StoreStatus.CLOSE</span><br><span class="line">            <span class="keyword">else</span> -&gt; StoreStatus.OPEN</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>이 외부 API는 평균 응답 속도는 <code>150ms</code>라고 가정하고 하고 성능 측정 시에는 <code>150ms</code>으로 고정하고 진행하겠습니다.</strong></p>
<h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UpdatePerformanceJobConfiguration</span>(</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@StepScope</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updatePerformanceReader</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        entityManagerFactory: <span class="type">EntityManagerFactory</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> = JpaCursorItemReaderBuilder&lt;StoreProjection&gt;()</span><br><span class="line">        .name(<span class="string">&quot;updatePerformanceReader&quot;</span>)</span><br><span class="line">        .entityManagerFactory(entityManagerFactory)</span><br><span class="line">        .queryString(<span class="string">&quot;SELECT NEW com.batch.payment.domain.store.StoreProjection(s.id, s.status) FROM Store s where s.createdAt &gt;= :createdAt ORDER BY s.id DESC&quot;</span>)</span><br><span class="line">        .parameterValues(mapOf(<span class="string">&quot;createdAt&quot;</span> to localDateTime))</span><br><span class="line">        .build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JpaCursorItemReader 기반으로 성능 측정에서 모드 동일한 리더를 사용했습니다. <strong>JPA를 사용한다면 배치 애플리케이션에는 대량 처리 시 Entity 객체를 리턴하는 것이 아니라 Projections 객체를 리턴하는 것을 권장합니다.</strong> JPA에서 지원해 주는 Dirty Checking 기반으로 업데이트를 진행할 이는 거의 없으며, 있더라도 merger 기능이 동작할 때 select 쿼리가 한 번 더 발생할 위험도 있으며 Lazy Loading으로 추가 조회를 하는 경우도 거의 없습니다. 무엇보다도 처리할 데이터 rows가 많고 해당 테이블에 칼럼이 맞은 경우 JPA에서 이전에 언급한 기능들 및 다른 기타 기능들을 사용하기 위해서 더 많은 메모리를 사용하게 되기 때문에 성능적인 측면에 유의미한 차이가 있어 가능하면 Projections 객체를 리턴하는 것이 좋습니다.</p>
<p>CursorItemReader와 Reader에 대한 성능 분석은 <a href="https://cheese10yun.github.io/spring-batch-reader-performance/">Spring Batch Reader 성능 분석 및 측정 part 1</a>, <a href="https://cheese10yun.github.io/spring-batch-reader-performance-2/">Spring Batch Reader 성능 분석 및 측정 part 2</a>를 참고해 주세요. 본 포스팅에서는 Reader에 대해서는 깊게 다루지 않겠습니다.</p>
<h3 id="단건-처리-Processor-Writer"><a href="#단건-처리-Processor-Writer" class="headerlink" title="단건 처리 Processor, Writer"></a>단건 처리 Processor, Writer</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UpdatePerformanceJobConfiguration</span>(</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">processor</span><span class="params">()</span></span>: ItemProcessor&lt;StoreProjection, StoreProjection&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> ItemProcessor &#123;</span><br><span class="line">            <span class="comment">// 사업자 최산 상태 조회 150ms 이후 응답</span></span><br><span class="line">            it.status = latestStoreStatusObtainer.getLatestStoreStatus(it.id)</span><br><span class="line">            it</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">jpaWriter</span><span class="params">()</span></span>: ItemWriter&lt;StoreProjection&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> ItemWriter &#123; stores -&gt;</span><br><span class="line">            <span class="keyword">for</span> (store <span class="keyword">in</span> stores) &#123;</span><br><span class="line">                storeRepository.updateStatus(store.id, store.status)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoreCustomRepositoryImpl</span> :</span><br><span class="line">    <span class="type">StoreCustomRepository</span>,</span><br><span class="line">    <span class="type">QuerydslRepositorySupport</span>(Store::<span class="keyword">class</span>.java) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Query DSL 기반 업데이트 </span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateStatus</span><span class="params">(id: <span class="type">Long</span>, status: <span class="type">StoreStatus</span>)</span></span> =</span><br><span class="line">        update(qStore)</span><br><span class="line">            .<span class="keyword">set</span>(qStore.status, status)</span><br><span class="line">            .<span class="keyword">where</span>(qStore.id.eq(id))</span><br><span class="line">            .execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>가장 일반적이고 직관적인 배치 흐름입니다. Processor에서 단건 조회 API를 조회하여 데이터를 가공하고 Writer에서 Query DSL 기반으로 업데이트를 진행합니다. 이렇게 처리하면 total rows * 150ms만큼 소요 시 간이 발생하게 되기 때문에 데이터 모수에 큰 영향을 받습니다.</p>
<h3 id="Rx-기반-멀티-스레드-Writer-처리"><a href="#Rx-기반-멀티-스레드-Writer-처리" class="headerlink" title="Rx 기반 멀티 스레드 Writer 처리"></a>Rx 기반 멀티 스레드 Writer 처리</h3><p>total rows * 150ms만큼 소요되기 때문에 처리할 수 있는 스레드 수만큼 작업 시간이 줄어들며 이론 상 rows 1,000 * 150ms &#x2F; 10 Thread(Parallel(10)) 만큼 처리 시간을 단축시킬 수 있습니다. 해당 포스팅은 <a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxKotlin">RxKotlin</a> 기반으로 스레드 처리를 진행합니다.</p>
<p><img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/parallelflowable.sequential.png"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UpdatePerformanceJobConfiguration</span>(</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">rxWriter</span><span class="params">()</span></span>: ItemWriter&lt;StoreProjection&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> ItemWriter &#123; stores -&gt;</span><br><span class="line">            stores</span><br><span class="line">                .toFlowable()</span><br><span class="line">                .parallel() <span class="comment">// (1)</span></span><br><span class="line">                .runOn(Schedulers.io()) <span class="comment">// (2)</span></span><br><span class="line">                .map &#123; store -&gt;</span><br><span class="line">                    <span class="comment">// 속도 특정 시에는 주석</span></span><br><span class="line">                    log.info(<span class="string">&quot;Mapping Thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>, store: <span class="variable">$store</span>&quot;</span>)</span><br><span class="line">                    <span class="comment">// 사업자 최산 상태 조회 150ms 이후 응답</span></span><br><span class="line">                    Pair(store, latestStoreStatusObtainer.getLatestStoreStatus(store.id))</span><br><span class="line">                &#125;</span><br><span class="line">                .sequential() <span class="comment">// (3)</span></span><br><span class="line">                .blockingSubscribe( <span class="comment">// (4)</span></span><br><span class="line">                    &#123; store -&gt;</span><br><span class="line">                        <span class="comment">// 속도 특정 시에는 주석</span></span><br><span class="line">                        log.info(<span class="string">&quot;Received Thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">                        <span class="keyword">val</span> second = store.second</span><br><span class="line">                        store.first.status = second</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        log.error(it.message, it)</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// (5)</span></span><br><span class="line">                        <span class="keyword">for</span> (store <span class="keyword">in</span> stores) &#123;</span><br><span class="line">                            storeRepository.updateStatus(</span><br><span class="line">                                id = store.id,</span><br><span class="line">                                status = store.status</span><br><span class="line">                            )</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoreCustomRepositoryImpl</span> :</span><br><span class="line">    <span class="type">StoreCustomRepository</span>,</span><br><span class="line">    <span class="type">QuerydslRepositorySupport</span>(Store::<span class="keyword">class</span>.java) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateStatus</span><span class="params">(id: <span class="type">Long</span>, status: <span class="type">StoreStatus</span>)</span></span> =</span><br><span class="line">        update(qStore)</span><br><span class="line">            .<span class="keyword">set</span>(qStore.status, status)</span><br><span class="line">            .<span class="keyword">where</span>(qStore.id.eq(id))</span><br><span class="line">            .execute()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>(1): stores를 병렬화하여 위 이미지처럼 레일을 만들며 레일에게 발송할 수 있게 합니다.</li>
<li>(2): Schedulers.io()를 통해서 ParallelFlowable의 병렬 처리 수준만큼 Scheduler.createWorker를 호출해서 스레드를 생성합니다.</li>
<li>(3): sequential를 통해서 parallel에서 여러 레일을 생성하는 것을 다시 단일 시퀀스로 병합합니다.</li>
<li>(4): 해당 레일이 정상 종료, 오류가 발생하기 전까지 Blocking 합니다.</li>
<li>(5): 단일 시퀀스로 병합이 완료되고 Query DSL 기반으로 업데이트를 진행합니다.</li>
</ul>
<p>Writer에서 넘겨받은 stores 객체를 병렬 처리하기 때문에 더 이상 Proccsor가 필요하지 않습니다. <strong>배치 애플리케이션에서 Proccsor에서 데이터 가공 처리하는 것은 역할 책임의 분리로는 적절하나 I&#x2F;O 작업처럼 상대적으로 느린 작업이 있으면 Proccsor에서 처리하지 않고 가능하면 Writer에서 벌크(병렬) 처리하는 것이 성능적으로 큰 이점이 있습니다.</strong></p>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/update-batch-2.png"></p>
<p><code>RxCachedThreadScheduler-1~10</code>으로 10개의 스레드로 데이터를 사업자 최산 상태 조회를 하고 있으며 이후 <code>blockingSubscribe</code>의 <code>onNext</code>는 메인 스레드로 다시 전달받는 것을 확인할 수 있습니다. <code>runOn()</code>에 각자 환경에 맞는 Schedulers를 적절하게 사용하면 되며 모든 테스트는 10개의 스케줄러 스레드 기반으로 테스트를 진행했습니다.</p>
<h3 id="Rx-기반-멀티-스레드-Bulk-Update-Writer-처리"><a href="#Rx-기반-멀티-스레드-Bulk-Update-Writer-처리" class="headerlink" title="Rx 기반 멀티 스레드 &amp; Bulk Update Writer 처리"></a>Rx 기반 멀티 스레드 &amp; Bulk Update Writer 처리</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UpdatePerformanceJobConfiguration</span>(</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">rxAndBulkWriter</span><span class="params">()</span></span>: ItemWriter&lt;StoreProjection&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> ItemWriter &#123; stores -&gt;</span><br><span class="line">            stores</span><br><span class="line">                .toFlowable()</span><br><span class="line">                .parallel()</span><br><span class="line">                .runOn(Schedulers.io())</span><br><span class="line">                .map &#123; store -&gt;</span><br><span class="line">                    <span class="comment">// 속도 특정 시에는 주석</span></span><br><span class="line">                    log.info(<span class="string">&quot;Mapping Thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>, store: <span class="variable">$store</span>&quot;</span>)</span><br><span class="line">                    <span class="comment">// 사업자 최산 상태 조회 150ms 이후 응답</span></span><br><span class="line">                    Pair(store, latestStoreStatusObtainer.getLatestStoreStatus(store.id))</span><br><span class="line">                &#125;</span><br><span class="line">                .sequential()</span><br><span class="line">                .blockingSubscribe(</span><br><span class="line">                    &#123; store -&gt;</span><br><span class="line">                        <span class="comment">// 속도 특정 시에는 주석</span></span><br><span class="line">                        log.info(<span class="string">&quot;Received Thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">                        <span class="keyword">val</span> second = store.second</span><br><span class="line">                        store.first.status = second</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        log.error(it.message, it)</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 속도 특정 시에는 주석</span></span><br><span class="line">                        log.info(<span class="string">&quot;onComplete Thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">                        <span class="comment">// (1)</span></span><br><span class="line">                        <span class="keyword">val</span> groups = stores.groupBy(&#123; it.status &#125;, &#123; it.id &#125;)</span><br><span class="line">                        <span class="comment">// (2)</span></span><br><span class="line">                        <span class="keyword">val</span> closeIds = groups[StoreStatus.CLOSE] ?: emptyList()</span><br><span class="line">                        <span class="keyword">val</span> openIds = groups[StoreStatus.OPEN] ?: emptyList()</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// (3)</span></span><br><span class="line">                        <span class="keyword">if</span> (closeIds.isNotEmpty()) &#123;</span><br><span class="line">                            storeRepository.updateStatus(ids = closeIds, status = StoreStatus.CLOSE)</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (openIds.isNotEmpty()) &#123;</span><br><span class="line">                            storeRepository.updateStatus(ids = openIds, status = StoreStatus.OPEN)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StoreCustomRepositoryImpl</span> :</span><br><span class="line">    <span class="type">StoreCustomRepository</span>,</span><br><span class="line">    <span class="type">QuerydslRepositorySupport</span>(Store::<span class="keyword">class</span>.java) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (4)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateStatus</span><span class="params">(ids: <span class="type">List</span>&lt;<span class="type">Long</span>&gt;, status: <span class="type">StoreStatus</span>)</span></span> =</span><br><span class="line">        update(qStore)</span><br><span class="line">            .<span class="keyword">set</span>(qStore.status, status)</span><br><span class="line">            .<span class="keyword">where</span>(qStore.id.`<span class="keyword">in</span>`(ids))</span><br><span class="line">            .execute()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>(1): 단일 시퀀스로 병합된 stores를 StoreStatus 값으로 그룹화 진행</li>
<li>(2): <code>OPEN(&quot;오픈&quot;),</code>, <code>CLOSE(&quot;폐업&quot;),</code> 기반으로 ids 객체 생성</li>
<li>(3): ids 객체 기반으로 업데이트 진행</li>
<li>(4): Query DSL <code>where id in</code> 기반으로 일괄 업데이트, <strong>디비 서버와 네트워크 I&#x2F;O 최소화</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/update-batch-3.png"></p>
<p><code>onComplete</code>으로 최종 결과를 main Thread로 받는 것을 확인했습니다.</p>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/update-batch-4.png"></p>
<p>이전 Rx과 거의 동일하며 Query DSL 업데이트 처리하는 방식만 달라졌습니다. Chunk 단위로 데이터를 모아서 가맹점 상태를 기준으로 그룹화를 진행하며, 그룹화를 통해서 ids 통해서 DB 업데이트를 진행합니다. <strong>Chunk 단위로는 DB 서버와 최대 2번의 통신을 하기 때문에 기존 방식 대비 네트워크 I&#x2F;O가 크게 줄어들게 됩니다. 모든 테스트는 로컬 DB 서버와 통신을 했기 때문에 JpaWriter, RxWriter 방식에서 네트워크 I&#x2F;O에 비용이 크게 발생하지 않았지만 실제 운영 환경에서는 네트워크 I&#x2F;O 비용이 커짐에 따라 더 안 좋은 성능을 보여주게 되며, RxAndBulkWriter와의 차이는 더 발생할 것으로 보입니다.</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">실제 <span class="keyword">SQL</span> log, <span class="keyword">where</span> id <span class="keyword">in</span> 절로 업데이트 진행</span><br><span class="line"><span class="type">Time</span>                 Id Command    Argument</span><br><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-12</span>T05:<span class="number">33</span>:<span class="number">58.608788</span>Z	 <span class="number">4242</span> Query</span><br><span class="line"><span class="keyword">update</span> store</span><br><span class="line"><span class="keyword">set</span> status<span class="operator">=</span><span class="string">&#x27;CLOSE&#x27;</span></span><br><span class="line"><span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">600</span>, <span class="number">598</span>, <span class="number">596</span>, <span class="number">594</span>, <span class="number">592</span>, <span class="number">590</span>, <span class="number">588</span>, <span class="number">586</span>, <span class="number">584</span>, <span class="number">582</span>, <span class="number">580</span>, <span class="number">578</span>, <span class="number">576</span>, <span class="number">574</span>, <span class="number">572</span>, <span class="number">570</span>, <span class="number">568</span>, <span class="number">566</span>, <span class="number">564</span>, <span class="number">562</span>, <span class="number">560</span>, <span class="number">558</span>, <span class="number">556</span>, <span class="number">554</span>, <span class="number">552</span>, <span class="number">550</span>, <span class="number">548</span>, <span class="number">546</span>, <span class="number">544</span>, <span class="number">542</span>, <span class="number">540</span>, <span class="number">538</span>, <span class="number">536</span>, <span class="number">534</span>, <span class="number">532</span>, <span class="number">530</span>, <span class="number">528</span>, <span class="number">526</span>, <span class="number">524</span>, <span class="number">522</span>, <span class="number">520</span>, <span class="number">518</span>, <span class="number">516</span>, <span class="number">514</span>, <span class="number">512</span>, <span class="number">510</span>, <span class="number">508</span>, <span class="number">506</span>, <span class="number">504</span>, <span class="number">502</span>) <span class="number">2022</span><span class="number">-11</span><span class="number">-12</span>T05:<span class="number">33</span>:<span class="number">58.614597</span>Z	 <span class="number">4242</span> Query</span><br><span class="line"><span class="keyword">update</span> store</span><br><span class="line"><span class="keyword">set</span> status<span class="operator">=</span><span class="string">&#x27;OPEN&#x27;</span></span><br><span class="line"><span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">599</span>, <span class="number">597</span>, <span class="number">595</span>, <span class="number">593</span>, <span class="number">591</span>, <span class="number">589</span>, <span class="number">587</span>, <span class="number">585</span>, <span class="number">583</span>, <span class="number">581</span>, <span class="number">579</span>, <span class="number">577</span>, <span class="number">575</span>, <span class="number">573</span>, <span class="number">571</span>, <span class="number">569</span>, <span class="number">567</span>, <span class="number">565</span>, <span class="number">563</span>, <span class="number">561</span>, <span class="number">559</span>, <span class="number">557</span>, <span class="number">555</span>, <span class="number">553</span>, <span class="number">551</span>, <span class="number">549</span>, <span class="number">547</span>, <span class="number">545</span>, <span class="number">543</span>, <span class="number">541</span>, <span class="number">539</span>, <span class="number">537</span>, <span class="number">535</span>, <span class="number">533</span>, <span class="number">531</span>, <span class="number">529</span>, <span class="number">527</span>, <span class="number">525</span>, <span class="number">523</span>, <span class="number">521</span>, <span class="number">519</span>, <span class="number">517</span>, <span class="number">515</span>, <span class="number">513</span>, <span class="number">511</span>, <span class="number">509</span>, <span class="number">507</span>, <span class="number">505</span>, <span class="number">503</span>, <span class="number">501</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Performance-측정-및-분석"><a href="#Performance-측정-및-분석" class="headerlink" title="Performance 측정 및 분석"></a>Performance 측정 및 분석</h2><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/update-batch-5.png"></p>
<table>
<thead>
<tr>
<th>Rows</th>
<th align="left">ChunkSize</th>
<th>JpaWriter</th>
<th>RxWriter</th>
<th>RxAndBulkWriter</th>
</tr>
</thead>
<tbody><tr>
<td>50</td>
<td align="left">10</td>
<td>8,252 ms</td>
<td>1,406 ms</td>
<td>1,258 ms</td>
</tr>
<tr>
<td>100</td>
<td align="left">20</td>
<td>16,207 ms</td>
<td>2,357 ms</td>
<td>2,078 ms</td>
</tr>
<tr>
<td>500</td>
<td align="left">100</td>
<td>78,738 ms</td>
<td>9,106 ms</td>
<td>8,268 ms</td>
</tr>
<tr>
<td>1,000</td>
<td align="left">200</td>
<td>156,420 ms</td>
<td>17,751 ms</td>
<td>1,6001 ms</td>
</tr>
<tr>
<td>5,000</td>
<td align="left">1,000</td>
<td>776,786 ms(12 min)</td>
<td>83,670 ms(1.3 min)</td>
<td>77,732 ms(1.2 min)</td>
</tr>
<tr>
<td>10,000</td>
<td align="left">1,000</td>
<td>1,556,775 ms(25 min)</td>
<td>169,473 ms(2.8 min)</td>
<td>155,777 ms(2.5 min)</td>
</tr>
<tr>
<td>50,000</td>
<td align="left">1,000</td>
<td>7,781,424 ms(129 min)</td>
<td>881,320 ms(14 min)</td>
<td>774,789 ms(12 min)</td>
</tr>
<tr>
<td>100,000</td>
<td align="left">1,000</td>
<td>15,622,542 ms(260 min)</td>
<td>1,699,994 ms(28 min)</td>
<td>1,581,545 ms(26 min)</td>
</tr>
</tbody></table>
<p>JpaWriter는 단일 스레드, RxWriter는 10 스레드로 진행하여 대략적인 수치는 스레드 차이만큼의 결과를 보여주는 것을 확인할 수 있습니다. RxWriter와 RxAndBulkWriter의 차이는 대략 10% 정도 차이가 있습니다. 이 차이는 배치 애플리케이션과 DB 서버가 로컬에 있어 루프백으로 통신을 진행하여 차이가 크게 발생하지 않았으나 실제 환경에서는 더 유의미한 차이가 있을 것으로 보입니다. 네트워크 I&#x2F;O 비용뿐만 아니라 트랜잭션을 점유하는 시간, 커넥션을 맺고 있는 시간 등등 그룹화하여 where in 절로 처리가 가능하다면 이렇게 처리하는 것이 훨씬 더 효율적이라고 판단됩니다.</p>
<p>또 RxAndBulkWriter 경우 where in으로 처리하기 때문에 ChunkSize를 늘리면 더 성능이 좋을 것으로 생각했지만 5,000 보다 1,000 Chunk가 더 좋은 성능이 좋았습니다. 아마 Rx에서 스레드를 알맞게 나누고 그것을 다시 병합하는 과정의 비용이 비싸기 때문이라고 추정됩니다. 대량 처리를 진행하는 경우는 각 환경에 맞는 ChunkSize를 측정하여 사용하는 것이 바람직해 보입니다.</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">태그</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/JPA/" rel="tag">JPA</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/ORM/" rel="tag">ORM</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/Performance/" rel="tag">Performance</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/Spring-Batch/" rel="tag">Spring Batch</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/kotlin-collection/"
                    data-tooltip="Kotlin groupBy, groupingBy, chunked, flatMap, aggregate 정리"
                    aria-label="이전: Kotlin groupBy, groupingBy, chunked, flatMap, aggregate 정리"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/mysql-batch-update/"
                    data-tooltip="MySQL Batch Update 성능 측정 및 분석"
                    aria-label="다음: MySQL Batch Update 성능 측정 및 분석"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/spring-batch-update-performance/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/spring-batch-update-performance/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cheese10yun.github.io/spring-batch-update-performance/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>


<!-- Comment -->
<!--  utteranc comment -->

<script src="https://utteranc.es/client.js"
        repo="cheese10yun/blog-comment"
        issue-term="title"
        label="Comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Yun. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/kotlin-collection/"
                    data-tooltip="Kotlin groupBy, groupingBy, chunked, flatMap, aggregate 정리"
                    aria-label="이전: Kotlin groupBy, groupingBy, chunked, flatMap, aggregate 정리"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/mysql-batch-update/"
                    data-tooltip="MySQL Batch Update 성능 측정 및 분석"
                    aria-label="다음: MySQL Batch Update 성능 측정 및 분석"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/spring-batch-update-performance/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/spring-batch-update-performance/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cheese10yun.github.io/spring-batch-update-performance/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="5">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/spring-batch-update-performance/"
                        aria-label="Facebook에 공유하기"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Facebook에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/spring-batch-update-performance/"
                        aria-label="Twitter에 공유하기"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Twitter에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://cheese10yun.github.io/spring-batch-update-performance/"
                        aria-label="Google+에 공유하기"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Google+에 공유하기</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
            <h4 id="about-card-name">Yun</h4>
        
            <div id="about-card-bio"><p>기술 블로그</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
