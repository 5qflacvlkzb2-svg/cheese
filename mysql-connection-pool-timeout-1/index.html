
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="naver-site-verification" content="a37ea649edf26e70c3de94f9cb034f9d6e11de3f" />
    <meta name="generator" content="Yun Blog">
    <title>HikariCP로 MySQL Connection Pool 최적화하기 - Yun Blog</title>
    <meta name="author" content="Yun">
    
        <meta name="keywords" content="Node,Spring,Spring Boot,Spring Batch,Kotlin,기술 블로그,JPA,Mongo,MySQL,OOP,">
    
    
    
        
            <link rel="alternate" type="application/rss+xml" title="RSS" href="/rss2.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg"},"articleBody":"Spring Boot는 기본적으로 HikariCP를 내장된 커넥션 풀로 지원하며, 이를 통해 데이터베이스 연결을 효율적으로 관리할 수 있습니다. 이번 포스팅에서는 Spring Boot 환경에서 HikariCP의 설정을 최적화하여 TPS 변화에 유연하게 대응하는 방법을 알아보겠습니다.\nHikariCP 설정 예시#\nSpring Boot에서 application.yml 또는 application.properties 파일을 통해 HikariCP 설정을 정의할 수 있습니다. 이번 예시에서는 다음과 같은 설정을 적용하였습니다.\n1234567spring:    datasource:        hikari:            minimum-idle: 10            maximum-pool-size: 10            idle-timeout: 30000            connection-timeout: 20000\n\nminimum-idle: 최소 유휴 커넥션 수입니다. 초기 설정 시 최소한의 커넥션(여기서는 10개)만 유지하여, TPS가 낮을 때 리소스를 절약할 수 있습니다.\nmaximum-pool-size: 커넥션 풀의 최대 크기입니다. TPS가 높아질 때 최대 10개의 커넥션까지 생성하여 요청을 처리할 수 있게 설정합니다.\nidle-timeout: 지정된 시간(밀리초) 동안 유휴 상태인 커넥션이 있을 경우 풀에서 제거합니다. 트래픽이 낮아질 때 자동으로 풀 크기를 줄이는 데 기여합니다.\nconnection-timeout: 커넥션을 얻기 위해 대기하는 최대 시간입니다. 이 시간 내에 커넥션을 확보하지 못하면 예외가 발생합니다.\n\nTPS 변화에 따른 커넥션 풀의 동작#\n\nTPS가 낮은 경우: Spring Boot 애플리케이션이 유휴 상태이거나 트래픽이 적은 경우, HikariCP는 최소 커넥션(minimum-idle)만 유지하여 리소스 사용을 최적화합니다.\nTPS가 높아질 경우: TPS가 증가하여 커넥션이 필요한 상황이 되면, HikariCP는 최대 커넥션(maximum-pool-size)까지 확장하여 대량의 요청을 처리할 수 있게 합니다. 이를 통해 성능 저하 없이 안정적으로 트래픽을 소화할 수 있습니다.\nTPS가 다시 낮아지는 경우: TPS가 다시 낮아지면 HikariCP는 idle-timeout에 따라 불필요한 커넥션을 풀에서 제거하고, minimum-idle만 유지하여 리소스를 절약합니다.\n\n이 케이스는 MySQL Connection Pool에서 minimum-idle과 maximum-pool-size를 동일하게 설정한 상황에서, TPS가 200대에 도달할 때 발생하는 성능 문제를 다루고 있습니다. 그래프와 로그를 바탕으로 아래와 같이 분석할 수 있습니다.\nTPS가 높아지는 상황에서의 커넥션 풀 동작 분석#\nSpring Boot 애플리케이션에서 TPS가 높아질 때, HikariCP의 커넥션 풀이 어떻게 반응하고 성능에 어떤 영향을 미치는지 살펴보겠습니다. 이 테스트는 minimum-idle: 10과 maximum-pool-size: 10 설정을 사용해, 커넥션 풀의 확장성과 한계점을 확인하는 데 중점을 두었습니다.\n애플리케이션은 지속적으로 증가하는 사용자 요청을 처리하며, TPS가 증가함에 따라 커넥션 풀이 최대에 도달하는 시점에서 성능 지연과 요청 실패가 발생하는 과정을 시각적으로 분석했습니다.\n상황 설명#\n다음 코드는 Spring Boot와 Kotlin 환경에서 설정된 컨트롤러와 서비스 로직입니다. 컨트롤러에서는 SampleService의 getMember() 메서드를 호출하며, 이 메서드는 1~100 사이의 랜덤 ID로 Member 엔티티를 PK를 기반으로 조회한 후, 1초의 지연 시간을 둔 뒤 커넥션 풀의 현재 상태를 로깅합니다.\n123456789101112@RestController@RequestMappingclass SampleController(    private val SampleService: SampleService) &#123;    @GetMapping(&quot;/api/v1/members&quot;)    fun sample(): Member &#123;        // 1 ~ 100 사이의 랜덤으로 member 조회        return SampleService.getMember()    &#125;&#125;\n1234567891011121314151617181920212223242526272829303132@Serviceclass SampleService(    private val dataSource: DataSource,    private val memberRepository: MemberRepository) &#123;    private val log = LoggerFactory.getLogger(javaClass)!!    @Transactional    fun getMember(): Member &#123;        val findById = memberRepository.findById(Random.nextInt(1, 100).toLong()).get()        runBlocking &#123; delay(1000) &#125;        val targetDataSource = dataSource.unwrap(HikariDataSource::class.java)        val hikariDataSource = targetDataSource as HikariDataSource        val hikariPoolMXBean = hikariDataSource.hikariPoolMXBean        val hikariConfigMXBean = hikariDataSource.hikariConfigMXBean        val log =            &quot;&quot;&quot;            totalConnections : $&#123;hikariPoolMXBean.totalConnections&#125;            activeConnections : $&#123;hikariPoolMXBean.activeConnections&#125;            idleConnections : $&#123;hikariPoolMXBean.idleConnections&#125;            threadsAwaitingConnection : $&#123;hikariPoolMXBean.threadsAwaitingConnection&#125;            maxLifetime : $&#123;hikariConfigMXBean.maxLifetime&#125;            maximumPoolSize : $&#123;hikariConfigMXBean.maximumPoolSize&#125;            minimumIdle : $&#123;hikariConfigMXBean.minimumIdle&#125;            connectionTimeout : $&#123;hikariConfigMXBean.connectionTimeout&#125;            validationTimeout : $&#123;hikariConfigMXBean.validationTimeout&#125;            idleTimeout : $&#123;hikariConfigMXBean.idleTimeout&#125;            &quot;&quot;&quot;.trimIndent()        this.log.info(log)        return findById    &#125;&#125;\n이 코드는 지연을 위해 1초 동안 대기한 후, HikariCP 커넥션 풀의 상태를 로깅하여 현재 커넥션 풀 상황을 모니터링할 수 있게 합니다.\n성능 테스트 결과 (위 이미지 설명)#\n\n위 이미지는 커넥션 풀 설정이 minimum-idle: 10, maximum-pool-size: 10으로 설정된 상황에서, TPS가 증가함에 따라 성능이 어떻게 변화하는지를 시각화한 결과입니다.\n\nTotal Requests per Second:\n\n이 그래프는 초당 요청 처리량(RPS, 초록색 라인)과 실패한 요청(Failures, 빨간색 라인)을 보여줍니다.\nTPS가 점진적으로 증가하여 초당 12 요청 수준에 도달했을 때, 실패한 요청이 발생하기 시작했습니다. 이는 커넥션 풀이 최대 용량인 10에 도달하여 더 이상 추가 요청을 처리하지 못하는 상황을 나타냅니다.\n이후 TPS는 유지되지만, 실패한 요청이 지속적으로 발생하면서 커넥션 풀의 제한에 따른 성능 저하가 명확히 드러납니다. 이후 TPS는 응답 지연으로 인해 더 이상 올라가지 않습니다.\n\n\nResponse Times:\n\n응답 시간 그래프에서는 50th 퍼센타일(주황색 라인)과 95th 퍼센타일(보라색 라인)의 응답 시간이 시간이 지남에 따라 증가하는 모습이 보입니다.\n특히 TPS가 증가함에 따라 95th 퍼센타일 응답 시간은 약 20,000ms 이상으로 치솟아, 사용자 요청이 큰 지연을 겪고 있음을 나타냅니다.\n이는 커넥션 풀이 가득 차서 새로운 요청이 대기 상태로 전환되었기 때문이며, 트래픽 증가와 함께 시스템의 성능 한계에 도달했음을 보여줍니다.\n\n\nNumber of Users:\n\n사용자의 수가 점진적으로 증가하며 시스템에 부하를 가하고 있습니다. 사용자가 약 300명 이상일 때부터 시스템은 커넥션 풀이 한계에 도달하여, 그 이후로는 성능 저하가 본격적으로 발생합니다.\n커넥션 풀 크기를 초과하는 사용자 요청은 실패하거나 긴 대기 시간을 초래하게 되며, 이는 응답 시간 증가와 TPS 유지의 원인이 됩니다.\n\n\n\n이 이미지에서는 커넥션 풀이 최대 용량에 도달함에 따라, 시스템이 추가적인 요청을 감당하지 못하고 지연 시간과 실패율이 증가하는 과정을 시각적으로 확인할 수 있습니다.\n로그 분석#\n\n\n\n필드\n설명\n\n\n\n\nactiveConnections\n10 - 현재 활성 상태인 모든 커넥션이 사용 중입니다.\n\n\nidleConnections\n0 - 유휴 상태의 커넥션은 없습니다.\n\n\nthreadsAwaitingConnection\n84 - 84개의 스레드가 커넥션을 기다리고 있습니다.\n\n\nmaxLifetime\n1800000 (밀리초) - 커넥션의 최대 수명입니다.\n\n\nmaximumPoolSize\n10 - 최대 커넥션 풀 크기가 10으로 설정되어 있습니다.\n\n\nminimumIdle\n10 - 최소 유휴 커넥션이 10으로 설정되어 있습니다.\n\n\nconnectionTimeout\n30000 (밀리초) - 커넥션을 얻기 위해 대기할 수 있는 최대 시간입니다.\n\n\nvalidationTimeout\n5000 (밀리초) - 커넥션 유효성 검사를 위한 시간입니다.\n\n\nidleTimeout\n600000 (밀리초) - 유휴 커넥션을 유지하는 최대 시간입니다.\n\n\n\n이 로그는 커넥션 풀이 한계에 도달하여 더 이상 커넥션을 확장할 수 없고, 여러 스레드가 커넥션을 기다리면서 성능 저하가 발생하고 있음을 보여줍니다.\n문제 원인#\n\n커넥션 풀 크기 제한: 현재 maximum-pool-size가 10으로 설정되어 있어 초당 12개 이상의 요청(TPS)을 처리하기에는 커넥션 풀 크기가 부족합니다. 모든 커넥션이 이미 사용 중이기 때문에, 추가적인 요청이 들어오면 커넥션을 기다리게 되고, 이로 인해 요청 실패가 발생하거나 응답 시간이 길어집니다.\n스레드 대기: 커넥션 풀이 최대 용량에 도달하면서 threadsAwaitingConnection 수가 증가하게 됩니다. 이는 커넥션을 얻지 못한 요청이 대기 상태로 전환되는 상황을 나타내며, TPS가 증가할 때 시스템이 추가 요청을 즉각적으로 처리하지 못하고 성능 저하를 초래하는 주요 원인이 됩니다.\nconnectionTimeout 설정: 현재 connectionTimeout이 30000밀리초(30초)로 설정되어 있어, 커넥션을 기다리는 요청은 최대 30초까지 대기할 수 있습니다. 그러나 이 대기 시간이 길어질수록 전체 응답 시간이 증가하게 되며, 대기 중인 요청이 많아지면 TPS가 상승하기 어려워지고 응답 지연으로 인한 성능 저하가 발생할 수 있습니다.\n\n이러한 문제들은 TPS가 높아질수록 커넥션 풀의 제한으로 인해 전체적인 성능 저하가 발생하게 되는 이유입니다.\n해결 방안#\n\nmaximum-pool-size 증가: 현재의 TPS 수요를 충족하기 위해 maximum-pool-size 값을 늘려야 합니다. 예를 들어, 10 이상으로 설정하여 커넥션 풀이 더 많은 요청을 처리할 수 있도록 하면, 요청 대기 시간과 실패를 줄일 수 있습니다.\n동적 커넥션 관리: HikariCP의 특성을 활용해 minimum-idle과 maximum-pool-size를 적절히 조정하여 트래픽 변화에 유연하게 대응할 수 있도록 합니다. TPS가 높아질 때는 커넥션 풀이 자동으로 확장되도록 하고, TPS가 감소할 때는 최소한의 커넥션만 유지해 리소스를 절약하도록 설정하는 것이 좋습니다.\n모니터링 및 지속적인 튜닝: 커넥션 풀의 상태를 지속적으로 모니터링하여, 트래픽 패턴에 맞게 적절히 튜닝하는 것이 필요합니다. 정기적인 모니터링을 통해 TPS와 응답 시간 변화를 관찰하고, 필요에 따라 maximum-pool-size, connectionTimeout 등의 설정을 조정하여 최적의 성능을 유지할 수 있습니다.\n\n이러한 방안들은 트래픽 변동에 따라 유연하게 커넥션 풀을 관리하고, 시스템 성능을 최적화하는 데 도움이 됩니다.\n성능 테스트 결과 분석: maximum-pool-size를 200으로 조정한 경우#\n12345spring:    datasource:        hikari:            maximum-pool-size: 200           # 최대 커넥션 수            minimum-idle: 10                 # 최소 유휴 커넥션 수\n위와 같이 maximum-pool-size를 200, minimum-idle을 10으로 설정하여 테스트를 진행한 결과, 커넥션 풀이 충분히 확장 가능해지면서 시스템 성능이 크게 개선되었습니다. 주요 개선 사항은 다음과 같습니다.\n\n\nTotal Requests per Second (RPS):\n\nRPS가 점진적으로 증가하여 높은 TPS를 안정적으로 처리할 수 있게 되었습니다. 초당 요청 처리량이 약 150까지 증가했음에도 불구하고, 실패한 요청(Failures/s)은 발생하지 않았습니다.\n이는 커넥션 풀이 충분히 확장되어, 모든 요청이 처리되는 동안 커넥션 부족으로 인한 대기 시간이 발생하지 않았음을 의미합니다.\n\n\nResponse Times:\n\n응답 시간 그래프에서 50th 및 95th 퍼센타일 응답 시간이 비교적 안정적인 수준을 유지하고 있습니다.\n95th 퍼센타일 응답 시간은 약 3,000ms 이하로, 50th 퍼센타일은 약 1,000ms 내외로 유지되었습니다. 이는 고TPS 상황에서도 일관된 응답 속도를 제공할 수 있음을 보여줍니다.\n이전 설정에서 발생했던 응답 시간의 급격한 증가가 해소되어, 사용자 경험이 크게 개선되었습니다.\n\n\nFailures/s 비율:\n\n요청 실패율이 0으로 유지되었습니다. maximum-pool-size를 200으로 설정한 덕분에, connectionTimeout으로 인해 대기 상태에서 실패하는 요청이 없었습니다.\n이로써 고TPS 상황에서도 안정적인 서비스가 가능해졌으며, 대량의 동시 요청을 처리하는 데 적합한 환경이 조성되었습니다.\n\n\n\n로그 분석#\n\n\n\n필드\n설명\n\n\n\n\ntotalConnections\n152 - 현재 총 152개의 커넥션이 생성되었습니다.\n\n\nactiveConnections\n152 - 모든 커넥션이 활성 상태로 사용 중입니다.\n\n\nidleConnections\n0 - 유휴 상태의 커넥션은 없습니다.\n\n\nthreadsAwaitingConnection\n48 - 48개의 스레드가 커넥션을 기다리고 있습니다.\n\n\nmaximumPoolSize\n200 - 최대 커넥션 풀 크기가 200으로 설정되었습니다.\n\n\nminimumIdle\n10 - 최소 유휴 커넥션이 10으로 설정되어 있어, 초기에 모든 커넥션이 생성된 상태입니다.\n\n\n\n이 설정을 통해 커넥션 풀은 트래픽이 적을 때에는 최소한의 자원만 사용하고, 트래픽이 증가할 때에는 최대 200개의 커넥션까지 확장하여 요청을 처리할 수 있습니다. 로그에서 볼 수 있듯이 TPS가 높은 상황에서도 커넥션 풀이 충분히 확장되었고, 전체적인 시스템 성능에는 큰 영향을 미치지 않았습니다. 이를 통해 시스템은 높은 TPS 환경에서도 안정적이고 일관된 성능을 제공할 수 있음을 확인할 수 있습니다.\n성능 테스트 결과 분석: TPS 감소 상황에서의 커넥션 풀 동작#\n아래 설정으로 TPS가 낮아진 상황에서 성능 테스트를 진행했습니다.\n1234567spring:    datasource:        hikari:            maximum-pool-size: 200           # 최대 커넥션 수            minimum-idle: 10                 # 최소 유휴 커넥션 수            max-lifetime: 300000             # 커넥션이 유지될 최대 시간 (밀리초)            idle-timeout: 250000             # 유휴 커넥션이 유지될 최대 시간 (밀리초)\n\nmax-lifetime: 기본값은 1800000ms (30분)입니다. 각 커넥션이 일정 시간 동안만 유지된 후 새 커넥션으로 교체되도록 하여, 오래된 커넥션으로 인해 발생할 수 있는 문제를 방지합니다. 설정된 시간(예: 300,000ms = 5분) 이후에 커넥션은 제거되고 새로운 커넥션으로 대체됩니다.\nidle-timeout: 기본값은 600000ms (10분)입니다. 유휴 상태의 커넥션이 설정된 시간 동안 사용되지 않으면 커넥션 풀에서 제거됩니다. 트래픽이 감소한 상황에서는 유휴 커넥션이 줄어들어 리소스가 절약됩니다. 위 설정에서는 250,000ms 동안 유휴 상태인 커넥션을 유지하고 이후에 해제하도록 설정했습니다.\n\n테스트 결과 분석#\n\n\nTotal Requests per Second (RPS):\n\nTPS가 낮아지며, 초당 요청 처리량이 약 5 수준으로 안정화되었습니다.\n요청 실패(Failures/s)가 발생하지 않았으며, 모든 요청이 성공적으로 처리되었습니다.\n이는 트래픽이 줄어들면서 커넥션 풀이 유휴 상태로 돌아가고 있음을 의미합니다.\n\n\nResponse Times:\n\n50th 및 95th 퍼센타일 응답 시간 모두 약 1,000ms 내외로 일정하게 유지되고 있습니다.\n응답 시간의 변동이 크지 않고 안정적인 수준을 보여, TPS가 낮아진 상황에서도 일관된 성능을 제공하고 있습니다.\n\n\nNumber of Users:\n\n테스트에서 사용자 수가 10명으로 일정하게 유지되고 있으며, TPS가 낮은 상태로 안정화되었습니다.\n\n\n\n로그 분석#\n\n\n\n필드\n\n\n\n\n\ntotalConnections\n15 - 현재 총 15개의 커넥션이 생성되었습니다. 트래픽 감소에 따라 필요 없는 커넥션이 자동으로 해제되며, 풀 크기가 줄어든 상태입니다.\n\n\nactiveConnections\n6 - 현재 활성 상태로 사용 중인 커넥션이 6개입니다.\n\n\nidleConnections\n9 - 최소 유휴 커넥션 설정(minimumIdle)이 10이므로, 트래픽이 줄어든 상황에서 9개의 유휴 커넥션이 유지됩니다.\n\n\nthreadsAwaitingConnection\n0 - 대기 중인 스레드가 없어 모든 요청이 즉시 처리되고 있습니다.\n\n\nmaximumPoolSize\n200 - 최대 커넥션 풀 크기가 200으로 설정되어 있지만, 현재 트래픽 수준에서는 전체를 사용할 필요 없이 적정 개수의 커넥션만 유지하고 있습니다.\n\n\nminimumIdle\n10 - 최소 유휴 커넥션 수가 10으로 설정되어, 트래픽이 적을 때도 최소한의 커넥션을 유지해 자원을 절약합니다.\n\n\nmaxLifetime\n300000 (밀리초) - 각 커넥션이 5분(300초) 동안 유지된 후 자동으로 갱신되도록 설정되어 있어, 오래된 커넥션으로 인한 문제를 방지하고 안정적인 연결 상태를 보장합니다.\n\n\nidleTimeout\n250000 (밀리초) - 유휴 상태의 커넥션이 4분 10초 동안 사용되지 않으면 풀에서 해제됩니다. 이를 통해 트래픽이 감소한 상황에서는 유휴 커넥션을 줄여 리소스를 절약할 수 있습니다.\n\n\n\n이 테스트 결과는 TPS가 줄어들면 totalConnections도 함께 감소하며 리소스가 효율적으로 관리되는 모습을 보여줍니다. minimum-idle 설정을 통해 커넥션 풀이 최소 10개의 유휴 커넥션을 유지하고, idleTimeout이 설정된 시간 동안 유휴 상태인 커넥션을 자동으로 해제하여 불필요한 자원 낭비를 방지합니다. 또한 maxLifetime 설정으로 각 커넥션의 유지 시간을 제한하여 일정 시간이 지나면 커넥션이 새롭게 갱신되도록 함으로써 오래된 커넥션으로 인한 문제를 예방합니다. 이를 통해 시스템은 트래픽 변화에 유연하게 대응하며 안정적으로 자원을 관리할 수 있는 구조를 갖추게 됩니다.\n결론#\nHikariCP를 사용한 커넥션 풀 설정은 트래픽 변화에 유연하게 대응할 수 있으며, 성능 최적화를 위해 중요한 도구가 됩니다. 적절한 maximum-pool-size와 minimum-idle 설정을 통해 고TPS 환경에서도 안정적이고 일관된 응답 시간을 제공할 수 있으며, 리소스를 효율적으로 관리하여 비용 절감 효과도 기대할 수 있습니다. 이를 통해 Spring Boot 애플리케이션은 다양한 트래픽 상황에서 성능을 최적화하며, 사용자 경험을 크게 개선할 수 있습니다.\n","dateCreated":"2024-10-26T00:00:00+09:00","dateModified":"2025-02-06T02:52:03+09:00","datePublished":"2024-10-26T00:00:00+09:00","description":"Spring Boot는 기본적으로 HikariCP를 내장된 커넥션 풀로 지원하며, 이를 통해 데이터베이스 연결을 효율적으로 관리할 수 있습니다. 이번 포스팅에서는 Spring Boot 환경에서 HikariCP의 설정을 최적화하여 TPS 변화에 유연하게 대응하는 방법을 알아보겠습니다.","headline":"HikariCP로 MySQL Connection Pool 최적화하기","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://cheese10yun.github.io/mysql-connection-pool-timeout-1/"},"publisher":{"@type":"Organization","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg","logo":{"@type":"ImageObject","url":"yun-icon.jpg"}},"url":"https://cheese10yun.github.io/mysql-connection-pool-timeout-1/","keywords":"Performance, MySQL, Connection Pool"}</script>
    <meta name="description" content="Spring Boot는 기본적으로 HikariCP를 내장된 커넥션 풀로 지원하며, 이를 통해 데이터베이스 연결을 효율적으로 관리할 수 있습니다. 이번 포스팅에서는 Spring Boot 환경에서 HikariCP의 설정을 최적화하여 TPS 변화에 유연하게 대응하는 방법을 알아보겠습니다.">
<meta property="og:type" content="blog">
<meta property="og:title" content="HikariCP로 MySQL Connection Pool 최적화하기">
<meta property="og:url" content="https://cheese10yun.github.io/mysql-connection-pool-timeout-1/index.html">
<meta property="og:site_name" content="Yun Blog">
<meta property="og:description" content="Spring Boot는 기본적으로 HikariCP를 내장된 커넥션 풀로 지원하며, 이를 통해 데이터베이스 연결을 효율적으로 관리할 수 있습니다. 이번 포스팅에서는 Spring Boot 환경에서 HikariCP의 설정을 최적화하여 TPS 변화에 유연하게 대응하는 방법을 알아보겠습니다.">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-1-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-1-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-1-3.png">
<meta property="article:published_time" content="2024-10-25T15:00:00.000Z">
<meta property="article:modified_time" content="2025-02-05T17:52:03.299Z">
<meta property="article:author" content="Yun">
<meta property="article:tag" content="Performance">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="Connection Pool">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-1-1.png">
    
    
        
    
    
        <meta property="og:image" content="https://cheese10yun.github.io/assets/images/yun-icon.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90907312-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-90907312-1');
    </script>


    

    
        
    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5813739623204880" crossorigin="anonymous"></script>
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="5">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Yun Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="링크 열기: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="5">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="저자에 대해 더 알아보기"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
                </a>
                <h4 class="sidebar-profile-name">Yun</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기술 블로그</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="태그"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="아카이브"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">아카이브</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/cheese10yun"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/rss2.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="5"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            HikariCP로 MySQL Connection Pool 최적화하기
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2024-10-26T00:00:00+09:00">
	
		    2024/10/26
    	
    </time>
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>Spring Boot는 기본적으로 HikariCP를 내장된 커넥션 풀로 지원하며, 이를 통해 데이터베이스 연결을 효율적으로 관리할 수 있습니다. 이번 포스팅에서는 Spring Boot 환경에서 HikariCP의 설정을 최적화하여 TPS 변화에 유연하게 대응하는 방법을 알아보겠습니다.</p>
<h2><span id="hikaricp-seoljeong-yesi">HikariCP 설정 예시</span><a href="#hikaricp-seoljeong-yesi" class="header-anchor">#</a></h2>
<p>Spring Boot에서 application.yml 또는 application.properties 파일을 통해 HikariCP 설정을 정의할 수 있습니다. 이번 예시에서는 다음과 같은 설정을 적용하였습니다.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">hikari:</span></span><br><span class="line">            <span class="attr">minimum-idle:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">maximum-pool-size:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">idle-timeout:</span> <span class="number">30000</span></span><br><span class="line">            <span class="attr">connection-timeout:</span> <span class="number">20000</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>minimum-idle</strong>: 최소 유휴 커넥션 수입니다. 초기 설정 시 최소한의 커넥션(여기서는 10개)만 유지하여, TPS가 낮을 때 리소스를 절약할 수 있습니다.</li>
<li><strong>maximum-pool-size</strong>: 커넥션 풀의 최대 크기입니다. TPS가 높아질 때 최대 10개의 커넥션까지 생성하여 요청을 처리할 수 있게 설정합니다.</li>
<li><strong>idle-timeout</strong>: 지정된 시간(밀리초) 동안 유휴 상태인 커넥션이 있을 경우 풀에서 제거합니다. 트래픽이 낮아질 때 자동으로 풀 크기를 줄이는 데 기여합니다.</li>
<li><strong>connection-timeout</strong>: 커넥션을 얻기 위해 대기하는 최대 시간입니다. 이 시간 내에 커넥션을 확보하지 못하면 예외가 발생합니다.</li>
</ul>
<h2><span id="tps-byeonhwae-ddareun-keonegsyeon-pulyi-dongjag">TPS 변화에 따른 커넥션 풀의 동작</span><a href="#tps-byeonhwae-ddareun-keonegsyeon-pulyi-dongjag" class="header-anchor">#</a></h2>
<ol>
<li><strong>TPS가 낮은 경우</strong>: Spring Boot 애플리케이션이 유휴 상태이거나 트래픽이 적은 경우, HikariCP는 최소 커넥션(minimum-idle)만 유지하여 리소스 사용을 최적화합니다.</li>
<li><strong>TPS가 높아질 경우</strong>: TPS가 증가하여 커넥션이 필요한 상황이 되면, HikariCP는 최대 커넥션(maximum-pool-size)까지 확장하여 대량의 요청을 처리할 수 있게 합니다. 이를 통해 성능 저하 없이 안정적으로 트래픽을 소화할 수 있습니다.</li>
<li><strong>TPS가 다시 낮아지는 경우</strong>: TPS가 다시 낮아지면 HikariCP는 <code>idle-timeout</code>에 따라 불필요한 커넥션을 풀에서 제거하고, <code>minimum-idle</code>만 유지하여 리소스를 절약합니다.</li>
</ol>
<p>이 케이스는 MySQL Connection Pool에서 <code>minimum-idle</code>과 <code>maximum-pool-size</code>를 동일하게 설정한 상황에서, TPS가 200대에 도달할 때 발생하는 성능 문제를 다루고 있습니다. 그래프와 로그를 바탕으로 아래와 같이 분석할 수 있습니다.</p>
<h2><span id="tpsga-nopajineun-sanghwangeseoyi-keonegsyeon-pul-dongjag-bunseog">TPS가 높아지는 상황에서의 커넥션 풀 동작 분석</span><a href="#tpsga-nopajineun-sanghwangeseoyi-keonegsyeon-pul-dongjag-bunseog" class="header-anchor">#</a></h2>
<p>Spring Boot 애플리케이션에서 TPS가 높아질 때, HikariCP의 커넥션 풀이 어떻게 반응하고 성능에 어떤 영향을 미치는지 살펴보겠습니다. 이 테스트는 <code>minimum-idle: 10</code>과 <code>maximum-pool-size: 10</code> 설정을 사용해, 커넥션 풀의 확장성과 한계점을 확인하는 데 중점을 두었습니다.</p>
<p>애플리케이션은 지속적으로 증가하는 사용자 요청을 처리하며, TPS가 증가함에 따라 커넥션 풀이 최대에 도달하는 시점에서 성능 지연과 요청 실패가 발생하는 과정을 시각적으로 분석했습니다.</p>
<h3><span id="sanghwang-seolmyeong">상황 설명</span><a href="#sanghwang-seolmyeong" class="header-anchor">#</a></h3>
<p>다음 코드는 Spring Boot와 Kotlin 환경에서 설정된 컨트롤러와 서비스 로직입니다. 컨트롤러에서는 <code>SampleService</code>의 <code>getMember()</code> 메서드를 호출하며, 이 메서드는 1~100 사이의 랜덤 ID로 <code>Member</code> 엔티티를 PK를 기반으로 조회한 후, 1초의 지연 시간을 둔 뒤 커넥션 풀의 현재 상태를 로깅합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SampleController</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> SampleService: SampleService</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(<span class="string">&quot;/api/v1/members&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sample</span><span class="params">()</span></span>: Member &#123;</span><br><span class="line">        <span class="comment">// 1 ~ 100 사이의 랜덤으로 member 조회</span></span><br><span class="line">        <span class="keyword">return</span> SampleService.getMember()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SampleService</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> dataSource: DataSource,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> memberRepository: MemberRepository</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> log = LoggerFactory.getLogger(javaClass)!!</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getMember</span><span class="params">()</span></span>: Member &#123;</span><br><span class="line">        <span class="keyword">val</span> findById = memberRepository.findById(Random.nextInt(<span class="number">1</span>, <span class="number">100</span>).toLong()).<span class="keyword">get</span>()</span><br><span class="line">        runBlocking &#123; delay(<span class="number">1000</span>) &#125;</span><br><span class="line">        <span class="keyword">val</span> targetDataSource = dataSource.unwrap(HikariDataSource::<span class="keyword">class</span>.java)</span><br><span class="line">        <span class="keyword">val</span> hikariDataSource = targetDataSource <span class="keyword">as</span> HikariDataSource</span><br><span class="line">        <span class="keyword">val</span> hikariPoolMXBean = hikariDataSource.hikariPoolMXBean</span><br><span class="line">        <span class="keyword">val</span> hikariConfigMXBean = hikariDataSource.hikariConfigMXBean</span><br><span class="line">        <span class="keyword">val</span> log =</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            totalConnections : <span class="subst">$&#123;hikariPoolMXBean.totalConnections&#125;</span></span></span><br><span class="line"><span class="string">            activeConnections : <span class="subst">$&#123;hikariPoolMXBean.activeConnections&#125;</span></span></span><br><span class="line"><span class="string">            idleConnections : <span class="subst">$&#123;hikariPoolMXBean.idleConnections&#125;</span></span></span><br><span class="line"><span class="string">            threadsAwaitingConnection : <span class="subst">$&#123;hikariPoolMXBean.threadsAwaitingConnection&#125;</span></span></span><br><span class="line"><span class="string">            maxLifetime : <span class="subst">$&#123;hikariConfigMXBean.maxLifetime&#125;</span></span></span><br><span class="line"><span class="string">            maximumPoolSize : <span class="subst">$&#123;hikariConfigMXBean.maximumPoolSize&#125;</span></span></span><br><span class="line"><span class="string">            minimumIdle : <span class="subst">$&#123;hikariConfigMXBean.minimumIdle&#125;</span></span></span><br><span class="line"><span class="string">            connectionTimeout : <span class="subst">$&#123;hikariConfigMXBean.connectionTimeout&#125;</span></span></span><br><span class="line"><span class="string">            validationTimeout : <span class="subst">$&#123;hikariConfigMXBean.validationTimeout&#125;</span></span></span><br><span class="line"><span class="string">            idleTimeout : <span class="subst">$&#123;hikariConfigMXBean.idleTimeout&#125;</span></span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line">        <span class="keyword">this</span>.log.info(log)</span><br><span class="line">        <span class="keyword">return</span> findById</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이 코드는 지연을 위해 1초 동안 대기한 후, HikariCP 커넥션 풀의 상태를 로깅하여 현재 커넥션 풀 상황을 모니터링할 수 있게 합니다.</p>
<h3><span id="seongneung-teseuteu-gyeolgwa-wi-imiji-seolmyeong">성능 테스트 결과 (위 이미지 설명)</span><a href="#seongneung-teseuteu-gyeolgwa-wi-imiji-seolmyeong" class="header-anchor">#</a></h3>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-1-1.png" alt></p>
<p>위 이미지는 커넥션 풀 설정이 <strong>minimum-idle: 10, maximum-pool-size: 10</strong>으로 설정된 상황에서, TPS가 증가함에 따라 성능이 어떻게 변화하는지를 시각화한 결과입니다.</p>
<ul>
<li><strong>Total Requests per Second</strong>:
<ul>
<li>이 그래프는 초당 요청 처리량(RPS, 초록색 라인)과 실패한 요청(Failures, 빨간색 라인)을 보여줍니다.</li>
<li>TPS가 점진적으로 증가하여 초당 12 요청 수준에 도달했을 때, 실패한 요청이 발생하기 시작했습니다. 이는 커넥션 풀이 최대 용량인 10에 도달하여 더 이상 추가 요청을 처리하지 못하는 상황을 나타냅니다.</li>
<li>이후 TPS는 유지되지만, 실패한 요청이 지속적으로 발생하면서 커넥션 풀의 제한에 따른 성능 저하가 명확히 드러납니다. 이후 TPS는 응답 지연으로 인해 더 이상 올라가지 않습니다.</li>
</ul>
</li>
<li><strong>Response Times</strong>:
<ul>
<li>응답 시간 그래프에서는 <strong>50th 퍼센타일</strong>(주황색 라인)과 <strong>95th 퍼센타일</strong>(보라색 라인)의 응답 시간이 시간이 지남에 따라 증가하는 모습이 보입니다.</li>
<li>특히 TPS가 증가함에 따라 95th 퍼센타일 응답 시간은 약 20,000ms 이상으로 치솟아, 사용자 요청이 큰 지연을 겪고 있음을 나타냅니다.</li>
<li>이는 커넥션 풀이 가득 차서 새로운 요청이 대기 상태로 전환되었기 때문이며, 트래픽 증가와 함께 시스템의 성능 한계에 도달했음을 보여줍니다.</li>
</ul>
</li>
<li><strong>Number of Users</strong>:
<ul>
<li>사용자의 수가 점진적으로 증가하며 시스템에 부하를 가하고 있습니다. 사용자가 약 300명 이상일 때부터 시스템은 커넥션 풀이 한계에 도달하여, 그 이후로는 성능 저하가 본격적으로 발생합니다.</li>
<li>커넥션 풀 크기를 초과하는 사용자 요청은 실패하거나 긴 대기 시간을 초래하게 되며, 이는 응답 시간 증가와 TPS 유지의 원인이 됩니다.</li>
</ul>
</li>
</ul>
<p>이 이미지에서는 커넥션 풀이 최대 용량에 도달함에 따라, 시스템이 추가적인 요청을 감당하지 못하고 지연 시간과 실패율이 증가하는 과정을 시각적으로 확인할 수 있습니다.</p>
<h3><span id="rogeu-bunseog">로그 분석</span><a href="#rogeu-bunseog" class="header-anchor">#</a></h3>
<table>
<thead>
<tr>
<th>필드</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>activeConnections</td>
<td>10 - 현재 활성 상태인 모든 커넥션이 사용 중입니다.</td>
</tr>
<tr>
<td>idleConnections</td>
<td>0 - 유휴 상태의 커넥션은 없습니다.</td>
</tr>
<tr>
<td>threadsAwaitingConnection</td>
<td>84 - 84개의 스레드가 커넥션을 기다리고 있습니다.</td>
</tr>
<tr>
<td>maxLifetime</td>
<td>1800000 (밀리초) - 커넥션의 최대 수명입니다.</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>10 - 최대 커넥션 풀 크기가 10으로 설정되어 있습니다.</td>
</tr>
<tr>
<td>minimumIdle</td>
<td>10 - 최소 유휴 커넥션이 10으로 설정되어 있습니다.</td>
</tr>
<tr>
<td>connectionTimeout</td>
<td>30000 (밀리초) - 커넥션을 얻기 위해 대기할 수 있는 최대 시간입니다.</td>
</tr>
<tr>
<td>validationTimeout</td>
<td>5000 (밀리초) - 커넥션 유효성 검사를 위한 시간입니다.</td>
</tr>
<tr>
<td>idleTimeout</td>
<td>600000 (밀리초) - 유휴 커넥션을 유지하는 최대 시간입니다.</td>
</tr>
</tbody>
</table>
<p>이 로그는 커넥션 풀이 한계에 도달하여 더 이상 커넥션을 확장할 수 없고, 여러 스레드가 커넥션을 기다리면서 성능 저하가 발생하고 있음을 보여줍니다.</p>
<h3><span id="munje-weonin">문제 원인</span><a href="#munje-weonin" class="header-anchor">#</a></h3>
<ol>
<li><strong>커넥션 풀 크기 제한</strong>: 현재 <code>maximum-pool-size</code>가 10으로 설정되어 있어 초당 12개 이상의 요청(TPS)을 처리하기에는 커넥션 풀 크기가 부족합니다. 모든 커넥션이 이미 사용 중이기 때문에, 추가적인 요청이 들어오면 커넥션을 기다리게 되고, 이로 인해 요청 실패가 발생하거나 응답 시간이 길어집니다.</li>
<li><strong>스레드 대기</strong>: 커넥션 풀이 최대 용량에 도달하면서 <code>threadsAwaitingConnection</code> 수가 증가하게 됩니다. 이는 커넥션을 얻지 못한 요청이 대기 상태로 전환되는 상황을 나타내며, TPS가 증가할 때 시스템이 추가 요청을 즉각적으로 처리하지 못하고 성능 저하를 초래하는 주요 원인이 됩니다.</li>
<li><strong>connectionTimeout 설정</strong>: 현재 <code>connectionTimeout</code>이 30000밀리초(30초)로 설정되어 있어, 커넥션을 기다리는 요청은 최대 30초까지 대기할 수 있습니다. 그러나 이 대기 시간이 길어질수록 전체 응답 시간이 증가하게 되며, 대기 중인 요청이 많아지면 TPS가 상승하기 어려워지고 응답 지연으로 인한 성능 저하가 발생할 수 있습니다.</li>
</ol>
<p>이러한 문제들은 TPS가 높아질수록 커넥션 풀의 제한으로 인해 전체적인 성능 저하가 발생하게 되는 이유입니다.</p>
<h2><span id="haegyeol-bangan">해결 방안</span><a href="#haegyeol-bangan" class="header-anchor">#</a></h2>
<ol>
<li><strong>maximum-pool-size 증가</strong>: 현재의 TPS 수요를 충족하기 위해 <code>maximum-pool-size</code> 값을 늘려야 합니다. 예를 들어, 10 이상으로 설정하여 커넥션 풀이 더 많은 요청을 처리할 수 있도록 하면, 요청 대기 시간과 실패를 줄일 수 있습니다.</li>
<li><strong>동적 커넥션 관리</strong>: HikariCP의 특성을 활용해 <code>minimum-idle</code>과 <code>maximum-pool-size</code>를 적절히 조정하여 트래픽 변화에 유연하게 대응할 수 있도록 합니다. TPS가 높아질 때는 커넥션 풀이 자동으로 확장되도록 하고, TPS가 감소할 때는 최소한의 커넥션만 유지해 리소스를 절약하도록 설정하는 것이 좋습니다.</li>
<li><strong>모니터링 및 지속적인 튜닝</strong>: 커넥션 풀의 상태를 지속적으로 모니터링하여, 트래픽 패턴에 맞게 적절히 튜닝하는 것이 필요합니다. 정기적인 모니터링을 통해 TPS와 응답 시간 변화를 관찰하고, 필요에 따라 <code>maximum-pool-size</code>, <code>connectionTimeout</code> 등의 설정을 조정하여 최적의 성능을 유지할 수 있습니다.</li>
</ol>
<p>이러한 방안들은 트래픽 변동에 따라 유연하게 커넥션 풀을 관리하고, 시스템 성능을 최적화하는 데 도움이 됩니다.</p>
<h3><span id="seongneung-teseuteu-gyeolgwa-bunseog-maximum-pool-sizereul-200euro-jojeonghan-gyeongu">성능 테스트 결과 분석: maximum-pool-size를 200으로 조정한 경우</span><a href="#seongneung-teseuteu-gyeolgwa-bunseog-maximum-pool-sizereul-200euro-jojeonghan-gyeongu" class="header-anchor">#</a></h3>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">hikari:</span></span><br><span class="line">            <span class="attr">maximum-pool-size:</span> <span class="number">200</span>           <span class="comment"># 최대 커넥션 수</span></span><br><span class="line">            <span class="attr">minimum-idle:</span> <span class="number">10</span>                 <span class="comment"># 최소 유휴 커넥션 수</span></span><br></pre></td></tr></table></figure>
<p>위와 같이 <code>maximum-pool-size</code>를 200, <code>minimum-idle</code>을 10으로 설정하여 테스트를 진행한 결과, 커넥션 풀이 충분히 확장 가능해지면서 시스템 성능이 크게 개선되었습니다. 주요 개선 사항은 다음과 같습니다.</p>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-1-2.png" alt></p>
<ul>
<li><strong>Total Requests per Second (RPS)</strong>:
<ul>
<li>RPS가 점진적으로 증가하여 높은 TPS를 안정적으로 처리할 수 있게 되었습니다. 초당 요청 처리량이 약 150까지 증가했음에도 불구하고, 실패한 요청(Failures/s)은 발생하지 않았습니다.</li>
<li>이는 커넥션 풀이 충분히 확장되어, 모든 요청이 처리되는 동안 커넥션 부족으로 인한 대기 시간이 발생하지 않았음을 의미합니다.</li>
</ul>
</li>
<li><strong>Response Times</strong>:
<ul>
<li>응답 시간 그래프에서 50th 및 95th 퍼센타일 응답 시간이 비교적 안정적인 수준을 유지하고 있습니다.</li>
<li>95th 퍼센타일 응답 시간은 약 3,000ms 이하로, 50th 퍼센타일은 약 1,000ms 내외로 유지되었습니다. 이는 고TPS 상황에서도 일관된 응답 속도를 제공할 수 있음을 보여줍니다.</li>
<li>이전 설정에서 발생했던 응답 시간의 급격한 증가가 해소되어, 사용자 경험이 크게 개선되었습니다.</li>
</ul>
</li>
<li><strong>Failures/s 비율</strong>:
<ul>
<li>요청 실패율이 0으로 유지되었습니다. <code>maximum-pool-size</code>를 200으로 설정한 덕분에, <code>connectionTimeout</code>으로 인해 대기 상태에서 실패하는 요청이 없었습니다.</li>
<li>이로써 고TPS 상황에서도 안정적인 서비스가 가능해졌으며, 대량의 동시 요청을 처리하는 데 적합한 환경이 조성되었습니다.</li>
</ul>
</li>
</ul>
<h3><span id="rogeu-bunseog">로그 분석</span><a href="#rogeu-bunseog" class="header-anchor">#</a></h3>
<table>
<thead>
<tr>
<th>필드</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>totalConnections</td>
<td>152 - 현재 총 152개의 커넥션이 생성되었습니다.</td>
</tr>
<tr>
<td>activeConnections</td>
<td>152 - 모든 커넥션이 활성 상태로 사용 중입니다.</td>
</tr>
<tr>
<td>idleConnections</td>
<td>0 - 유휴 상태의 커넥션은 없습니다.</td>
</tr>
<tr>
<td>threadsAwaitingConnection</td>
<td>48 - 48개의 스레드가 커넥션을 기다리고 있습니다.</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>200 - 최대 커넥션 풀 크기가 200으로 설정되었습니다.</td>
</tr>
<tr>
<td>minimumIdle</td>
<td>10 - 최소 유휴 커넥션이 10으로 설정되어 있어, 초기에 모든 커넥션이 생성된 상태입니다.</td>
</tr>
</tbody>
</table>
<p>이 설정을 통해 커넥션 풀은 트래픽이 적을 때에는 최소한의 자원만 사용하고, 트래픽이 증가할 때에는 최대 200개의 커넥션까지 확장하여 요청을 처리할 수 있습니다. 로그에서 볼 수 있듯이 TPS가 높은 상황에서도 커넥션 풀이 충분히 확장되었고, 전체적인 시스템 성능에는 큰 영향을 미치지 않았습니다. 이를 통해 시스템은 높은 TPS 환경에서도 안정적이고 일관된 성능을 제공할 수 있음을 확인할 수 있습니다.</p>
<h2><span id="seongneung-teseuteu-gyeolgwa-bunseog-tps-gamso-sanghwangeseoyi-keonegsyeon-pul-dongjag">성능 테스트 결과 분석: TPS 감소 상황에서의 커넥션 풀 동작</span><a href="#seongneung-teseuteu-gyeolgwa-bunseog-tps-gamso-sanghwangeseoyi-keonegsyeon-pul-dongjag" class="header-anchor">#</a></h2>
<p>아래 설정으로 TPS가 낮아진 상황에서 성능 테스트를 진행했습니다.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">hikari:</span></span><br><span class="line">            <span class="attr">maximum-pool-size:</span> <span class="number">200</span>           <span class="comment"># 최대 커넥션 수</span></span><br><span class="line">            <span class="attr">minimum-idle:</span> <span class="number">10</span>                 <span class="comment"># 최소 유휴 커넥션 수</span></span><br><span class="line">            <span class="attr">max-lifetime:</span> <span class="number">300000</span>             <span class="comment"># 커넥션이 유지될 최대 시간 (밀리초)</span></span><br><span class="line">            <span class="attr">idle-timeout:</span> <span class="number">250000</span>             <span class="comment"># 유휴 커넥션이 유지될 최대 시간 (밀리초)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>max-lifetime</strong>: 기본값은 1800000ms (30분)입니다. 각 커넥션이 일정 시간 동안만 유지된 후 새 커넥션으로 교체되도록 하여, 오래된 커넥션으로 인해 발생할 수 있는 문제를 방지합니다. 설정된 시간(예: 300,000ms = 5분) 이후에 커넥션은 제거되고 새로운 커넥션으로 대체됩니다.</li>
<li><strong>idle-timeout</strong>: 기본값은 600000ms (10분)입니다. 유휴 상태의 커넥션이 설정된 시간 동안 사용되지 않으면 커넥션 풀에서 제거됩니다. 트래픽이 감소한 상황에서는 유휴 커넥션이 줄어들어 리소스가 절약됩니다. 위 설정에서는 250,000ms 동안 유휴 상태인 커넥션을 유지하고 이후에 해제하도록 설정했습니다.</li>
</ul>
<h3><span id="teseuteu-gyeolgwa-bunseog">테스트 결과 분석</span><a href="#teseuteu-gyeolgwa-bunseog" class="header-anchor">#</a></h3>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-1-3.png" alt></p>
<ul>
<li><strong>Total Requests per Second (RPS)</strong>:
<ul>
<li>TPS가 낮아지며, 초당 요청 처리량이 약 5 수준으로 안정화되었습니다.</li>
<li>요청 실패(Failures/s)가 발생하지 않았으며, 모든 요청이 성공적으로 처리되었습니다.</li>
<li>이는 트래픽이 줄어들면서 커넥션 풀이 유휴 상태로 돌아가고 있음을 의미합니다.</li>
</ul>
</li>
<li><strong>Response Times</strong>:
<ul>
<li>50th 및 95th 퍼센타일 응답 시간 모두 약 1,000ms 내외로 일정하게 유지되고 있습니다.</li>
<li>응답 시간의 변동이 크지 않고 안정적인 수준을 보여, TPS가 낮아진 상황에서도 일관된 성능을 제공하고 있습니다.</li>
</ul>
</li>
<li><strong>Number of Users</strong>:
<ul>
<li>테스트에서 사용자 수가 10명으로 일정하게 유지되고 있으며, TPS가 낮은 상태로 안정화되었습니다.</li>
</ul>
</li>
</ul>
<h3><span id="rogeu-bunseog">로그 분석</span><a href="#rogeu-bunseog" class="header-anchor">#</a></h3>
<table>
<thead>
<tr>
<th>필드</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>totalConnections</td>
<td>15 - 현재 총 15개의 커넥션이 생성되었습니다. 트래픽 감소에 따라 필요 없는 커넥션이 자동으로 해제되며, 풀 크기가 줄어든 상태입니다.</td>
</tr>
<tr>
<td>activeConnections</td>
<td>6 - 현재 활성 상태로 사용 중인 커넥션이 6개입니다.</td>
</tr>
<tr>
<td>idleConnections</td>
<td>9 - 최소 유휴 커넥션 설정(<code>minimumIdle</code>)이 10이므로, 트래픽이 줄어든 상황에서 9개의 유휴 커넥션이 유지됩니다.</td>
</tr>
<tr>
<td>threadsAwaitingConnection</td>
<td>0 - 대기 중인 스레드가 없어 모든 요청이 즉시 처리되고 있습니다.</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>200 - 최대 커넥션 풀 크기가 200으로 설정되어 있지만, 현재 트래픽 수준에서는 전체를 사용할 필요 없이 적정 개수의 커넥션만 유지하고 있습니다.</td>
</tr>
<tr>
<td>minimumIdle</td>
<td>10 - 최소 유휴 커넥션 수가 10으로 설정되어, 트래픽이 적을 때도 최소한의 커넥션을 유지해 자원을 절약합니다.</td>
</tr>
<tr>
<td>maxLifetime</td>
<td>300000 (밀리초) - 각 커넥션이 5분(300초) 동안 유지된 후 자동으로 갱신되도록 설정되어 있어, 오래된 커넥션으로 인한 문제를 방지하고 안정적인 연결 상태를 보장합니다.</td>
</tr>
<tr>
<td>idleTimeout</td>
<td>250000 (밀리초) - 유휴 상태의 커넥션이 4분 10초 동안 사용되지 않으면 풀에서 해제됩니다. 이를 통해 트래픽이 감소한 상황에서는 유휴 커넥션을 줄여 리소스를 절약할 수 있습니다.</td>
</tr>
</tbody>
</table>
<p>이 테스트 결과는 TPS가 줄어들면 <code>totalConnections</code>도 함께 감소하며 리소스가 효율적으로 관리되는 모습을 보여줍니다. <code>minimum-idle</code> 설정을 통해 커넥션 풀이 최소 10개의 유휴 커넥션을 유지하고, <code>idleTimeout</code>이 설정된 시간 동안 유휴 상태인 커넥션을 자동으로 해제하여 불필요한 자원 낭비를 방지합니다. 또한 <code>maxLifetime</code> 설정으로 각 커넥션의 유지 시간을 제한하여 일정 시간이 지나면 커넥션이 새롭게 갱신되도록 함으로써 오래된 커넥션으로 인한 문제를 예방합니다. 이를 통해 시스템은 트래픽 변화에 유연하게 대응하며 안정적으로 자원을 관리할 수 있는 구조를 갖추게 됩니다.</p>
<h2><span id="gyeolron">결론</span><a href="#gyeolron" class="header-anchor">#</a></h2>
<p>HikariCP를 사용한 커넥션 풀 설정은 트래픽 변화에 유연하게 대응할 수 있으며, 성능 최적화를 위해 중요한 도구가 됩니다. 적절한 <code>maximum-pool-size</code>와 <code>minimum-idle</code> 설정을 통해 고TPS 환경에서도 안정적이고 일관된 응답 시간을 제공할 수 있으며, 리소스를 효율적으로 관리하여 비용 절감 효과도 기대할 수 있습니다. 이를 통해 Spring Boot 애플리케이션은 다양한 트래픽 상황에서 성능을 최적화하며, 사용자 경험을 크게 개선할 수 있습니다.</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">태그</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/Connection-Pool/" rel="tag">Connection Pool</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/MySQL/" rel="tag">MySQL</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/Performance/" rel="tag">Performance</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/kotlin-pattern-2/"
                    data-tooltip="Kotlin 객체 생성의 안전성과 유효성 강화하기"
                    aria-label="이전: Kotlin 객체 생성의 안전성과 유효성 강화하기"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/mysql-connection-pool-timeout/"
                    data-tooltip="MySQL Connection Pool 관리 - HikariCP 설정 및 타임아웃 처리"
                    aria-label="다음: MySQL Connection Pool 관리 - HikariCP 설정 및 타임아웃 처리"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/mysql-connection-pool-timeout-1/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/mysql-connection-pool-timeout-1/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        

                
                    <!--  utteranc comment -->

<script src="https://utteranc.es/client.js"
        repo="cheese10yun/blog-comment"
        issue-term="title"
        label="Comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

                

            
        
    </div>
</article>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Yun. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/kotlin-pattern-2/"
                    data-tooltip="Kotlin 객체 생성의 안전성과 유효성 강화하기"
                    aria-label="이전: Kotlin 객체 생성의 안전성과 유효성 강화하기"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/mysql-connection-pool-timeout/"
                    data-tooltip="MySQL Connection Pool 관리 - HikariCP 설정 및 타임아웃 처리"
                    aria-label="다음: MySQL Connection Pool 관리 - HikariCP 설정 및 타임아웃 처리"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/mysql-connection-pool-timeout-1/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/mysql-connection-pool-timeout-1/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="5">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/mysql-connection-pool-timeout-1/"
                        aria-label="Facebook에 공유하기"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Facebook에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/mysql-connection-pool-timeout-1/"
                        aria-label="Twitter에 공유하기"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Twitter에 공유하기</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
            <h4 id="about-card-name">Yun</h4>
        
            <div id="about-card-bio"><p>기술 블로그</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
