
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="naver-site-verification" content="a37ea649edf26e70c3de94f9cb034f9d6e11de3f" />
    <meta name="generator" content="Yun Blog">
    <title>Spring Data MongoDB에서의 Update 전략과 경험 - Yun Blog</title>
    <meta name="author" content="Yun">
    
        <meta name="keywords" content="Node,Spring,Spring Boot,Spring Batch,Kotlin,기술 블로그,JPA,Mongo,MySQL,OOP,">
    
    
    
        
            <link rel="alternate" type="application/rss+xml" title="RSS" href="/rss2.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg"},"articleBody":"Spring Data MongoDB를 활용한 애플리케이션 개발 과정에서, 데이터를 업데이트하는 방법은 프로젝트의 설계와 성능에 큰 영향을 미칩니다. 특히, mongoRepository.save, mongoTemplate.save, 그리고 mongoTemplate.updateFirst와 같은 메서드들은 각각의 특성과 적합한 상황이 다릅니다. 이 글에서는 Spring Data MongoDB에서 업데이트 전략을 중심으로 개발 경험에서 얻은 인사이트를 공유하며, 각 메서드의 동작 방식과 적절한 사용 방법에 대해 논의합니다.\nUpdate 메서드 비교Spring Data MongoDB에서 사용되는 주요 업데이트 메서드들은 아래와 같이 동작 방식과 적합한 시나리오에서 차이가 있습니다:\n\n\n\n특징\nmongoRepository.save\nmongoTemplate.save\nmongoTemplate.updateFirst\n\n\n\n작업 대상\n단일 문서\n단일 문서\n단일 문서\n\n\n저장 방식\n변경된 필드만 업데이트\n전체 문서 교체\n변경된 필드만 업데이트\n\n\n문서가 없을 경우\n새로 삽입\n새로 삽입\n기본적으로 아무 작업도 수행하지 않음\n\n\n업데이트 범위\n필드 단위\n전체 문서\n필드 단위\n\n\n조건 지정\n_id 기준\n_id 기준\n사용자 정의 쿼리\n\n\nSpring Data 통합\n페이징, 정렬 등 지원\n미지원\n미지원\n\n\n적합한 상황\n간단한 CRUD 작업\n전체 문서 교체 또는 삽입\n조건에 맞는 단일 문서 필드 수정\n\n\nmongoTemplate.save문서 전체 교체(Replace)를 수행합니다.\n동작 방식\n_id 필드를 기준으로 MongoDB에서 문서를 검색.\n문서가 존재하면 전체 문서를 교체합니다.\n문서가 존재하지 않으면 새로 삽입합니다.\n저장 객체에 없는 필드는 기존 문서에서 삭제됩니다.\n\n예제12val user = User(id = &quot;123&quot;, name = &quot;John Doe&quot;, age = 30)mongoTemplate.save(user)\n\n결과\n기존 문서: &#123; &quot;_id&quot;: &quot;123&quot;, &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25, &quot;email&quot;: &quot;alice@example.com&quot; &#125;\n업데이트 후: &#123; &quot;_id&quot;: &quot;123&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 30 &#125;\n변경 사항: email 필드가 삭제됨.\n\nmongoRepository.save문서의 일부 필드만 업데이트(Partial Update)를 수행합니다.\n동작 방식\n_id 필드를 기준으로 MongoDB에서 문서를 검색.\n문서가 존재하면 변경된 필드만 업데이트하고, 나머지 필드는 유지됩니다.\n문서가 존재하지 않으면 새로 삽입합니다.\n\n예제12val user = User(id = &quot;123&quot;, name = &quot;John Doe&quot;)userRepository.save(user)\n\n결과\n기존 문서: &#123; &quot;_id&quot;: &quot;123&quot;, &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25, &quot;email&quot;: &quot;alice@example.com&quot; &#125;\n업데이트 후: &#123; &quot;_id&quot;: &quot;123&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 25, &quot;email&quot;: &quot;alice@example.com&quot; &#125;\n변경 사항: name 필드만 업데이트, 나머지 필드는 유지됨.\n\nmongoTemplate.updateFirstMongoDB의 updateFirst 명령어를 실행하여 단일 문서를 부분 업데이트합니다.\n동작 방식\n조건을 지정하여 MongoDB에서 문서를 검색.\n첫 번째로 매칭된 문서의 일부 필드만 업데이트합니다.\n문서가 존재하지 않으면 기본적으로 아무 작업도 수행하지 않습니다(삽입하지 않음).\n$set과 같은 MongoDB 연산자를 사용하여 지정된 필드만 업데이트합니다.\n\n예제123val query = Query(Criteria.where(&quot;name&quot;).`is`(&quot;Alice&quot;))val update = Update().set(&quot;age&quot;, 30)mongoTemplate.updateFirst(query, update, User::class.java)\n\n결과\n기존 문서: &#123; &quot;_id&quot;: &quot;123&quot;, &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25, &quot;email&quot;: &quot;alice@example.com&quot; &#125;\n업데이트 후: &#123; &quot;_id&quot;: &quot;123&quot;, &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30, &quot;email&quot;: &quot;alice@example.com&quot; &#125;\n변경 사항: age 필드만 업데이트, 나머지 필드는 유지됨.\n\n효율적인 MongoDB 업데이트 전략mongoTemplate.save는 문서 전체를 교체하기 때문에 일반적인 경우에는 거의 사용되지 않습니다. 반면, mongoRepository.save는 더 직관적이며, 특히 Spring Data JPA 경험이 있는 개발자에게는 익숙하고 이해하기 쉬운 방식입니다. 그럼에도 불구하고, 저는 업데이트 작업에 mongoTemplate기반의 업데이트만을 사용하고 있습니다. 그 이유는 다음과 같습니다.\n대량 처리에서의 성능 차이MongoDB Update 성능 측정 및 분석에서 업데이트 성능을 측정한 결과를 참고할 수 있습니다.\n\n\n\n\nRows\nsaveAll\nupdateFirst\nbulkOps (UNORDERED)\nbulkOps (ORDERED)\n\n\n\n100\n1,052 ms\n1,176 ms\n46 ms\n79 ms\n\n\n200\n2,304 ms\n2,196 ms\n103 ms\n124 ms\n\n\n500\n5,658 ms\n5,250 ms\n309 ms\n257 ms\n\n\n1,000\n11,106 ms\n10,846 ms\n418 ms\n412 ms\n\n\n2,000\n22,592 ms\n21,427 ms\n1,060 ms\n1,004 ms\n\n\n5,000\n54,407 ms\n52,075 ms\n2,663 ms\n2,292 ms\n\n\n10,000\n107,651 ms\n110,884 ms\n4,514 ms\n4,496 ms\n\n\nsaveAll 방식은 각 문서의 _id를 확인하여 데이터베이스에 해당 문서가 존재하는지 판단합니다. 존재하는 경우에는 이를 업데이트로 인식하고, 내부적으로 반복문을 돌면서 save를 개별적으로 호출합니다. 이로 인해 각 문서에 대해 별도의 데이터베이스 요청이 발생하며, 처리 성능이 문서 수에 비례하여 저하될 수 있습니다. 특히, 요청 수가 많아질수록 이러한 방식은 응답 시간이 급격히 증가하는 원인이 됩니다.\n반면, bulkOps는 여러 업데이트 작업을 한 번의 연산으로 묶어서 실행하므로 대량 처리에서 훨씬 효율적입니다. 이를 통해 처리 시간을 크게 단축할 수 있지만, save와 saveAll 방식으로는 bulkOps를 활용할 수 없다는 한계가 있습니다. 이러한 이유로 저는 대량 처리 작업에서 updateFirst와 함께 bulkOps를 활용하는 방식을 선호합니다.\n또한, 대량 데이터를 업데이트할 때 where in 절을 활용하면 효과적입니다. 이 경우, mongoTemplate.updateMulti를 사용하면 bulkOps 방식과 유사한 성능을 얻을 수 있습니다. saveAll을 사용하면 성능이 급격히 저하되므로, 대량 데이터를 업데이트할 때는 반드시 mongoTemplate을 사용하는 것이 좋습니다. 이러한 접근 방식은 대량 처리의 효율성과 성능 최적화를 보장하며, 대량 데이터를 다루는 애플리케이션에서 더욱 유용합니다.\n명확한 변경 사항 추적mongoRepository.save를 사용하여 데이터를 업데이트할 경우, 정확히 어떤 필드가 변경되었는지 추적하기 어렵습니다. MongoDB는 비정형 데이터베이스로, 다양한 필드와 그 필드들이 다루는 컨텍스트가 매우 다양합니다. 이런 상황에서 mongoRepository.save를 통해 업데이트가 이루어지면, 어떤 필드가 어떤 조건에서 업데이트되었는지 명확히 파악하기 어렵기 때문에 데이터 변경 사항을 추적하고 관리하는 데 어려움이 발생할 수 있습니다.\n반면, mongoTemplate을 기반으로 업데이트 쿼리를 작성하면 특정 필드에 대해 명확히 정의된 업데이트를 수행할 수 있습니다. 각 업데이트가 어디에서 이루어졌는지, 어떤 필드가 변경되었는지를 코드 레벨에서 명확히 확인할 수 있어 추적이 용이합니다. 특히 프로젝트가 복잡해지거나 엄격한 변경 관리가 요구될수록, 이러한 명확성은 유지보수와 협업 측면에서 큰 장점으로 작용합니다. 이를 통해 데이터 업데이트의 불확실성을 줄이고, 코드의 가독성과 신뢰성을 높일 수 있습니다.\n실제 사용 예시Document 정의1234567891011121314151617@Document(collection = &quot;members&quot;)class Member(    @Field(name = &quot;name&quot;)    val name: String,    @Field(name = &quot;address&quot;)    val address: Address,    @Field(name = &quot;member_id&quot;)    val memberId: String,    @Field(name = &quot;email&quot;)    val email: String,    @Field(name = &quot;status&quot;)    val status: MemberStatus) : Auditable()\n\n위 예시와 같이 Member 도큐먼트가 정의되어 있다고 가정하겠습니다. 이 도큐먼트는 MongoRepository를 사용하여 업데이트하지 않기 때문에, 필드들이 val로 지정되어 있습니다. 필드를 val로 지정하면 도큐먼트의 특정 필드를 변경하기 위해 객체를 직접 수정한 뒤 save를 호출하는 방식이 불가능합니다. 이렇게 필드를 val로 지정하면 도큐먼트의 불변성을 보장하며, 특정 필드의 변경을 엄격히 관리할 수 있습니다.\nRepository 정의12345678910111213141516171819interface MemberRepository : MongoRepository&lt;Member, ObjectId&gt;, MemberCustomRepositoryinterface MemberCustomRepository &#123;    fun updateName(targets: List&lt;MemberQueryForm.UpdateName&gt;)&#125;class MemberCustomRepositoryImpl(mongoTemplate: MongoTemplate) : MemberCustomRepository, MongoCustomRepositorySupport&lt;Member&gt;(Member::class.java, mongoTemplate) &#123;    override fun updateName(targets: List&lt;MemberQueryForm.UpdateName&gt;) &#123;        bulkUpdate(            targets.map &#123;                Pair(                    &#123; Query(Criteria.where(&quot;id&quot;).`is`(it.id)) &#125;,                    &#123; Update().set(&quot;name&quot;, it.name) &#125;                )            &#125;        )    &#125;&#125;\n\nMongoCustomRepositorySupport를 상속받아 bulkUpdate 메서드를 통해 bulkOps를 사용한 대량 업데이트를 수행합니다. 이를 활용하면 대량 데이터를 효율적으로 처리할 수 있으며, 단일 업데이트만 필요한 경우 updateFirst를 사용하여 업데이트를 수행할 수도 있습니다. 그러나 특별한 이유가 없다면 MongoCustomRepositorySupport 기반으로 대량 업데이트를 지원하는 bulkUpdate를 사용하는 것을 권장합니다.\n이 방식에 대한 자세한 구현 방법은 이전 포스팅 MongoDB Update 성능 측정 및 분석 - MongoCustomRepositorySupport을 통한 bulkOps 기능 제공에서 확인할 수 있습니다.\n업데이트 쿼리에 사용할 객체 정의123456object MemberQueryForm &#123;    data class UpdateName(        val id: ObjectId,        val name: String    )&#125;\n\nMemberQueryForm 객체를 정의하여 쿼리에 필요한 필드와 데이터를 명확하게 관리합니다. 이를 통해 업데이트 작업에서 어떤 필드가 업데이트되는지 명확히 파악할 수 있습니다. 만약 MemberQueryForm에 정의되지 않은 필드가 있다면, 해당 필드는 현재 업데이트 대상이 아니거나 정책적으로 업데이트되지 않는 필드라고 간주할 수 있습니다.\n테스트 코드 예시1234567891011121314151617181920212223242526272829303132333435@MongoTestSupportclass MemberRepositoryTest(    private val memberRepository: MemberRepository) : MongoStudyApplicationTests() &#123;    @Test    fun `updateName test`() &#123;        // given        val members = (1..20).map &#123;            Member(                name = &quot;name&quot;,                ...            )        &#125;        val targets = mongoTemplate            .insertAll(members).map &#123;                MemberQueryForm.UpdateName(                    id = it.id!!,                    name = &quot;newName&quot;                )            &#125;        // when        memberRepository.updateName(targets)        // then        val results = mongoTemplate.findAll&lt;Member&gt;()        then(results).hasSize(20)        then(results).allSatisfy &#123;            then(it.name).isEqualTo(&quot;newName&quot;)        &#125;    &#125;&#125;\n\n해당 테스트 코드는 MemberRepository의 updateName 메서드를 검증합니다.\n\n먼저 Member 객체를 생성하고 MongoDB에 저장한 뒤, 저장된 데이터를 조회하여 UpdateName 객체를 생성합니다.\n이후 updateName 메서드를 호출하여 업데이트를 수행합니다.\n마지막으로 MongoDB에서 데이터를 다시 조회해, 업데이트가 성공적으로 이루어졌는지 확인합니다.\n\n이처럼 MemberQueryForm 객체를 사용해 업데이트 대상 필드를 명확히 정의함으로써, 변경 작업의 범위를 명확히 관리하고 추적할 수 있습니다. 테스트 코드 역시 이러한 명확성을 기반으로 업데이트 로직을 확인하도록 작성되었습니다.\n정리제가 담당하는 도메인은 특정 필드마다 업데이트 권한이 다르게 설정되어 있어, 업데이트 필드를 보다 명확하고 엄격하게 관리해야 하는 상황입니다. 또한, 대량의 데이터를 처리해야 하며, 빠른 처리를 보장해야 하는 요구사항도 있습니다. 이러한 이유로, 위에서 설명한 방식의 업데이트 전략을 선택했습니다. 각자의 상황과 요구사항에 맞는 적절한 방법을 선택하는 것이 가장 중요합니다.\n","dateCreated":"2025-01-18T00:00:00+09:00","dateModified":"2025-01-31T04:41:33+09:00","datePublished":"2025-01-18T00:00:00+09:00","description":"이 글에서는 Spring Data MongoDB에서 업데이트 전략을 중심으로 개발 경험에서 얻은 인사이트를 공유하며, 각 메서드의 동작 방식과 적절한 사용 방법에 대해 논의합니다.","headline":"Spring Data MongoDB에서의 Update 전략과 경험","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://cheese10yun.github.io/spring-data-mongo-update-guide-1/"},"publisher":{"@type":"Organization","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg","logo":{"@type":"ImageObject","url":"yun-icon.jpg"}},"url":"https://cheese10yun.github.io/spring-data-mongo-update-guide-1/","keywords":"Guide, Performance, Mongo"}</script>
    <meta name="description" content="이 글에서는 Spring Data MongoDB에서 업데이트 전략을 중심으로 개발 경험에서 얻은 인사이트를 공유하며, 각 메서드의 동작 방식과 적절한 사용 방법에 대해 논의합니다.">
<meta property="og:type" content="blog">
<meta property="og:title" content="Spring Data MongoDB에서의 Update 전략과 경험">
<meta property="og:url" content="https://cheese10yun.github.io/spring-data-mongo-update-guide-1/index.html">
<meta property="og:site_name" content="Yun Blog">
<meta property="og:description" content="이 글에서는 Spring Data MongoDB에서 업데이트 전략을 중심으로 개발 경험에서 얻은 인사이트를 공유하며, 각 메서드의 동작 방식과 적절한 사용 방법에 대해 논의합니다.">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/5fc6127a0800ca9bce5de5a6c73931b2025b0791/mongo-study/images/performance-update.png">
<meta property="article:published_time" content="2025-01-17T15:00:00.000Z">
<meta property="article:modified_time" content="2025-01-30T19:41:33.783Z">
<meta property="article:author" content="Yun">
<meta property="article:tag" content="Guide">
<meta property="article:tag" content="Performance">
<meta property="article:tag" content="Mongo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/5fc6127a0800ca9bce5de5a6c73931b2025b0791/mongo-study/images/performance-update.png">
    
    
        
    
    
        <meta property="og:image" content="https://cheese10yun.github.io/assets/images/yun-icon.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90907312-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-90907312-1');
    </script>


    

    
        
    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5813739623204880" crossorigin="anonymous"></script>
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="5">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Yun Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="링크 열기: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="5">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="저자에 대해 더 알아보기"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
                </a>
                <h4 class="sidebar-profile-name">Yun</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기술 블로그</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="카테고리"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">카테고리</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="태그"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="아카이브"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">아카이브</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="검색"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">검색</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/cheese10yun"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/rss2.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="5"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Spring Data MongoDB에서의 Update 전략과 경험
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2025-01-18T00:00:00+09:00">
	
		    2025/01/18
    	
    </time>
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>Spring Data MongoDB를 활용한 애플리케이션 개발 과정에서, 데이터를 업데이트하는 방법은 프로젝트의 설계와 성능에 큰 영향을 미칩니다. 특히, <code>mongoRepository.save</code>, <code>mongoTemplate.save</code>, 그리고 <code>mongoTemplate.updateFirst</code>와 같은 메서드들은 각각의 특성과 적합한 상황이 다릅니다. 이 글에서는 Spring Data MongoDB에서 <strong>업데이트 전략</strong>을 중심으로 개발 경험에서 얻은 인사이트를 공유하며, 각 메서드의 동작 방식과 적절한 사용 방법에 대해 논의합니다.</p>
<h2 id="Update-메서드-비교"><a href="#Update-메서드-비교" class="headerlink" title="Update 메서드 비교"></a>Update 메서드 비교</h2><p>Spring Data MongoDB에서 사용되는 주요 업데이트 메서드들은 아래와 같이 동작 방식과 적합한 시나리오에서 차이가 있습니다:</p>
<table>
<thead>
<tr>
<th><strong>특징</strong></th>
<th><strong>mongoRepository.save</strong></th>
<th><strong>mongoTemplate.save</strong></th>
<th><strong>mongoTemplate.updateFirst</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>작업 대상</strong></td>
<td>단일 문서</td>
<td>단일 문서</td>
<td>단일 문서</td>
</tr>
<tr>
<td><strong>저장 방식</strong></td>
<td>변경된 필드만 업데이트</td>
<td>전체 문서 교체</td>
<td>변경된 필드만 업데이트</td>
</tr>
<tr>
<td><strong>문서가 없을 경우</strong></td>
<td>새로 삽입</td>
<td>새로 삽입</td>
<td>기본적으로 아무 작업도 수행하지 않음</td>
</tr>
<tr>
<td><strong>업데이트 범위</strong></td>
<td>필드 단위</td>
<td>전체 문서</td>
<td>필드 단위</td>
</tr>
<tr>
<td><strong>조건 지정</strong></td>
<td><code>_id</code> 기준</td>
<td><code>_id</code> 기준</td>
<td>사용자 정의 쿼리</td>
</tr>
<tr>
<td><strong>Spring Data 통합</strong></td>
<td>페이징, 정렬 등 지원</td>
<td>미지원</td>
<td>미지원</td>
</tr>
<tr>
<td><strong>적합한 상황</strong></td>
<td>간단한 CRUD 작업</td>
<td>전체 문서 교체 또는 삽입</td>
<td>조건에 맞는 단일 문서 필드 수정</td>
</tr>
</tbody></table>
<h3 id="mongoTemplate-save"><a href="#mongoTemplate-save" class="headerlink" title="mongoTemplate.save"></a>mongoTemplate.save</h3><p>문서 전체 교체(Replace)를 수행합니다.</p>
<h4 id="동작-방식"><a href="#동작-방식" class="headerlink" title="동작 방식"></a>동작 방식</h4><ul>
<li><code>_id</code> 필드를 기준으로 MongoDB에서 문서를 검색.</li>
<li>문서가 존재하면 <strong>전체 문서를 교체</strong>합니다.</li>
<li>문서가 존재하지 않으면 새로 삽입합니다.</li>
<li>저장 객체에 없는 필드는 기존 문서에서 삭제됩니다.</li>
</ul>
<h4 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> user = User(id = <span class="string">&quot;123&quot;</span>, name = <span class="string">&quot;John Doe&quot;</span>, age = <span class="number">30</span>)</span><br><span class="line">mongoTemplate.save(user)</span><br></pre></td></tr></table></figure>

<h4 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h4><ul>
<li>기존 문서: <code>&#123; &quot;_id&quot;: &quot;123&quot;, &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25, &quot;email&quot;: &quot;alice@example.com&quot; &#125;</code></li>
<li>업데이트 후: <code>&#123; &quot;_id&quot;: &quot;123&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 30 &#125;</code></li>
<li>변경 사항: <code>email</code> 필드가 삭제됨.</li>
</ul>
<h3 id="mongoRepository-save"><a href="#mongoRepository-save" class="headerlink" title="mongoRepository.save"></a>mongoRepository.save</h3><p>문서의 일부 필드만 업데이트(Partial Update)를 수행합니다.</p>
<h4 id="동작-방식-1"><a href="#동작-방식-1" class="headerlink" title="동작 방식"></a>동작 방식</h4><ul>
<li><code>_id</code> 필드를 기준으로 MongoDB에서 문서를 검색.</li>
<li>문서가 존재하면 <strong>변경된 필드만 업데이트</strong>하고, 나머지 필드는 유지됩니다.</li>
<li>문서가 존재하지 않으면 새로 삽입합니다.</li>
</ul>
<h4 id="예제-1"><a href="#예제-1" class="headerlink" title="예제"></a>예제</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> user = User(id = <span class="string">&quot;123&quot;</span>, name = <span class="string">&quot;John Doe&quot;</span>)</span><br><span class="line">userRepository.save(user)</span><br></pre></td></tr></table></figure>

<h4 id="결과-1"><a href="#결과-1" class="headerlink" title="결과"></a>결과</h4><ul>
<li>기존 문서: <code>&#123; &quot;_id&quot;: &quot;123&quot;, &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25, &quot;email&quot;: &quot;alice@example.com&quot; &#125;</code></li>
<li>업데이트 후: <code>&#123; &quot;_id&quot;: &quot;123&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 25, &quot;email&quot;: &quot;alice@example.com&quot; &#125;</code></li>
<li>변경 사항: <code>name</code> 필드만 업데이트, 나머지 필드는 유지됨.</li>
</ul>
<h3 id="mongoTemplate-updateFirst"><a href="#mongoTemplate-updateFirst" class="headerlink" title="mongoTemplate.updateFirst"></a>mongoTemplate.updateFirst</h3><p>MongoDB의 <strong><code>updateFirst</code></strong> 명령어를 실행하여 <strong>단일 문서를 부분 업데이트</strong>합니다.</p>
<h4 id="동작-방식-2"><a href="#동작-방식-2" class="headerlink" title="동작 방식"></a>동작 방식</h4><ul>
<li>조건을 지정하여 MongoDB에서 문서를 검색.</li>
<li>첫 번째로 매칭된 문서의 <strong>일부 필드만 업데이트</strong>합니다.</li>
<li>문서가 존재하지 않으면 기본적으로 아무 작업도 수행하지 않습니다(삽입하지 않음).</li>
<li><code>$set</code>과 같은 MongoDB 연산자를 사용하여 지정된 필드만 업데이트합니다.</li>
</ul>
<h4 id="예제-2"><a href="#예제-2" class="headerlink" title="예제"></a>예제</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = Query(Criteria.<span class="keyword">where</span>(<span class="string">&quot;name&quot;</span>).`<span class="keyword">is</span>`(<span class="string">&quot;Alice&quot;</span>))</span><br><span class="line"><span class="keyword">val</span> update = Update().<span class="keyword">set</span>(<span class="string">&quot;age&quot;</span>, <span class="number">30</span>)</span><br><span class="line">mongoTemplate.updateFirst(query, update, User::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure>

<h4 id="결과-2"><a href="#결과-2" class="headerlink" title="결과"></a>결과</h4><ul>
<li>기존 문서: <code>&#123; &quot;_id&quot;: &quot;123&quot;, &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25, &quot;email&quot;: &quot;alice@example.com&quot; &#125;</code></li>
<li>업데이트 후: <code>&#123; &quot;_id&quot;: &quot;123&quot;, &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30, &quot;email&quot;: &quot;alice@example.com&quot; &#125;</code></li>
<li>변경 사항: <code>age</code> 필드만 업데이트, 나머지 필드는 유지됨.</li>
</ul>
<h2 id="효율적인-MongoDB-업데이트-전략"><a href="#효율적인-MongoDB-업데이트-전략" class="headerlink" title="효율적인 MongoDB 업데이트 전략"></a>효율적인 MongoDB 업데이트 전략</h2><p><code>mongoTemplate.save</code>는 문서 전체를 교체하기 때문에 일반적인 경우에는 거의 사용되지 않습니다. 반면, <code>mongoRepository.save</code>는 더 직관적이며, 특히 Spring Data JPA 경험이 있는 개발자에게는 익숙하고 이해하기 쉬운 방식입니다. 그럼에도 불구하고, 저는 업데이트 작업에 <code>mongoTemplate</code>기반의 업데이트만을 사용하고 있습니다. 그 이유는 다음과 같습니다.</p>
<h3 id="대량-처리에서의-성능-차이"><a href="#대량-처리에서의-성능-차이" class="headerlink" title="대량 처리에서의 성능 차이"></a>대량 처리에서의 성능 차이</h3><p><a href="https://cheese10yun.github.io/spring-data-mongodb-update-performance/">MongoDB Update 성능 측정 및 분석</a>에서 업데이트 성능을 측정한 결과를 참고할 수 있습니다.</p>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/5fc6127a0800ca9bce5de5a6c73931b2025b0791/mongo-study/images/performance-update.png"></p>
<table>
<thead>
<tr>
<th><strong>Rows</strong></th>
<th><strong>saveAll</strong></th>
<th><strong>updateFirst</strong></th>
<th><strong>bulkOps (UNORDERED)</strong></th>
<th><strong>bulkOps (ORDERED)</strong></th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>1,052 ms</td>
<td>1,176 ms</td>
<td>46 ms</td>
<td>79 ms</td>
</tr>
<tr>
<td>200</td>
<td>2,304 ms</td>
<td>2,196 ms</td>
<td>103 ms</td>
<td>124 ms</td>
</tr>
<tr>
<td>500</td>
<td>5,658 ms</td>
<td>5,250 ms</td>
<td>309 ms</td>
<td>257 ms</td>
</tr>
<tr>
<td>1,000</td>
<td>11,106 ms</td>
<td>10,846 ms</td>
<td>418 ms</td>
<td>412 ms</td>
</tr>
<tr>
<td>2,000</td>
<td>22,592 ms</td>
<td>21,427 ms</td>
<td>1,060 ms</td>
<td>1,004 ms</td>
</tr>
<tr>
<td>5,000</td>
<td>54,407 ms</td>
<td>52,075 ms</td>
<td>2,663 ms</td>
<td>2,292 ms</td>
</tr>
<tr>
<td>10,000</td>
<td>107,651 ms</td>
<td>110,884 ms</td>
<td>4,514 ms</td>
<td>4,496 ms</td>
</tr>
</tbody></table>
<p><code>saveAll</code> 방식은 각 문서의 <code>_id</code>를 확인하여 데이터베이스에 해당 문서가 존재하는지 판단합니다. 존재하는 경우에는 이를 업데이트로 인식하고, 내부적으로 반복문을 돌면서 <code>save</code>를 개별적으로 호출합니다. 이로 인해 각 문서에 대해 별도의 데이터베이스 요청이 발생하며, 처리 성능이 문서 수에 비례하여 저하될 수 있습니다. 특히, 요청 수가 많아질수록 이러한 방식은 응답 시간이 급격히 증가하는 원인이 됩니다.</p>
<p>반면, <code>bulkOps</code>는 여러 업데이트 작업을 한 번의 연산으로 묶어서 실행하므로 대량 처리에서 훨씬 효율적입니다. 이를 통해 처리 시간을 크게 단축할 수 있지만, <code>save</code>와 <code>saveAll</code> 방식으로는 <code>bulkOps</code>를 활용할 수 없다는 한계가 있습니다. 이러한 이유로 저는 대량 처리 작업에서 <code>updateFirst</code>와 함께 <code>bulkOps</code>를 활용하는 방식을 선호합니다.</p>
<p>또한, 대량 데이터를 업데이트할 때 <strong><code>where in</code> 절</strong>을 활용하면 효과적입니다. 이 경우, <code>mongoTemplate.updateMulti</code>를 사용하면 <code>bulkOps</code> 방식과 유사한 성능을 얻을 수 있습니다. <code>saveAll</code>을 사용하면 성능이 급격히 저하되므로, 대량 데이터를 업데이트할 때는 반드시 <code>mongoTemplate</code>을 사용하는 것이 좋습니다. 이러한 접근 방식은 대량 처리의 효율성과 성능 최적화를 보장하며, 대량 데이터를 다루는 애플리케이션에서 더욱 유용합니다.</p>
<h3 id="명확한-변경-사항-추적"><a href="#명확한-변경-사항-추적" class="headerlink" title="명확한 변경 사항 추적"></a>명확한 변경 사항 추적</h3><p><code>mongoRepository.save</code>를 사용하여 데이터를 업데이트할 경우, 정확히 어떤 필드가 변경되었는지 추적하기 어렵습니다. MongoDB는 비정형 데이터베이스로, 다양한 필드와 그 필드들이 다루는 컨텍스트가 매우 다양합니다. 이런 상황에서 <code>mongoRepository.save</code>를 통해 업데이트가 이루어지면, 어떤 필드가 어떤 조건에서 업데이트되었는지 명확히 파악하기 어렵기 때문에 데이터 변경 사항을 추적하고 관리하는 데 어려움이 발생할 수 있습니다.</p>
<p>반면, <code>mongoTemplate</code>을 기반으로 업데이트 쿼리를 작성하면 특정 필드에 대해 명확히 정의된 업데이트를 수행할 수 있습니다. 각 업데이트가 어디에서 이루어졌는지, 어떤 필드가 변경되었는지를 코드 레벨에서 명확히 확인할 수 있어 추적이 용이합니다. 특히 프로젝트가 복잡해지거나 엄격한 변경 관리가 요구될수록, 이러한 명확성은 유지보수와 협업 측면에서 큰 장점으로 작용합니다. 이를 통해 데이터 업데이트의 불확실성을 줄이고, 코드의 가독성과 신뢰성을 높일 수 있습니다.</p>
<h2 id="실제-사용-예시"><a href="#실제-사용-예시" class="headerlink" title="실제 사용 예시"></a>실제 사용 예시</h2><h3 id="Document-정의"><a href="#Document-정의" class="headerlink" title="Document 정의"></a>Document 정의</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document(collection = <span class="string">&quot;members&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span>(</span><br><span class="line">    <span class="meta">@Field(name = <span class="string">&quot;name&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = <span class="string">&quot;address&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> address: Address,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = <span class="string">&quot;member_id&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> memberId: String,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = <span class="string">&quot;email&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> email: String,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = <span class="string">&quot;status&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> status: MemberStatus</span><br><span class="line">) : Auditable()</span><br></pre></td></tr></table></figure>

<p>위 예시와 같이 <code>Member</code> 도큐먼트가 정의되어 있다고 가정하겠습니다. 이 도큐먼트는 <code>MongoRepository</code>를 사용하여 업데이트하지 않기 때문에, 필드들이 <code>val</code>로 지정되어 있습니다. 필드를 <code>val</code>로 지정하면 도큐먼트의 특정 필드를 변경하기 위해 객체를 직접 수정한 뒤 <code>save</code>를 호출하는 방식이 불가능합니다. 이렇게 필드를 <code>val</code>로 지정하면 도큐먼트의 불변성을 보장하며, 특정 필드의 변경을 엄격히 관리할 수 있습니다.</p>
<h3 id="Repository-정의"><a href="#Repository-정의" class="headerlink" title="Repository 정의"></a>Repository 정의</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MemberRepository</span> : <span class="type">MongoRepository</span>&lt;<span class="type">Member, ObjectId</span>&gt;, <span class="type">MemberCustomRepository</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MemberCustomRepository</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateName</span><span class="params">(targets: <span class="type">List</span>&lt;<span class="type">MemberQueryForm</span>.<span class="type">UpdateName</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemberCustomRepositoryImpl</span>(mongoTemplate: MongoTemplate) : MemberCustomRepository, MongoCustomRepositorySupport&lt;Member&gt;(Member::<span class="keyword">class</span>.java, mongoTemplate) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateName</span><span class="params">(targets: <span class="type">List</span>&lt;<span class="type">MemberQueryForm</span>.<span class="type">UpdateName</span>&gt;)</span></span> &#123;</span><br><span class="line">        bulkUpdate(</span><br><span class="line">            targets.map &#123;</span><br><span class="line">                Pair(</span><br><span class="line">                    &#123; Query(Criteria.<span class="keyword">where</span>(<span class="string">&quot;id&quot;</span>).`<span class="keyword">is</span>`(it.id)) &#125;,</span><br><span class="line">                    &#123; Update().<span class="keyword">set</span>(<span class="string">&quot;name&quot;</span>, it.name) &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MongoCustomRepositorySupport</code>를 상속받아 <code>bulkUpdate</code> 메서드를 통해 <code>bulkOps</code>를 사용한 대량 업데이트를 수행합니다. 이를 활용하면 대량 데이터를 효율적으로 처리할 수 있으며, 단일 업데이트만 필요한 경우 <code>updateFirst</code>를 사용하여 업데이트를 수행할 수도 있습니다. 그러나 특별한 이유가 없다면 <code>MongoCustomRepositorySupport</code> 기반으로 대량 업데이트를 지원하는 <code>bulkUpdate</code>를 사용하는 것을 권장합니다.</p>
<p>이 방식에 대한 자세한 구현 방법은 이전 포스팅 <a href="https://cheese10yun.github.io/spring-data-mongodb-update-performance/">MongoDB Update 성능 측정 및 분석 - MongoCustomRepositorySupport을 통한 bulkOps 기능 제공</a>에서 확인할 수 있습니다.</p>
<h3 id="업데이트-쿼리에-사용할-객체-정의"><a href="#업데이트-쿼리에-사용할-객체-정의" class="headerlink" title="업데이트 쿼리에 사용할 객체 정의"></a>업데이트 쿼리에 사용할 객체 정의</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> MemberQueryForm &#123;</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">UpdateName</span>(</span><br><span class="line">        <span class="keyword">val</span> id: ObjectId,</span><br><span class="line">        <span class="keyword">val</span> name: String</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MemberQueryForm</code> 객체를 정의하여 쿼리에 필요한 필드와 데이터를 명확하게 관리합니다. 이를 통해 업데이트 작업에서 어떤 필드가 업데이트되는지 명확히 파악할 수 있습니다. 만약 <code>MemberQueryForm</code>에 정의되지 않은 필드가 있다면, 해당 필드는 현재 업데이트 대상이 아니거나 정책적으로 업데이트되지 않는 필드라고 간주할 수 있습니다.</p>
<h3 id="테스트-코드-예시"><a href="#테스트-코드-예시" class="headerlink" title="테스트 코드 예시"></a>테스트 코드 예시</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MongoTestSupport</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemberRepositoryTest</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> memberRepository: MemberRepository</span><br><span class="line">) : MongoStudyApplicationTests() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `updateName test`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// given</span></span><br><span class="line">        <span class="keyword">val</span> members = (<span class="number">1.</span><span class="number">.20</span>).map &#123;</span><br><span class="line">            Member(</span><br><span class="line">                name = <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                ...</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> targets = mongoTemplate</span><br><span class="line">            .insertAll(members).map &#123;</span><br><span class="line">                MemberQueryForm.UpdateName(</span><br><span class="line">                    id = it.id!!,</span><br><span class="line">                    name = <span class="string">&quot;newName&quot;</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// when</span></span><br><span class="line">        memberRepository.updateName(targets)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// then</span></span><br><span class="line">        <span class="keyword">val</span> results = mongoTemplate.findAll&lt;Member&gt;()</span><br><span class="line"></span><br><span class="line">        then(results).hasSize(<span class="number">20</span>)</span><br><span class="line">        then(results).allSatisfy &#123;</span><br><span class="line">            then(it.name).isEqualTo(<span class="string">&quot;newName&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>해당 테스트 코드는 <code>MemberRepository</code>의 <code>updateName</code> 메서드를 검증합니다.</p>
<ol>
<li>먼저 <code>Member</code> 객체를 생성하고 MongoDB에 저장한 뒤, 저장된 데이터를 조회하여 <code>UpdateName</code> 객체를 생성합니다.</li>
<li>이후 <code>updateName</code> 메서드를 호출하여 업데이트를 수행합니다.</li>
<li>마지막으로 MongoDB에서 데이터를 다시 조회해, 업데이트가 성공적으로 이루어졌는지 확인합니다.</li>
</ol>
<p>이처럼 <code>MemberQueryForm</code> 객체를 사용해 업데이트 대상 필드를 명확히 정의함으로써, 변경 작업의 범위를 명확히 관리하고 추적할 수 있습니다. 테스트 코드 역시 이러한 명확성을 기반으로 업데이트 로직을 확인하도록 작성되었습니다.</p>
<h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>제가 담당하는 도메인은 특정 필드마다 업데이트 권한이 다르게 설정되어 있어, 업데이트 필드를 보다 명확하고 엄격하게 관리해야 하는 상황입니다. 또한, 대량의 데이터를 처리해야 하며, 빠른 처리를 보장해야 하는 요구사항도 있습니다. 이러한 이유로, 위에서 설명한 방식의 업데이트 전략을 선택했습니다. 각자의 상황과 요구사항에 맞는 적절한 방법을 선택하는 것이 가장 중요합니다.</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">태그</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/Guide/" rel="tag">Guide</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/Mongo/" rel="tag">Mongo</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/Performance/" rel="tag">Performance</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/spring-data-mongo-repository-2/"
                    data-tooltip="Spring Data MongoDB Repository 확장 - Aggregation 기반 페이징 처리"
                    aria-label="이전: Spring Data MongoDB Repository 확장 - Aggregation 기반 페이징 처리"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/redis-lettuce-connection/"
                    data-tooltip="Hikari와 비교하며 알아보는 Redis Lettuce 커넥션 풀의 특징"
                    aria-label="다음: Hikari와 비교하며 알아보는 Redis Lettuce 커넥션 풀의 특징"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/spring-data-mongo-update-guide-1/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/spring-data-mongo-update-guide-1/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cheese10yun.github.io/spring-data-mongo-update-guide-1/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>


<!-- Comment -->
<!--  utteranc comment -->

<script src="https://utteranc.es/client.js"
        repo="cheese10yun/blog-comment"
        issue-term="title"
        label="Comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Yun. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/spring-data-mongo-repository-2/"
                    data-tooltip="Spring Data MongoDB Repository 확장 - Aggregation 기반 페이징 처리"
                    aria-label="이전: Spring Data MongoDB Repository 확장 - Aggregation 기반 페이징 처리"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/redis-lettuce-connection/"
                    data-tooltip="Hikari와 비교하며 알아보는 Redis Lettuce 커넥션 풀의 특징"
                    aria-label="다음: Hikari와 비교하며 알아보는 Redis Lettuce 커넥션 풀의 특징"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/spring-data-mongo-update-guide-1/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/spring-data-mongo-update-guide-1/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://cheese10yun.github.io/spring-data-mongo-update-guide-1/"
                    title="Google+에 공유하기"
                    aria-label="Google+에 공유하기"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="5">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/spring-data-mongo-update-guide-1/"
                        aria-label="Facebook에 공유하기"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Facebook에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/spring-data-mongo-update-guide-1/"
                        aria-label="Twitter에 공유하기"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Twitter에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://cheese10yun.github.io/spring-data-mongo-update-guide-1/"
                        aria-label="Google+에 공유하기"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Google+에 공유하기</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
            <h4 id="about-card-name">Yun</h4>
        
            <div id="about-card-bio"><p>기술 블로그</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
