
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="naver-site-verification" content="a37ea649edf26e70c3de94f9cb034f9d6e11de3f" />
    <meta name="generator" content="Yun Blog">
    <title>MySQL Connection Pool 관리 - HikariCP 설정 및 타임아웃 처리 - Yun Blog</title>
    <meta name="author" content="Yun">
    
        <meta name="keywords" content="Node,Spring,Spring Boot,Spring Batch,Kotlin,기술 블로그,JPA,Mongo,MySQL,OOP,">
    
    
    
        
            <link rel="alternate" type="application/rss+xml" title="RSS" href="/rss2.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg"},"articleBody":"Connection Pool이란?#애플리케이션에서 MySQL 데이터베이스와의 효율적인 연결을 위해 커넥션 풀을 사용합니다. 커넥션 풀은 미리 일정한 수의 데이터베이스 연결을 생성해 두고, 애플리케이션이 필요할 때마다 이 연결들을 재사용함으로써 성능을 향상시키는 기법입니다. 이 방식은 데이터베이스와의 연결을 매번 새로 생성하는 대신 이미 준비된 연결을 재사용하여 애플리케이션의 응답 시간을 줄이는 데 매우 유용합니다.\nJava JDBC와 HikariCP#Java 애플리케이션에서 가장 널리 사용되는 커넥션 풀 중 하나는 HikariCP입니다. HikariCP는 가볍고 빠른 커넥션 풀로, 대규모 트래픽이 발생하는 상황에서도 효율적인 연결 관리를 지원합니다. HikariCP는 HikariPoolMXBean과 HikariConfigMXBean이라는 JMX(Java Management Extensions)를 통해 커넥션 풀의 상태 및 설정을 관리할 수 있습니다.\nSpring Boot에서의 HikariCP 설정과 기본값#\n\n\n설정 항목\n설명\n기본값\n\n\n\nmaximum-pool-size\n커넥션 풀에서 유지할 수 있는 최대 커넥션 수입니다. 이 수치를 초과하는 요청은 대기 상태로 들어갑니다.\n10\n\n\nminimum-idle\n풀에서 유지할 유휴 커넥션의 최소 개수입니다. 유휴 커넥션이 이 수치 이하로 떨어지면 새로운 커넥션이 생성됩니다.\nmaximum-pool-size 값과 동일\n\n\nconnection-timeout\n커넥션을 가져오기 위해 스레드가 대기할 수 있는 최대 시간입니다. 이 시간이 초과되면 예외가 발생합니다.\n30,000ms (30초)\n\n\nmax-lifetime\n커넥션이 유지될 수 있는 최대 시간입니다. 이 시간이 지나면 커넥션은 폐기되고 새 커넥션으로 교체됩니다.\n1,800,000ms (30분)\n\n\nidle-timeout\n유휴 상태의 커넥션이 풀에서 유지될 수 있는 최대 시간입니다. 이 시간이 지나면 유휴 커넥션이 풀에서 제거됩니다.\n600,000ms (10분)\n\n\nleak-detection-threshold\n지정된 시간(밀리초) 동안 사용되지 않은 커넥션을 감지하는 데 사용됩니다. 이 시간이 지나면 커넥션 리크(leak)를 의심하고 경고를 남깁니다.\n0 (비활성화)\n\n\npool-name\n커넥션 풀의 이름을 지정합니다. 기본적으로 HikariCP는 자동으로 이름을 생성하지만, 필요에 따라 지정할 수 있습니다.\n자동 생성된 이름\n\n\nauto-commit\n새 커넥션이 자동 커밋 모드로 시작할지를 결정합니다. 각 쿼리 후 자동으로 커밋됩니다.\ntrue\n\n\nvalidation-timeout\n커넥션이 유효한지 검증할 때 사용할 최대 시간입니다. 이 시간이 초과되면 커넥션은 유효하지 않다고 판단하고 폐기됩니다.\n5,000ms (5초)\n\n\nread-only\n커넥션이 읽기 전용 모드에서 작동할지를 결정합니다.\nfalse\n\n\nisolate-internal-queries\n내부 쿼리(예: 커넥션 풀의 유지 관리 쿼리)가 애플리케이션의 쿼리와 격리되는지를 설정합니다.\nfalse\n\n\nallow-pool-suspension\n커넥션 풀의 일시 정지 기능을 활성화합니다. 이 설정이 활성화되면 풀을 일시 정지하거나 다시 시작할 수 있습니다.\nfalse\n\n\ninitialization-fail-timeout\n풀을 시작할 때 초기화에 실패하는 경우를 대비한 타임아웃 시간입니다. 이 시간이 지나면 예외가 발생합니다.\n1초 (1,000ms)\n\n\n커넥션 풀 시나리오 설명#\nmaximumPoolSize가 10인 커넥션 풀을 가진 애플리케이션에서, 10명의 사용자가 각각 1초에 한 번씩 요청을 보낸다고 가정해보겠습니다. 각 요청은 약 1초가 소요됩니다. 아래 시나리오는 커넥션 풀의 상태를 각 단계별로 설명합니다.\n커넥션 풀의 주요 필드 및 동작 시나리오 분석#\nmaximumPoolSize:\n설명: 커넥션 풀에서 관리할 수 있는 최대 커넥션 수를 나타냅니다. 이 시나리오에서는 10개로 설정되어 있어, 동시에 최대 10개의 요청을 처리할 수 있습니다.\n이미지 설명: 이미지에서 totalConnections = 10으로 설정되어 있으며, 이는 커넥션 풀에서 관리할 수 있는 총 커넥션이 10개임을 의미합니다.\n\n\nactiveConnections:\n설명: 현재 요청을 처리 중인 커넥션의 수입니다. 동시 요청이 10건 발생하면 activeConnections는 10이 됩니다. 더 이상 여유가 없는 상태에서 추가 요청이 들어오면 대기 상태가 됩니다.\n이미지 설명: 첫 번째 그림에서 activeConnections = 1로, 한 개의 요청이 활성화된 상태입니다. 두 번째 그림에서는 activeConnections = 5로, 5명이 동시에 요청을 보내고 있습니다. 세 번째 그림에서는 activeConnections = 10으로, 모든 커넥션이 활성화되어 추가 요청을 처리할 수 없는 상태입니다.\n\n\nidleConnections:\n설명: 유휴 상태로 대기 중인 커넥션의 수를 나타냅니다. 예를 들어, 첫 번째 요청이 처리될 때 idleConnections는 9개이며, 모든 커넥션이 활성화되면 idleConnections는 0이 됩니다.\n이미지 설명: 첫 번째 그림에서 idleConnections = 9로, 9개의 커넥션이 대기 상태입니다. 두 번째 그림에서는 idleConnections = 5, 세 번째 그림에서는 idleConnections = 0으로, 모든 커넥션이 사용 중인 상태입니다.\n\n\ntotalConnections:\n설명: 커넥션 풀에서 관리하고 있는 총 커넥션 수로, activeConnections와 idleConnections의 합입니다. 이 값은 maximumPoolSize 내에서 유지되며, 동시 요청이 많을수록 idleConnections가 줄어듭니다.\n이미지 설명: 세 개의 그림 모두 totalConnections = 10으로, 이는 커넥션 풀에서 관리하는 커넥션이 총 10개임을 나타냅니다.\n\n\nthreadsAwaitingConnection:\n설명: 커넥션이 모두 사용 중일 때 대기 중인 요청의 수를 나타냅니다. 예를 들어, 10명의 사용자가 모두 커넥션을 사용 중일 때 추가 요청이 발생하면, 그 요청은 대기 상태로 들어가 threadsAwaitingConnection이 증가합니다.\n이미지 설명: 마지막 그림에서는 모든 커넥션이 사용 중이기 때문에, 추가 요청이 발생하면 대기 상태로 들어가게 됩니다.\n\n\nconnectionTimeout:\n설명: 대기 중인 요청이 커넥션을 얻기 위해 기다릴 수 있는 최대 시간을 나타냅니다. 예를 들어, connectionTimeout이 2초로 설정된 경우, 대기 중인 요청이 2초 내에 커넥션을 할당받지 못하면 요청은 실패하게 됩니다.\n이미지 설명: 마지막 그림에서 모든 커넥션이 사용 중인 상태에서 추가 요청이 들어오면, connectionTimeout 내에 커넥션을 할당받지 못할 경우 해당 요청은 실패하게 됩니다.\n\n\nvalidationTimeout:\n설명: 풀에서 커넥션을 빌려올 때 해당 커넥션이 유효한지 확인하는 시간입니다. 이 시간이 초과되면 해당 커넥션은 사용되지 않고 새로운 커넥션이 할당됩니다.\n이미지 설명: 유휴 상태로 오래 있던 커넥션은 유효성 검사에서 실패할 수 있으며, 이 경우 새로운 커넥션이 할당됩니다. 이미지에서는 유휴 상태의 커넥션들이 대기 중인 상태를 보여줍니다.\n\n\n\nHikariCP 설정 및 상태 측정 샘플 코드#Spring Boot 애플리케이션에서 HikariCP를 사용하는 방법을 설명합니다. HikariCP는 Spring Boot에서 기본적으로 사용하는 커넥션 풀로, 설정을 통해 다양한 커넥션 관리 옵션을 제공합니다. 또한, HikariCP의 상태를 측정할 수 있는 방법을 추가하여 커넥션 풀의 효율적인 관리가 가능합니다.\nHikariCP Properties 설정#12345678910111213141516spring:    datasource:        hikari:            maximum-pool-size: 10           # 최대 커넥션 수            minimum-idle: 10                # 최소 유휴 커넥션 수            connection-timeout: 30000       # 커넥션을 가져올 때 대기할 최대 시간 (밀리초)            max-lifetime: 1800000           # 커넥션이 유지될 최대 시간 (밀리초)            idle-timeout: 600000            # 유휴 커넥션이 유지될 최대 시간 (밀리초)            leak-detection-threshold: 2000  # 커넥션 리크를 감지할 기준 시간 (밀리초)            pool-name: Sample-HikariPool    # 커넥션 풀 이름            auto-commit: true               # 자동 커밋 여부            validation-timeout: 5000        # 커넥션 유효성 검사를 위한 최대 시간 (밀리초)            read-only: false                # 읽기 전용 모드 여부            isolate-internal-queries: false # 내부 쿼리 격리 여부            allow-pool-suspension: false    # 커넥션 풀 일시 정지 허용 여부            initialization-fail-timeout: 1  # 초기화 실패 시 타임아웃 (밀리초)\n\nHikariCP 상태 측정 코드#123456789101112131415161718192021222324252627282930@Serviceclass SampleService(    private val dataSource: DataSource,    private val memberRepository: MemberRepository) &#123;    private val log = LoggerFactory.getLogger(javaClass)!!    @Transactional    fun getMember(): Member &#123;        val member = memberRepository.findById(Random.nextInt(1, 101).toLong()).get()        runBlocking &#123; delay(1000) &#125;        val targetDataSource = dataSource.unwrap(HikariDataSource::class.java)        val hikariDataSource = targetDataSource as HikariDataSource        val hikariPoolMXBean = hikariDataSource.hikariPoolMXBean        val hikariConfigMXBean = hikariDataSource.hikariConfigMXBean        val log =            &quot;&quot;&quot;            totalConnections : $&#123;hikariPoolMXBean.totalConnections&#125;            activeConnections : $&#123;hikariPoolMXBean.activeConnections&#125;            idleConnections : $&#123;hikariPoolMXBean.idleConnections&#125;            threadsAwaitingConnection : $&#123;hikariPoolMXBean.threadsAwaitingConnection&#125;            &quot;&quot;&quot;.trimIndent()        this.log.info(log)        return member    &#125;&#125;\n\n이 코드에서는 먼저 DataSource를 HikariDataSource로 변환한 후, HikariPoolMXBean과 HikariConfigMXBean을 사용하여 커넥션 풀의 상태를 확인합니다. 이를 통해 총 커넥션 수, 활성 커넥션 수, 유휴 커넥션 수, 그리고 대기 중인 스레드 수와 같은 정보를 가져옵니다. 또한, runBlocking &#123; delay(1000) &#125;을 사용하여 1초간의 지연을 추가함으로써, 실제 요청이 처리되는 동안 커넥션 풀의 상태를 보다 명확하게 모니터링할 수 있습니다. 마지막으로, 이러한 커넥션 풀의 상태를 로그로 출력하여 애플리케이션의 성능을 모니터링하고, 필요한 경우 성능을 조정할 수 있는 정보를 제공합니다.\nConnection Pool 측정#\n애플리케이션에서 커넥션 풀을 사용할 때, 커넥션 풀의 상태를 지속적으로 모니터링하는 것은 매우 중요합니다. 아래와 같은 로그는 **10 TPS (초당 트랜잭션)**를 지속적으로 유지할 때 발생한 로그입니다. 이때 평균 응답 시간은 약 1,000ms로 나타나며, 이는 TPS 수준을 고려했을 때 시스템이 적정 수준에서 작동하고 있음을 보여줍니다.\n\n로그 1:\n\ntotalConnections = 10\nactiveConnections = 7\nidleConnections = 3\nthreadsAwaitingConnection = 0\n\n이 상태는 총 10개의 커넥션 중 7개가 활성화되어 요청을 처리하고 있으며, 3개의 유휴 커넥션이 대기 중인 상황입니다. 모든 요청이 원활하게 처리되고 있기 때문에, 대기 중인 스레드는 없습니다.\n\n로그 2:\n\ntotalConnections = 10\nactiveConnections = 10\nidleConnections = 0\nthreadsAwaitingConnection = 4\n\n이 상태는 모든 10개의 커넥션이 활성화되어 요청을 처리 중이며, 더 이상 유휴 커넥션이 남아있지 않습니다. 이때 4개의 추가 요청이 들어와 대기 중입니다. threadsAwaitingConnection 값이 4로 증가한 이유는, 요청을 처리할 수 있는 유휴 커넥션이 없기 때문입니다.\n\n\n커넥션 풀 동작 및 타임아웃 발생#커넥션 풀이 설정된 maximumPoolSize만큼 활성화된 경우, 그 이후에 들어오는 요청은 대기 상태에 들어가게 됩니다. 이때 대기 시간이 길어질 수 있으며, 이러한 대기 시간이 너무 길어지면 타임아웃이 발생할 수 있습니다. 타임아웃이 발생하는 주요 원인은 다음과 같습니다.\nconnection-timeout은 커넥션을 얻기 위해 스레드가 대기할 수 있는 최대 시간을 의미합니다. 예를 들어, connection-timeout이 30초로 설정되어 있다면, 커넥션 풀이 사용 가능한 커넥션을 30초 동안 제공하지 못할 경우 타임아웃이 발생하게 됩니다. 이 설정은 대기 중인 요청이 얼마 동안 기다릴 수 있는지를 제한합니다.\n커넥션 풀은 한정된 자원을 효율적으로 관리하여 시스템의 안정성을 유지하는 좋은 방법입니다. 그러나, 만약 요청량이 설정된 maximumPoolSize를 초과하게 되면 대기 상태가 발생할 수 있습니다. 이러한 상황을 방지하기 위해 적절한 타임아웃 값을 설정하고, 필요에 따라 풀 크기를 조정하는 것이 중요합니다.\nconnection-timeout 설정과 TPS 증가로 인한 오류 발생#123456spring:    datasource:        hikari:            maximum-pool-size: 10         # 최대 커넥션 수            minimum-idle: 10              # 최소 유휴 커넥션 수            connection-timeout: 250       # 커넥션을 가져올 때 대기할 최대 시간 (밀리초)\n\n위 설정에서 connection-timeout을 250ms로 지정한 경우, TPS가 10을 초과하게 되면 threadsAwaitingConnection에 대기하는 시간이 250ms를 넘을 수 있습니다. 이 상황이 발생하면, 커넥션 풀은 설정된 대기 시간보다 오래 걸리기 때문에 타임아웃 오류가 발생하게 됩니다.\n\n이미지에서와 같이, RPS(Request Per Second)가 10 이상일 때 커넥션 풀의 한계로 인해 대기 중인 요청이 발생하고, 그 대기 시간이 250ms를 초과하면 오류가 발생합니다. 이때 Failures/s가 증가하는 것을 확인할 수 있습니다. 이는 타임아웃 설정과 관련이 있으며, 커넥션 풀의 자원 한계와 처리량을 적절히 맞춰야 하는 이유를 보여줍니다.\n오류 메시지 예시:\n123java.sql.SQLTransientConnectionException: Sample-HikariPool - Connection is not available, request timed out after 251ms.\tat com.zaxxer.hikari.pool.HikariPool.createTimeoutException(HikariPool.java:696) ~[HikariCP-4.0.3.jar:na]\tat com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:197) \n\n이 오류는 대기 시간이 설정된 connection-timeout을 초과했음을 의미하며, 커넥션 풀이 추가 요청을 처리할 수 없다는 것을 나타냅니다. 이 문제를 해결하기 위해 여러 가지 방법을 고려할 수 있습니다.\nConnection Pool 문제 해결방법#애플리케이션에서 Connection Pool은 안정적인 데이터베이스 연결을 관리하는 데 매우 중요한 역할을 합니다. 하지만 시스템 부하가 높거나 설정이 적절하지 않은 경우, 커넥션 풀에서 발생하는 문제로 인해 성능 저하나 타임아웃 오류가 발생할 수 있습니다. 이러한 문제를 해결하기 위해서는 몇 가지 핵심적인 접근 방식을 취할 수 있습니다.\n\n쿼리 최적화: 데이터베이스 성능 문제는 종종 비효율적인 쿼리로 인해 발생합니다. 쿼리 최적화는 애플리케이션의 응답 시간을 줄이고, 커넥션이 오랫동안 점유되는 상황을 방지할 수 있는 중요한 방법입니다. 인덱스를 추가하거나 복잡한 쿼리 구조를 단순화하는 것 등이 이에 해당합니다.\nconnection-timeout 시간 조정: 커넥션 타임아웃은 대기 중인 요청이 커넥션을 얻기 위해 얼마나 오랜 시간 기다릴 수 있는지를 결정합니다. 이 시간을 적절히 설정함으로써 대기 중인 요청들이 효율적으로 처리되도록 할 수 있습니다. 너무 짧은 타임아웃은 오류를 유발할 수 있고, 너무 긴 타임아웃은 응답 지연을 초래할 수 있으므로, 상황에 맞게 타임아웃을 조정해야 합니다.\nmaximum-pool-size 증가: 예상되는 트래픽에 맞춰 커넥션 풀의 최대 크기를 늘림으로써 동시 요청 처리 성능을 향상시킬 수 있습니다. 그러나 자원 낭비를 방지하기 위해 시스템의 메모리와 CPU 사용량을 신중하게 고려하여 최적의 크기를 설정하는 것이 중요합니다.\n\n이와 같은 방법을 적절히 적용하면 Connection Pool 문제를 해결하고, 애플리케이션의 성능과 안정성을 크게 향상시킬 수 있습니다. 아래에서는 이 세 가지 접근 방법을 구체적으로 다루고, 실제 적용 사례를 통해 성능 최적화 방법을 설명합니다.\n쿼리 최적화#쿼리 최적화는 데이터베이스 성능 향상에 있어 중요한 단계입니다. 특히, 애플리케이션에서 activeConnections가 빠르게 응답하지 못하는 경우, 그 원인이 복잡한 쿼리 처리에 있다면 쿼리 최적화를 통해 성능을 크게 개선할 수 있습니다. 잘못 설계된 쿼리나 불필요하게 긴 실행 시간을 가진 쿼리는 시스템 전반의 성능에 영향을 미치고, 커넥션 풀의 자원을 오래 점유하게 되어 대기 중인 요청들이 지연되는 상황을 초래할 수 있습니다.\n다음과 같은 방식으로 쿼리를 최적화함으로써 응답 속도를 개선할 수 있습니다:\n1234567@Transactionalfun getMember(): Member &#123;    val member = memberRepository.findById(Random.nextInt(1, 101).toLong()).get()    // runBlocking &#123; delay(1000) &#125; 블록킹 코드 제거    ...    return member&#125;\n\n위 코드에서 불필요한 블로킹 코드인 runBlocking &#123; delay(1000) &#125;를 제거함으로써 쿼리 실행 지연을 없앴습니다. 이와 같이, 쿼리 최적화는 단순히 코드 내의 블로킹 요소를 제거하는 것뿐만 아니라, 인덱스 추가, 복잡한 조인 구조 단순화, 캐싱 등을 통해 데이터베이스에 대한 부하를 줄이는 방법도 포함됩니다. 이러한 최적화 작업을 통해 쿼리 실행 시간이 줄어들면 커넥션이 더 빨리 반환되고, 대기 중인 요청이 빠르게 처리될 수 있습니다.\n\n쿼리 최적화를 통해 성능이 향상되면, connection-timeout이 250ms로 설정된 상황에서도 RPS가 20인 경우처럼 높은 요청 처리량에서도 타임아웃 오류가 발생하지 않게 됩니다. 이는 쿼리가 최적화되면 커넥션이 더 빠르게 반환되기 때문에, 커넥션 풀 내에서 더 많은 요청을 동시에 처리할 수 있기 때문입니다.\n최적화된 쿼리는 커넥션 점유 시간을 줄여 connection-timeout 설정의 제한을 넘지 않도록 도와주며, 결과적으로 더 많은 트랜잭션을 안정적으로 처리할 수 있게 됩니다. 따라서, 쿼리 최적화는 애플리케이션 성능을 유지하고 향상시키는 중요한 방법입니다.\n결론적으로, 쿼리 최적화는 데이터베이스 성능 개선뿐만 아니라, 커넥션 풀 자원 관리에도 매우 중요한 역할을 합니다. 불필요한 대기 시간을 줄이고, 시스템이 고부하 상황에서도 원활하게 작동할 수 있도록 돕습니다.\nconnection-timeout 시간 조정#connection-timeout 설정은 대기 중인 요청이 커넥션을 얻기 위해 기다릴 수 있는 시간을 조정하는 중요한 요소입니다. 만약 요청량이 많아 maximumPoolSize에 도달했을 때, connection-timeout을 적절히 늘려주면 대기 중인 요청이 커넥션을 할당받기까지 더 오랜 시간을 허용할 수 있습니다. 예를 들어, connection-timeout을 250ms에서 2,500ms로 늘리면, 커넥션 반환 대기 시간을 더 길게 설정함으로써 타임아웃 오류를 줄일 수 있습니다. 하지만, 너무 긴 대기 시간을 설정하면 그만큼 응답 시간이 지연될 수 있으므로 신중하게 설정해야 합니다.\n아래는 connection-timeout을 2,500ms로 설정하고 테스트한 설정 예시입니다:\n123456spring:    datasource:        hikari:            maximum-pool-size: 10         # 최대 커넥션 수            minimum-idle: 10              # 최소 유휴 커넥션 수            connection-timeout: 2500      # 커넥션을 가져올 때 대기할 최대 시간 (밀리초)\n\n이 설정에서, delay(1000)는 유지하면서 connection-timeout을 2,500ms로 변경한 후 테스트를 진행하였습니다.\n\n테스트 결과는 아래와 같습니다:\n12345totalConnections : 10maximumPoolSize : 10activeConnections : 10idleConnections : 0threadsAwaitingConnection : 20\n\n\ntotalConnections: 10개 커넥션이 모두 사용 중입니다.\nmaximumPoolSize: 설정된 최대 커넥션 수는 10개입니다.\nactiveConnections: 현재 10개의 커넥션이 활성화되어 있습니다.\nidleConnections: 유휴 커넥션이 없으며, 모든 커넥션이 사용 중입니다.\nthreadsAwaitingConnection: 20개의 요청이 대기 중입니다.\n\nconnection-timeout 설정이 2,500ms로 변경됨에 따라, threadsAwaitingConnection에서 대기하는 시간이 길어졌습니다. 결과적으로 타임아웃 오류는 발생하지 않았지만, 응답 시간이 더 길어졌습니다. 이는 각 요청에 대해 delay(1000)으로 인한 1,000ms의 블로킹 시간과 threadsAwaitingConnection에서 대기한 시간이 합쳐져 응답 시간이 느려진 것입니다.\n이런 경우, 타임아웃을 길게 설정하는 것은 타임아웃 오류를 방지할 수 있지만, 동시에 응답 속도가 저하될 수 있습니다. 따라서, connection-timeout은 요청의 특성과 트래픽 패턴에 맞추어 적절한 값을 설정하는 것이 매우 중요합니다.\nmaximum-pool-size 증가#애플리케이션에서 처리할 수 있는 동시 요청 수가 많아질 것으로 예상된다면, maximum-pool-size를 늘려 커넥션 풀에서 더 많은 커넥션을 생성하고 유지할 수 있도록 설정할 수 있습니다. 예를 들어, 트래픽이 예상보다 많아지거나, 동시성 처리가 많이 요구되는 상황에서는 커넥션 풀 크기를 늘려주는 것이 유리합니다. 이를 통해 더 많은 요청을 동시에 처리할 수 있게 됩니다. 그러나, 무작정 풀 크기를 크게 설정하는 것은 자원 낭비를 초래할 수 있습니다. 커넥션 풀 크기가 커지면 더 많은 메모리와 CPU가 필요하기 때문에, 시스템의 자원 사용량을 신중히 고려한 후에 조정하는 것이 중요합니다.\n예를 들어, maximum-pool-size를 100으로 설정하고, 1,000ms 대기 코드를 다시 활성화시키며 connection-timeout을 250ms로 유지했음에도 불구하고, 오류가 발생하지 않는 상황을 가정해보겠습니다.\n1234567@Transactionalfun getMember(): Member &#123;  val member = memberRepository.findById(Random.nextInt(1, 101).toLong()).get()  runBlocking &#123; delay(1000) &#125;  // 1,000ms 대기  ...  return member&#125;\n\n이 코드에서는 runBlocking &#123; delay(1000) &#125;를 통해 각 요청마다 1초의 지연을 발생시키고 있지만, maximum-pool-size를 충분히 높게 설정함으로써 동시 요청이 몰리는 상황에서도 타임아웃 오류가 발생하지 않습니다. 아래와 같은 로그를 통해 확인할 수 있습니다.\n\n1234totalConnections : 30maximumPoolSize : 100activeConnections : 13idleConnections : 17\n\n\ntotalConnections: 현재 커넥션 풀에서 관리되고 있는 커넥션의 총 개수로, 현재 30개가 할당되어 있는 상태입니다.\nmaximumPoolSize: 커넥션 풀에서 설정된 최대 커넥션 수는 100입니다. 하지만, 모든 커넥션이 필요하지 않기 때문에 100까지 차지 않고 있는 상황입니다.\nactiveConnections: 현재 요청을 처리 중인 활성 커넥션 수는 13개입니다.\nidleConnections: 유휴 상태로 대기 중인 커넥션 수는 17개로, 요청이 추가로 들어오면 이 커넥션들이 활성화될 수 있습니다.\n\n이 상황에서는 maximumPoolSize가 100으로 설정되어 있지만, 모든 커넥션이 사용 중이지 않기 때문에 자원 낭비를 최소화할 수 있습니다. 요청이 몰리지 않는 상태에서는 activeConnections가 13개에 머무르고, 나머지 17개는 유휴 상태로 남아있습니다. 이처럼 최대 커넥션 수는 설정했지만, 필요할 때만 커넥션이 활성화되고 나머지는 유휴 상태를 유지하는 방식으로 효율적인 자원 관리가 가능합니다.\n따라서, maximum-pool-size는 트래픽이 몰릴 경우를 대비해 충분히 큰 값으로 설정할 수 있지만, 시스템 자원에 부담을 주지 않도록 실제 트래픽과 자원 사용량을 분석하여 적절한 값으로 설정하는 것이 중요합니다.\n결론#HikariCP를 사용한 MySQL 커넥션 풀 관리는 애플리케이션 성능 최적화의 핵심 요소입니다. 적절한 커넥션 풀 설정을 통해 데이터베이스와의 연결을 효율적으로 관리하고, 불필요한 연결 재생성을 피하며, 응답 시간을 단축할 수 있습니다. 그러나, maximumPoolSize와 connection-timeout과 같은 설정이 적절하지 않으면, 트래픽이 증가할 때 커넥션 풀에서 대기 시간이 늘어나거나 타임아웃 오류가 발생할 수 있습니다.\n이를 방지하고 시스템 성능을 최적화하기 위해 다음과 같은 중요한 포인트를 기억해야 합니다.\n\n쿼리 최적화: 쿼리의 성능이 느릴 경우 activeConnections가 불필요하게 오래 점유되며, 전체 시스템의 성능을 저하시킬 수 있습니다. 쿼리를 최적화하여 커넥션을 빠르게 반환하면 대기 중인 요청도 신속하게 처리할 수 있습니다.\nmaximum-pool-size 설정: maximum-pool-size는 동시 처리할 수 있는 최대 요청 수를 결정합니다. 트래픽 예측에 맞춰 적절히 풀 크기를 늘리는 것은 중요하지만, 자원 낭비를 방지하기 위해 너무 크게 설정하지 않는 것이 좋습니다. 실제로 필요할 때만 커넥션이 활성화되는 방식으로 자원을 효율적으로 관리해야 합니다.\nconnection-timeout 설정: connection-timeout 값은 대기 중인 요청이 커넥션을 얻기 위해 기다릴 수 있는 최대 시간을 결정합니다. 이 값을 너무 낮게 설정하면 트래픽이 몰릴 때 타임아웃 오류가 자주 발생할 수 있으며, 반대로 너무 길게 설정하면 응답 시간이 지연될 수 있습니다. 트래픽 패턴에 맞춰 적절한 값을 설정하는 것이 중요합니다.\nTPS 모니터링: 초당 처리량(TPS)을 지속적으로 모니터링하고, 트래픽 패턴을 기반으로 HikariCP 설정을 조정해야 합니다. 이를 통해 애플리케이션이 다양한 부하 상황에서도 원활하게 작동할 수 있도록 합니다.\n\n최종적으로, 커넥션 풀 설정을 조정할 때는 트래픽 패턴과 시스템 자원을 고려하여 최적화된 값을 설정하는 것이 필수적입니다. 이를 통해 응답 속도 지연 및 타임아웃 오류를 최소화할 수 있으며, 안정적인 시스템 운영과 함께 애플리케이션의 성능을 극대화할 수 있습니다.\n","dateCreated":"2024-10-21T01:15:31+09:00","dateModified":"2025-01-31T22:31:40+09:00","datePublished":"2024-10-21T01:15:31+09:00","description":"애플리케이션에서 MySQL 데이터베이스와의 효율적인 연결을 위해 커넥션 풀을 사용합니다. 커넥션 풀은 미리 일정한 수의 데이터베이스 연결을 생성해 두고, 애플리케이션이 필요할 때마다 이 연결들을 재사용함으로써 성능을 향상시키는 기법입니다.","headline":"MySQL Connection Pool 관리 - HikariCP 설정 및 타임아웃 처리","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://cheese10yun.github.io/mysql-connection-pool-timeout/"},"publisher":{"@type":"Organization","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg","logo":{"@type":"ImageObject","url":"yun-icon.jpg"}},"url":"https://cheese10yun.github.io/mysql-connection-pool-timeout/","keywords":"Performance, MySQL, Connection Pool"}</script>
    <meta name="description" content="애플리케이션에서 MySQL 데이터베이스와의 효율적인 연결을 위해 커넥션 풀을 사용합니다. 커넥션 풀은 미리 일정한 수의 데이터베이스 연결을 생성해 두고, 애플리케이션이 필요할 때마다 이 연결들을 재사용함으로써 성능을 향상시키는 기법입니다.">
<meta property="og:type" content="blog">
<meta property="og:title" content="MySQL Connection Pool 관리 - HikariCP 설정 및 타임아웃 처리">
<meta property="og:url" content="https://cheese10yun.github.io/mysql-connection-pool-timeout/index.html">
<meta property="og:site_name" content="Yun Blog">
<meta property="og:description" content="애플리케이션에서 MySQL 데이터베이스와의 효율적인 연결을 위해 커넥션 풀을 사용합니다. 커넥션 풀은 미리 일정한 수의 데이터베이스 연결을 생성해 두고, 애플리케이션이 필요할 때마다 이 연결들을 재사용함으로써 성능을 향상시키는 기법입니다.">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-5.png">
<meta property="article:published_time" content="2024-10-20T16:15:31.000Z">
<meta property="article:modified_time" content="2025-01-31T13:31:40.721Z">
<meta property="article:author" content="Yun">
<meta property="article:tag" content="Performance">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="Connection Pool">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-1.png">
    
    
        
    
    
        <meta property="og:image" content="https://cheese10yun.github.io/assets/images/yun-icon.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90907312-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-90907312-1');
    </script>


    

    
        
    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5813739623204880" crossorigin="anonymous"></script>
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="5">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Yun Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="링크 열기: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="5">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="저자에 대해 더 알아보기"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
                </a>
                <h4 class="sidebar-profile-name">Yun</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기술 블로그</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="태그"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="아카이브"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">아카이브</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/cheese10yun"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/rss2.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="5"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            MySQL Connection Pool 관리 - HikariCP 설정 및 타임아웃 처리
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2024-10-21T01:15:31+09:00">
	
		    2024/10/21
    	
    </time>
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h2><span id="connection-pooliran">Connection Pool이란?</span><a href="#connection-pooliran" class="header-anchor">#</a></h2><p>애플리케이션에서 MySQL 데이터베이스와의 효율적인 연결을 위해 <strong>커넥션 풀</strong>을 사용합니다. 커넥션 풀은 미리 일정한 수의 데이터베이스 연결을 생성해 두고, 애플리케이션이 필요할 때마다 이 연결들을 재사용함으로써 성능을 향상시키는 기법입니다. 이 방식은 데이터베이스와의 연결을 매번 새로 생성하는 대신 이미 준비된 연결을 재사용하여 애플리케이션의 응답 시간을 줄이는 데 매우 유용합니다.</p>
<h2><span id="java-jdbcwa-hikaricp">Java JDBC와 HikariCP</span><a href="#java-jdbcwa-hikaricp" class="header-anchor">#</a></h2><p>Java 애플리케이션에서 가장 널리 사용되는 커넥션 풀 중 하나는 <strong>HikariCP</strong>입니다. HikariCP는 가볍고 빠른 커넥션 풀로, 대규모 트래픽이 발생하는 상황에서도 효율적인 연결 관리를 지원합니다. HikariCP는 <strong>HikariPoolMXBean</strong>과 <strong>HikariConfigMXBean</strong>이라는 JMX(Java Management Extensions)를 통해 커넥션 풀의 상태 및 설정을 관리할 수 있습니다.</p>
<h3><span id="spring-booteseoyi-hikaricp-seoljeonggwa-gibongabs">Spring Boot에서의 HikariCP 설정과 기본값</span><a href="#spring-booteseoyi-hikaricp-seoljeonggwa-gibongabs" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>설정 항목</th>
<th>설명</th>
<th>기본값</th>
</tr>
</thead>
<tbody><tr>
<td><strong>maximum-pool-size</strong></td>
<td>커넥션 풀에서 유지할 수 있는 최대 커넥션 수입니다. 이 수치를 초과하는 요청은 대기 상태로 들어갑니다.</td>
<td>10</td>
</tr>
<tr>
<td><strong>minimum-idle</strong></td>
<td>풀에서 유지할 유휴 커넥션의 최소 개수입니다. 유휴 커넥션이 이 수치 이하로 떨어지면 새로운 커넥션이 생성됩니다.</td>
<td><code>maximum-pool-size</code> 값과 동일</td>
</tr>
<tr>
<td><strong>connection-timeout</strong></td>
<td>커넥션을 가져오기 위해 스레드가 대기할 수 있는 최대 시간입니다. 이 시간이 초과되면 예외가 발생합니다.</td>
<td>30,000ms (30초)</td>
</tr>
<tr>
<td><strong>max-lifetime</strong></td>
<td>커넥션이 유지될 수 있는 최대 시간입니다. 이 시간이 지나면 커넥션은 폐기되고 새 커넥션으로 교체됩니다.</td>
<td>1,800,000ms (30분)</td>
</tr>
<tr>
<td><strong>idle-timeout</strong></td>
<td>유휴 상태의 커넥션이 풀에서 유지될 수 있는 최대 시간입니다. 이 시간이 지나면 유휴 커넥션이 풀에서 제거됩니다.</td>
<td>600,000ms (10분)</td>
</tr>
<tr>
<td><strong>leak-detection-threshold</strong></td>
<td>지정된 시간(밀리초) 동안 사용되지 않은 커넥션을 감지하는 데 사용됩니다. 이 시간이 지나면 커넥션 리크(leak)를 의심하고 경고를 남깁니다.</td>
<td>0 (비활성화)</td>
</tr>
<tr>
<td><strong>pool-name</strong></td>
<td>커넥션 풀의 이름을 지정합니다. 기본적으로 HikariCP는 자동으로 이름을 생성하지만, 필요에 따라 지정할 수 있습니다.</td>
<td>자동 생성된 이름</td>
</tr>
<tr>
<td><strong>auto-commit</strong></td>
<td>새 커넥션이 자동 커밋 모드로 시작할지를 결정합니다. 각 쿼리 후 자동으로 커밋됩니다.</td>
<td><code>true</code></td>
</tr>
<tr>
<td><strong>validation-timeout</strong></td>
<td>커넥션이 유효한지 검증할 때 사용할 최대 시간입니다. 이 시간이 초과되면 커넥션은 유효하지 않다고 판단하고 폐기됩니다.</td>
<td>5,000ms (5초)</td>
</tr>
<tr>
<td><strong>read-only</strong></td>
<td>커넥션이 읽기 전용 모드에서 작동할지를 결정합니다.</td>
<td><code>false</code></td>
</tr>
<tr>
<td><strong>isolate-internal-queries</strong></td>
<td>내부 쿼리(예: 커넥션 풀의 유지 관리 쿼리)가 애플리케이션의 쿼리와 격리되는지를 설정합니다.</td>
<td><code>false</code></td>
</tr>
<tr>
<td><strong>allow-pool-suspension</strong></td>
<td>커넥션 풀의 일시 정지 기능을 활성화합니다. 이 설정이 활성화되면 풀을 일시 정지하거나 다시 시작할 수 있습니다.</td>
<td><code>false</code></td>
</tr>
<tr>
<td><strong>initialization-fail-timeout</strong></td>
<td>풀을 시작할 때 초기화에 실패하는 경우를 대비한 타임아웃 시간입니다. 이 시간이 지나면 예외가 발생합니다.</td>
<td>1초 (1,000ms)</td>
</tr>
</tbody></table>
<h2><span id="keonegsyeon-pul-sinario-seolmyeong">커넥션 풀 시나리오 설명</span><a href="#keonegsyeon-pul-sinario-seolmyeong" class="header-anchor">#</a></h2><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-1.png"></p>
<p><code>maximumPoolSize</code>가 10인 커넥션 풀을 가진 애플리케이션에서, 10명의 사용자가 각각 1초에 한 번씩 요청을 보낸다고 가정해보겠습니다. 각 요청은 약 1초가 소요됩니다. 아래 시나리오는 커넥션 풀의 상태를 각 단계별로 설명합니다.</p>
<h3><span id="keonegsyeon-pulyi-juyo-pildeu-mic-dongjag-sinario-bunseog">커넥션 풀의 주요 필드 및 동작 시나리오 분석</span><a href="#keonegsyeon-pulyi-juyo-pildeu-mic-dongjag-sinario-bunseog" class="header-anchor">#</a></h3><ul>
<li><strong>maximumPoolSize</strong>:<ul>
<li><strong>설명</strong>: 커넥션 풀에서 관리할 수 있는 최대 커넥션 수를 나타냅니다. 이 시나리오에서는 10개로 설정되어 있어, 동시에 최대 10개의 요청을 처리할 수 있습니다.</li>
<li><strong>이미지 설명</strong>: 이미지에서 <code>totalConnections = 10</code>으로 설정되어 있으며, 이는 커넥션 풀에서 관리할 수 있는 총 커넥션이 10개임을 의미합니다.</li>
</ul>
</li>
<li><strong>activeConnections</strong>:<ul>
<li><strong>설명</strong>: 현재 요청을 처리 중인 커넥션의 수입니다. 동시 요청이 10건 발생하면 <code>activeConnections</code>는 10이 됩니다. 더 이상 여유가 없는 상태에서 추가 요청이 들어오면 대기 상태가 됩니다.</li>
<li><strong>이미지 설명</strong>: 첫 번째 그림에서 <code>activeConnections = 1</code>로, 한 개의 요청이 활성화된 상태입니다. 두 번째 그림에서는 <code>activeConnections = 5</code>로, 5명이 동시에 요청을 보내고 있습니다. 세 번째 그림에서는 <code>activeConnections = 10</code>으로, 모든 커넥션이 활성화되어 추가 요청을 처리할 수 없는 상태입니다.</li>
</ul>
</li>
<li><strong>idleConnections</strong>:<ul>
<li><strong>설명</strong>: 유휴 상태로 대기 중인 커넥션의 수를 나타냅니다. 예를 들어, 첫 번째 요청이 처리될 때 <code>idleConnections</code>는 9개이며, 모든 커넥션이 활성화되면 <code>idleConnections</code>는 0이 됩니다.</li>
<li><strong>이미지 설명</strong>: 첫 번째 그림에서 <code>idleConnections = 9</code>로, 9개의 커넥션이 대기 상태입니다. 두 번째 그림에서는 <code>idleConnections = 5</code>, 세 번째 그림에서는 <code>idleConnections = 0</code>으로, 모든 커넥션이 사용 중인 상태입니다.</li>
</ul>
</li>
<li><strong>totalConnections</strong>:<ul>
<li><strong>설명</strong>: 커넥션 풀에서 관리하고 있는 총 커넥션 수로, <code>activeConnections</code>와 <code>idleConnections</code>의 합입니다. 이 값은 <code>maximumPoolSize</code> 내에서 유지되며, 동시 요청이 많을수록 <code>idleConnections</code>가 줄어듭니다.</li>
<li><strong>이미지 설명</strong>: 세 개의 그림 모두 <code>totalConnections = 10</code>으로, 이는 커넥션 풀에서 관리하는 커넥션이 총 10개임을 나타냅니다.</li>
</ul>
</li>
<li><strong>threadsAwaitingConnection</strong>:<ul>
<li><strong>설명</strong>: 커넥션이 모두 사용 중일 때 대기 중인 요청의 수를 나타냅니다. 예를 들어, 10명의 사용자가 모두 커넥션을 사용 중일 때 추가 요청이 발생하면, 그 요청은 대기 상태로 들어가 <code>threadsAwaitingConnection</code>이 증가합니다.</li>
<li><strong>이미지 설명</strong>: 마지막 그림에서는 모든 커넥션이 사용 중이기 때문에, 추가 요청이 발생하면 대기 상태로 들어가게 됩니다.</li>
</ul>
</li>
<li><strong>connectionTimeout</strong>:<ul>
<li><strong>설명</strong>: 대기 중인 요청이 커넥션을 얻기 위해 기다릴 수 있는 최대 시간을 나타냅니다. 예를 들어, <code>connectionTimeout</code>이 2초로 설정된 경우, 대기 중인 요청이 2초 내에 커넥션을 할당받지 못하면 요청은 실패하게 됩니다.</li>
<li><strong>이미지 설명</strong>: 마지막 그림에서 모든 커넥션이 사용 중인 상태에서 추가 요청이 들어오면, <code>connectionTimeout</code> 내에 커넥션을 할당받지 못할 경우 해당 요청은 실패하게 됩니다.</li>
</ul>
</li>
<li><strong>validationTimeout</strong>:<ul>
<li><strong>설명</strong>: 풀에서 커넥션을 빌려올 때 해당 커넥션이 유효한지 확인하는 시간입니다. 이 시간이 초과되면 해당 커넥션은 사용되지 않고 새로운 커넥션이 할당됩니다.</li>
<li><strong>이미지 설명</strong>: 유휴 상태로 오래 있던 커넥션은 유효성 검사에서 실패할 수 있으며, 이 경우 새로운 커넥션이 할당됩니다. 이미지에서는 유휴 상태의 커넥션들이 대기 중인 상태를 보여줍니다.</li>
</ul>
</li>
</ul>
<h2><span id="hikaricp-seoljeong-mic-sangtae-ceugjeong-saempeul-kodeu">HikariCP 설정 및 상태 측정 샘플 코드</span><a href="#hikaricp-seoljeong-mic-sangtae-ceugjeong-saempeul-kodeu" class="header-anchor">#</a></h2><p>Spring Boot 애플리케이션에서 HikariCP를 사용하는 방법을 설명합니다. HikariCP는 Spring Boot에서 기본적으로 사용하는 커넥션 풀로, 설정을 통해 다양한 커넥션 관리 옵션을 제공합니다. 또한, HikariCP의 상태를 측정할 수 있는 방법을 추가하여 커넥션 풀의 효율적인 관리가 가능합니다.</p>
<h3><span id="hikaricp-properties-seoljeong">HikariCP Properties 설정</span><a href="#hikaricp-properties-seoljeong" class="header-anchor">#</a></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">hikari:</span></span><br><span class="line">            <span class="attr">maximum-pool-size:</span> <span class="number">10</span>           <span class="comment"># 최대 커넥션 수</span></span><br><span class="line">            <span class="attr">minimum-idle:</span> <span class="number">10</span>                <span class="comment"># 최소 유휴 커넥션 수</span></span><br><span class="line">            <span class="attr">connection-timeout:</span> <span class="number">30000</span>       <span class="comment"># 커넥션을 가져올 때 대기할 최대 시간 (밀리초)</span></span><br><span class="line">            <span class="attr">max-lifetime:</span> <span class="number">1800000</span>           <span class="comment"># 커넥션이 유지될 최대 시간 (밀리초)</span></span><br><span class="line">            <span class="attr">idle-timeout:</span> <span class="number">600000</span>            <span class="comment"># 유휴 커넥션이 유지될 최대 시간 (밀리초)</span></span><br><span class="line">            <span class="attr">leak-detection-threshold:</span> <span class="number">2000</span>  <span class="comment"># 커넥션 리크를 감지할 기준 시간 (밀리초)</span></span><br><span class="line">            <span class="attr">pool-name:</span> <span class="string">Sample-HikariPool</span>    <span class="comment"># 커넥션 풀 이름</span></span><br><span class="line">            <span class="attr">auto-commit:</span> <span class="literal">true</span>               <span class="comment"># 자동 커밋 여부</span></span><br><span class="line">            <span class="attr">validation-timeout:</span> <span class="number">5000</span>        <span class="comment"># 커넥션 유효성 검사를 위한 최대 시간 (밀리초)</span></span><br><span class="line">            <span class="attr">read-only:</span> <span class="literal">false</span>                <span class="comment"># 읽기 전용 모드 여부</span></span><br><span class="line">            <span class="attr">isolate-internal-queries:</span> <span class="literal">false</span> <span class="comment"># 내부 쿼리 격리 여부</span></span><br><span class="line">            <span class="attr">allow-pool-suspension:</span> <span class="literal">false</span>    <span class="comment"># 커넥션 풀 일시 정지 허용 여부</span></span><br><span class="line">            <span class="attr">initialization-fail-timeout:</span> <span class="number">1</span>  <span class="comment"># 초기화 실패 시 타임아웃 (밀리초)</span></span><br></pre></td></tr></table></figure>

<h3><span id="hikaricp-sangtae-ceugjeong-kodeu">HikariCP 상태 측정 코드</span><a href="#hikaricp-sangtae-ceugjeong-kodeu" class="header-anchor">#</a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SampleService</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> dataSource: DataSource,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> memberRepository: MemberRepository</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> log = LoggerFactory.getLogger(javaClass)!!</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getMember</span><span class="params">()</span></span>: Member &#123;</span><br><span class="line">        <span class="keyword">val</span> member = memberRepository.findById(Random.nextInt(<span class="number">1</span>, <span class="number">101</span>).toLong()).<span class="keyword">get</span>()</span><br><span class="line">        runBlocking &#123; delay(<span class="number">1000</span>) &#125;</span><br><span class="line">        <span class="keyword">val</span> targetDataSource = dataSource.unwrap(HikariDataSource::<span class="keyword">class</span>.java)</span><br><span class="line">        <span class="keyword">val</span> hikariDataSource = targetDataSource <span class="keyword">as</span> HikariDataSource</span><br><span class="line">        <span class="keyword">val</span> hikariPoolMXBean = hikariDataSource.hikariPoolMXBean</span><br><span class="line">        <span class="keyword">val</span> hikariConfigMXBean = hikariDataSource.hikariConfigMXBean</span><br><span class="line">        <span class="keyword">val</span> log =</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            totalConnections : <span class="subst">$&#123;hikariPoolMXBean.totalConnections&#125;</span></span></span><br><span class="line"><span class="string">            activeConnections : <span class="subst">$&#123;hikariPoolMXBean.activeConnections&#125;</span></span></span><br><span class="line"><span class="string">            idleConnections : <span class="subst">$&#123;hikariPoolMXBean.idleConnections&#125;</span></span></span><br><span class="line"><span class="string">            threadsAwaitingConnection : <span class="subst">$&#123;hikariPoolMXBean.threadsAwaitingConnection&#125;</span></span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.log.info(log)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> member</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이 코드에서는 먼저 <code>DataSource</code>를 <code>HikariDataSource</code>로 변환한 후, <code>HikariPoolMXBean</code>과 <code>HikariConfigMXBean</code>을 사용하여 커넥션 풀의 상태를 확인합니다. 이를 통해 총 커넥션 수, 활성 커넥션 수, 유휴 커넥션 수, 그리고 대기 중인 스레드 수와 같은 정보를 가져옵니다. 또한, <code>runBlocking &#123; delay(1000) &#125;</code>을 사용하여 1초간의 지연을 추가함으로써, 실제 요청이 처리되는 동안 커넥션 풀의 상태를 보다 명확하게 모니터링할 수 있습니다. 마지막으로, 이러한 커넥션 풀의 상태를 로그로 출력하여 애플리케이션의 성능을 모니터링하고, 필요한 경우 성능을 조정할 수 있는 정보를 제공합니다.</p>
<h2><span id="connection-pool-ceugjeong">Connection Pool 측정</span><a href="#connection-pool-ceugjeong" class="header-anchor">#</a></h2><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-2.png"></p>
<p>애플리케이션에서 커넥션 풀을 사용할 때, 커넥션 풀의 상태를 지속적으로 모니터링하는 것은 매우 중요합니다. 아래와 같은 로그는 **10 TPS (초당 트랜잭션)**를 지속적으로 유지할 때 발생한 로그입니다. 이때 평균 응답 시간은 약 1,000ms로 나타나며, 이는 TPS 수준을 고려했을 때 시스템이 적정 수준에서 작동하고 있음을 보여줍니다.</p>
<ul>
<li><p><strong>로그 1</strong>:</p>
<ul>
<li><code>totalConnections = 10</code></li>
<li><code>activeConnections = 7</code></li>
<li><code>idleConnections = 3</code></li>
<li><code>threadsAwaitingConnection = 0</code></li>
</ul>
<p>이 상태는 <strong>총 10개의 커넥션</strong> 중 <strong>7개가 활성화</strong>되어 요청을 처리하고 있으며, <strong>3개의 유휴 커넥션</strong>이 대기 중인 상황입니다. 모든 요청이 원활하게 처리되고 있기 때문에, 대기 중인 스레드는 없습니다.</p>
</li>
<li><p><strong>로그 2</strong>:</p>
<ul>
<li><code>totalConnections = 10</code></li>
<li><code>activeConnections = 10</code></li>
<li><code>idleConnections = 0</code></li>
<li><code>threadsAwaitingConnection = 4</code></li>
</ul>
<p>이 상태는 <strong>모든 10개의 커넥션이 활성화</strong>되어 요청을 처리 중이며, 더 이상 유휴 커넥션이 남아있지 않습니다. 이때 <strong>4개의 추가 요청이 들어와 대기</strong> 중입니다. <code>threadsAwaitingConnection</code> 값이 4로 증가한 이유는, 요청을 처리할 수 있는 유휴 커넥션이 없기 때문입니다.</p>
</li>
</ul>
<h3><span id="keonegsyeon-pul-dongjag-mic-taimaus-balsaeng">커넥션 풀 동작 및 타임아웃 발생</span><a href="#keonegsyeon-pul-dongjag-mic-taimaus-balsaeng" class="header-anchor">#</a></h3><p>커넥션 풀이 설정된 <code>maximumPoolSize</code>만큼 활성화된 경우, 그 이후에 들어오는 요청은 <strong>대기 상태</strong>에 들어가게 됩니다. 이때 <strong>대기 시간이 길어질 수 있으며</strong>, 이러한 대기 시간이 너무 길어지면 <strong>타임아웃</strong>이 발생할 수 있습니다. 타임아웃이 발생하는 주요 원인은 다음과 같습니다.</p>
<p><strong>connection-timeout</strong>은 커넥션을 얻기 위해 스레드가 대기할 수 있는 최대 시간을 의미합니다. 예를 들어, <code>connection-timeout</code>이 30초로 설정되어 있다면, 커넥션 풀이 사용 가능한 커넥션을 30초 동안 제공하지 못할 경우 타임아웃이 발생하게 됩니다. 이 설정은 대기 중인 요청이 얼마 동안 기다릴 수 있는지를 제한합니다.</p>
<p>커넥션 풀은 <strong>한정된 자원</strong>을 효율적으로 관리하여 시스템의 안정성을 유지하는 좋은 방법입니다. 그러나, 만약 요청량이 설정된 <code>maximumPoolSize</code>를 초과하게 되면 대기 상태가 발생할 수 있습니다. 이러한 상황을 방지하기 위해 적절한 <strong>타임아웃</strong> 값을 설정하고, 필요에 따라 풀 크기를 조정하는 것이 중요합니다.</p>
<h3><span id="connection-timeout-seoljeonggwa-tps-jeunggaro-inhan-oryu-balsaeng">connection-timeout 설정과 TPS 증가로 인한 오류 발생</span><a href="#connection-timeout-seoljeonggwa-tps-jeunggaro-inhan-oryu-balsaeng" class="header-anchor">#</a></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">hikari:</span></span><br><span class="line">            <span class="attr">maximum-pool-size:</span> <span class="number">10</span>         <span class="comment"># 최대 커넥션 수</span></span><br><span class="line">            <span class="attr">minimum-idle:</span> <span class="number">10</span>              <span class="comment"># 최소 유휴 커넥션 수</span></span><br><span class="line">            <span class="attr">connection-timeout:</span> <span class="number">250</span>       <span class="comment"># 커넥션을 가져올 때 대기할 최대 시간 (밀리초)</span></span><br></pre></td></tr></table></figure>

<p>위 설정에서 <code>connection-timeout</code>을 250ms로 지정한 경우, <strong>TPS</strong>가 10을 초과하게 되면 <strong>threadsAwaitingConnection</strong>에 대기하는 시간이 250ms를 넘을 수 있습니다. 이 상황이 발생하면, 커넥션 풀은 설정된 대기 시간보다 오래 걸리기 때문에 타임아웃 오류가 발생하게 됩니다.</p>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-3.png"></p>
<p>이미지에서와 같이, <code>RPS</code>(Request Per Second)가 10 이상일 때 커넥션 풀의 한계로 인해 대기 중인 요청이 발생하고, 그 대기 시간이 <code>250ms</code>를 초과하면 오류가 발생합니다. 이때 <code>Failures/s</code>가 증가하는 것을 확인할 수 있습니다. 이는 타임아웃 설정과 관련이 있으며, 커넥션 풀의 자원 한계와 처리량을 적절히 맞춰야 하는 이유를 보여줍니다.</p>
<p><strong>오류 메시지 예시</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.sql.SQLTransientConnectionException: Sample-HikariPool - Connection is not available, request timed out after 251ms.</span><br><span class="line">	at com.zaxxer.hikari.pool.HikariPool.createTimeoutException(HikariPool.java:696) ~[HikariCP-4.0.3.jar:na]</span><br><span class="line">	at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:197) </span><br></pre></td></tr></table></figure>

<p>이 오류는 대기 시간이 설정된 <code>connection-timeout</code>을 초과했음을 의미하며, 커넥션 풀이 추가 요청을 처리할 수 없다는 것을 나타냅니다. 이 문제를 해결하기 위해 여러 가지 방법을 고려할 수 있습니다.</p>
<h2><span id="connection-pool-munje-haegyeolbangbeob">Connection Pool 문제 해결방법</span><a href="#connection-pool-munje-haegyeolbangbeob" class="header-anchor">#</a></h2><p>애플리케이션에서 <strong>Connection Pool</strong>은 안정적인 데이터베이스 연결을 관리하는 데 매우 중요한 역할을 합니다. 하지만 시스템 부하가 높거나 설정이 적절하지 않은 경우, 커넥션 풀에서 발생하는 문제로 인해 성능 저하나 타임아웃 오류가 발생할 수 있습니다. 이러한 문제를 해결하기 위해서는 몇 가지 핵심적인 접근 방식을 취할 수 있습니다.</p>
<ol>
<li><strong>쿼리 최적화</strong>: 데이터베이스 성능 문제는 종종 비효율적인 쿼리로 인해 발생합니다. 쿼리 최적화는 애플리케이션의 응답 시간을 줄이고, 커넥션이 오랫동안 점유되는 상황을 방지할 수 있는 중요한 방법입니다. 인덱스를 추가하거나 복잡한 쿼리 구조를 단순화하는 것 등이 이에 해당합니다.</li>
<li><strong>connection-timeout 시간 조정</strong>: 커넥션 타임아웃은 대기 중인 요청이 커넥션을 얻기 위해 얼마나 오랜 시간 기다릴 수 있는지를 결정합니다. 이 시간을 적절히 설정함으로써 대기 중인 요청들이 효율적으로 처리되도록 할 수 있습니다. 너무 짧은 타임아웃은 오류를 유발할 수 있고, 너무 긴 타임아웃은 응답 지연을 초래할 수 있으므로, 상황에 맞게 타임아웃을 조정해야 합니다.</li>
<li><strong>maximum-pool-size 증가</strong>: 예상되는 트래픽에 맞춰 커넥션 풀의 최대 크기를 늘림으로써 동시 요청 처리 성능을 향상시킬 수 있습니다. 그러나 자원 낭비를 방지하기 위해 시스템의 메모리와 CPU 사용량을 신중하게 고려하여 최적의 크기를 설정하는 것이 중요합니다.</li>
</ol>
<p>이와 같은 방법을 적절히 적용하면 Connection Pool 문제를 해결하고, 애플리케이션의 성능과 안정성을 크게 향상시킬 수 있습니다. 아래에서는 이 세 가지 접근 방법을 구체적으로 다루고, 실제 적용 사례를 통해 성능 최적화 방법을 설명합니다.</p>
<h3><span id="kweori-coejeoghwa">쿼리 최적화</span><a href="#kweori-coejeoghwa" class="header-anchor">#</a></h3><p><strong>쿼리 최적화</strong>는 데이터베이스 성능 향상에 있어 중요한 단계입니다. 특히, 애플리케이션에서 <code>activeConnections</code>가 빠르게 응답하지 못하는 경우, 그 원인이 복잡한 쿼리 처리에 있다면 쿼리 최적화를 통해 성능을 크게 개선할 수 있습니다. 잘못 설계된 쿼리나 불필요하게 긴 실행 시간을 가진 쿼리는 시스템 전반의 성능에 영향을 미치고, 커넥션 풀의 자원을 오래 점유하게 되어 <strong>대기 중인 요청</strong>들이 지연되는 상황을 초래할 수 있습니다.</p>
<p>다음과 같은 방식으로 쿼리를 최적화함으로써 응답 속도를 개선할 수 있습니다:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMember</span><span class="params">()</span></span>: Member &#123;</span><br><span class="line">    <span class="keyword">val</span> member = memberRepository.findById(Random.nextInt(<span class="number">1</span>, <span class="number">101</span>).toLong()).<span class="keyword">get</span>()</span><br><span class="line">    <span class="comment">// runBlocking &#123; delay(1000) &#125; 블록킹 코드 제거</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> member</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드에서 불필요한 블로킹 코드인 <code>runBlocking &#123; delay(1000) &#125;</code>를 제거함으로써 쿼리 실행 지연을 없앴습니다. 이와 같이, 쿼리 최적화는 단순히 코드 내의 블로킹 요소를 제거하는 것뿐만 아니라, <strong>인덱스 추가</strong>, <strong>복잡한 조인 구조 단순화</strong>, <strong>캐싱</strong> 등을 통해 데이터베이스에 대한 부하를 줄이는 방법도 포함됩니다. 이러한 최적화 작업을 통해 쿼리 실행 시간이 줄어들면 커넥션이 더 빨리 반환되고, <strong>대기 중인 요청이 빠르게 처리</strong>될 수 있습니다.</p>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-4.png"></p>
<p>쿼리 최적화를 통해 성능이 향상되면, <strong>connection-timeout</strong>이 250ms로 설정된 상황에서도 <strong>RPS가 20</strong>인 경우처럼 높은 요청 처리량에서도 타임아웃 오류가 발생하지 않게 됩니다. 이는 쿼리가 최적화되면 커넥션이 더 빠르게 반환되기 때문에, 커넥션 풀 내에서 더 많은 요청을 동시에 처리할 수 있기 때문입니다.</p>
<p>최적화된 쿼리는 커넥션 점유 시간을 줄여 <strong>connection-timeout</strong> 설정의 제한을 넘지 않도록 도와주며, 결과적으로 더 많은 트랜잭션을 안정적으로 처리할 수 있게 됩니다. 따라서, 쿼리 최적화는 애플리케이션 성능을 유지하고 향상시키는 중요한 방법입니다.</p>
<p>결론적으로, <strong>쿼리 최적화</strong>는 데이터베이스 성능 개선뿐만 아니라, 커넥션 풀 자원 관리에도 매우 중요한 역할을 합니다. 불필요한 대기 시간을 줄이고, 시스템이 고부하 상황에서도 원활하게 작동할 수 있도록 돕습니다.</p>
<h3><span id="connection-timeout-sigan-jojeong">connection-timeout 시간 조정</span><a href="#connection-timeout-sigan-jojeong" class="header-anchor">#</a></h3><p><code>connection-timeout</code> 설정은 대기 중인 요청이 커넥션을 얻기 위해 기다릴 수 있는 시간을 조정하는 중요한 요소입니다. 만약 요청량이 많아 <strong>maximumPoolSize</strong>에 도달했을 때, <code>connection-timeout</code>을 적절히 늘려주면 대기 중인 요청이 커넥션을 할당받기까지 더 오랜 시간을 허용할 수 있습니다. 예를 들어, <code>connection-timeout</code>을 250ms에서 2,500ms로 늘리면, 커넥션 반환 대기 시간을 더 길게 설정함으로써 <strong>타임아웃 오류</strong>를 줄일 수 있습니다. 하지만, 너무 긴 대기 시간을 설정하면 그만큼 <strong>응답 시간이 지연</strong>될 수 있으므로 신중하게 설정해야 합니다.</p>
<p>아래는 <code>connection-timeout</code>을 2,500ms로 설정하고 테스트한 설정 예시입니다:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">hikari:</span></span><br><span class="line">            <span class="attr">maximum-pool-size:</span> <span class="number">10</span>         <span class="comment"># 최대 커넥션 수</span></span><br><span class="line">            <span class="attr">minimum-idle:</span> <span class="number">10</span>              <span class="comment"># 최소 유휴 커넥션 수</span></span><br><span class="line">            <span class="attr">connection-timeout:</span> <span class="number">2500</span>      <span class="comment"># 커넥션을 가져올 때 대기할 최대 시간 (밀리초)</span></span><br></pre></td></tr></table></figure>

<p>이 설정에서, <code>delay(1000)</code>는 유지하면서 <code>connection-timeout</code>을 2,500ms로 변경한 후 테스트를 진행하였습니다.</p>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-6.png"></p>
<p>테스트 결과는 아래와 같습니다:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">totalConnections : 10</span><br><span class="line">maximumPoolSize : 10</span><br><span class="line">activeConnections : 10</span><br><span class="line">idleConnections : 0</span><br><span class="line">threadsAwaitingConnection : 20</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>totalConnections</strong>: 10개 커넥션이 모두 사용 중입니다.</li>
<li><strong>maximumPoolSize</strong>: 설정된 최대 커넥션 수는 10개입니다.</li>
<li><strong>activeConnections</strong>: 현재 10개의 커넥션이 활성화되어 있습니다.</li>
<li><strong>idleConnections</strong>: 유휴 커넥션이 없으며, 모든 커넥션이 사용 중입니다.</li>
<li><strong>threadsAwaitingConnection</strong>: 20개의 요청이 대기 중입니다.</li>
</ul>
<p><strong>connection-timeout</strong> 설정이 2,500ms로 변경됨에 따라, <strong>threadsAwaitingConnection</strong>에서 대기하는 시간이 길어졌습니다. 결과적으로 <strong>타임아웃 오류는 발생하지 않았지만</strong>, 응답 시간이 더 길어졌습니다. 이는 각 요청에 대해 <code>delay(1000)</code>으로 인한 1,000ms의 블로킹 시간과 <strong>threadsAwaitingConnection</strong>에서 대기한 시간이 합쳐져 응답 시간이 느려진 것입니다.</p>
<p>이런 경우, 타임아웃을 길게 설정하는 것은 타임아웃 오류를 방지할 수 있지만, 동시에 <strong>응답 속도</strong>가 저하될 수 있습니다. 따라서, <strong>connection-timeout</strong>은 요청의 특성과 트래픽 패턴에 맞추어 적절한 값을 설정하는 것이 매우 중요합니다.</p>
<h3><span id="maximum-pool-size-jeungga">maximum-pool-size 증가</span><a href="#maximum-pool-size-jeungga" class="header-anchor">#</a></h3><p>애플리케이션에서 처리할 수 있는 동시 요청 수가 많아질 것으로 예상된다면, <code>maximum-pool-size</code>를 늘려 커넥션 풀에서 더 많은 커넥션을 생성하고 유지할 수 있도록 설정할 수 있습니다. 예를 들어, 트래픽이 예상보다 많아지거나, 동시성 처리가 많이 요구되는 상황에서는 커넥션 풀 크기를 늘려주는 것이 유리합니다. 이를 통해 더 많은 요청을 동시에 처리할 수 있게 됩니다. 그러나, 무작정 풀 크기를 크게 설정하는 것은 <strong>자원 낭비</strong>를 초래할 수 있습니다. 커넥션 풀 크기가 커지면 더 많은 메모리와 CPU가 필요하기 때문에, <strong>시스템의 자원 사용량</strong>을 신중히 고려한 후에 조정하는 것이 중요합니다.</p>
<p>예를 들어, <code>maximum-pool-size</code>를 100으로 설정하고, 1,000ms 대기 코드를 다시 활성화시키며 <code>connection-timeout</code>을 250ms로 유지했음에도 불구하고, 오류가 발생하지 않는 상황을 가정해보겠습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMember</span><span class="params">()</span></span>: Member &#123;</span><br><span class="line">  <span class="keyword">val</span> member = memberRepository.findById(Random.nextInt(<span class="number">1</span>, <span class="number">101</span>).toLong()).<span class="keyword">get</span>()</span><br><span class="line">  runBlocking &#123; delay(<span class="number">1000</span>) &#125;  <span class="comment">// 1,000ms 대기</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> member</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이 코드에서는 <code>runBlocking &#123; delay(1000) &#125;</code>를 통해 각 요청마다 1초의 지연을 발생시키고 있지만, <code>maximum-pool-size</code>를 충분히 높게 설정함으로써 동시 요청이 몰리는 상황에서도 타임아웃 오류가 발생하지 않습니다. 아래와 같은 로그를 통해 확인할 수 있습니다.</p>
<p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-5.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">totalConnections : 30</span><br><span class="line">maximumPoolSize : 100</span><br><span class="line">activeConnections : 13</span><br><span class="line">idleConnections : 17</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>totalConnections</strong>: 현재 커넥션 풀에서 관리되고 있는 커넥션의 총 개수로, 현재 30개가 할당되어 있는 상태입니다.</li>
<li><strong>maximumPoolSize</strong>: 커넥션 풀에서 설정된 최대 커넥션 수는 100입니다. 하지만, 모든 커넥션이 필요하지 않기 때문에 100까지 차지 않고 있는 상황입니다.</li>
<li><strong>activeConnections</strong>: 현재 요청을 처리 중인 활성 커넥션 수는 13개입니다.</li>
<li><strong>idleConnections</strong>: 유휴 상태로 대기 중인 커넥션 수는 17개로, 요청이 추가로 들어오면 이 커넥션들이 활성화될 수 있습니다.</li>
</ul>
<p>이 상황에서는 <strong>maximumPoolSize</strong>가 100으로 설정되어 있지만, 모든 커넥션이 사용 중이지 않기 때문에 <strong>자원 낭비를 최소화</strong>할 수 있습니다. 요청이 몰리지 않는 상태에서는 <code>activeConnections</code>가 13개에 머무르고, 나머지 17개는 유휴 상태로 남아있습니다. 이처럼 <strong>최대 커넥션 수</strong>는 설정했지만, 필요할 때만 커넥션이 활성화되고 나머지는 유휴 상태를 유지하는 방식으로 효율적인 자원 관리가 가능합니다.</p>
<p>따라서, <code>maximum-pool-size</code>는 트래픽이 몰릴 경우를 대비해 충분히 큰 값으로 설정할 수 있지만, 시스템 자원에 부담을 주지 않도록 <strong>실제 트래픽</strong>과 <strong>자원 사용량</strong>을 분석하여 적절한 값으로 설정하는 것이 중요합니다.</p>
<h2><span id="gyeolron">결론</span><a href="#gyeolron" class="header-anchor">#</a></h2><p>HikariCP를 사용한 <strong>MySQL 커넥션 풀 관리</strong>는 애플리케이션 성능 최적화의 핵심 요소입니다. 적절한 커넥션 풀 설정을 통해 데이터베이스와의 연결을 효율적으로 관리하고, 불필요한 연결 재생성을 피하며, 응답 시간을 단축할 수 있습니다. 그러나, <strong>maximumPoolSize</strong>와 <strong>connection-timeout</strong>과 같은 설정이 적절하지 않으면, 트래픽이 증가할 때 커넥션 풀에서 대기 시간이 늘어나거나 타임아웃 오류가 발생할 수 있습니다.</p>
<p>이를 방지하고 시스템 성능을 최적화하기 위해 다음과 같은 중요한 포인트를 기억해야 합니다.</p>
<ol>
<li><strong>쿼리 최적화</strong>: 쿼리의 성능이 느릴 경우 <code>activeConnections</code>가 불필요하게 오래 점유되며, 전체 시스템의 성능을 저하시킬 수 있습니다. 쿼리를 최적화하여 커넥션을 빠르게 반환하면 대기 중인 요청도 신속하게 처리할 수 있습니다.</li>
<li><strong>maximum-pool-size 설정</strong>: <strong>maximum-pool-size</strong>는 동시 처리할 수 있는 최대 요청 수를 결정합니다. 트래픽 예측에 맞춰 적절히 풀 크기를 늘리는 것은 중요하지만, 자원 낭비를 방지하기 위해 너무 크게 설정하지 않는 것이 좋습니다. 실제로 필요할 때만 커넥션이 활성화되는 방식으로 자원을 효율적으로 관리해야 합니다.</li>
<li><strong>connection-timeout 설정</strong>: <strong>connection-timeout</strong> 값은 대기 중인 요청이 커넥션을 얻기 위해 기다릴 수 있는 최대 시간을 결정합니다. 이 값을 너무 낮게 설정하면 트래픽이 몰릴 때 타임아웃 오류가 자주 발생할 수 있으며, 반대로 너무 길게 설정하면 응답 시간이 지연될 수 있습니다. 트래픽 패턴에 맞춰 적절한 값을 설정하는 것이 중요합니다.</li>
<li><strong>TPS 모니터링</strong>: 초당 처리량(TPS)을 지속적으로 모니터링하고, 트래픽 패턴을 기반으로 HikariCP 설정을 조정해야 합니다. 이를 통해 애플리케이션이 다양한 부하 상황에서도 원활하게 작동할 수 있도록 합니다.</li>
</ol>
<p>최종적으로, 커넥션 풀 설정을 조정할 때는 트래픽 패턴과 시스템 자원을 고려하여 <strong>최적화된 값</strong>을 설정하는 것이 필수적입니다. 이를 통해 <strong>응답 속도 지연</strong> 및 <strong>타임아웃 오류</strong>를 최소화할 수 있으며, 안정적인 시스템 운영과 함께 애플리케이션의 성능을 극대화할 수 있습니다.</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">태그</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/Connection-Pool/" rel="tag">Connection Pool</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/MySQL/" rel="tag">MySQL</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/Performance/" rel="tag">Performance</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/mysql-connection-pool-timeout-1/"
                    data-tooltip="HikariCP로 MySQL Connection Pool 최적화하기"
                    aria-label="이전: HikariCP로 MySQL Connection Pool 최적화하기"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/kotlin-flow/"
                    data-tooltip="코루틴을 이용한 성능 개선 - Flow를 활용한 다중 요청 처리"
                    aria-label="다음: 코루틴을 이용한 성능 개선 - Flow를 활용한 다중 요청 처리"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/mysql-connection-pool-timeout/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/mysql-connection-pool-timeout/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        

                
                    <!--  utteranc comment -->

<script src="https://utteranc.es/client.js"
        repo="cheese10yun/blog-comment"
        issue-term="title"
        label="Comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

                

            
        
    </div>
</article>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Yun. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/mysql-connection-pool-timeout-1/"
                    data-tooltip="HikariCP로 MySQL Connection Pool 최적화하기"
                    aria-label="이전: HikariCP로 MySQL Connection Pool 최적화하기"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/kotlin-flow/"
                    data-tooltip="코루틴을 이용한 성능 개선 - Flow를 활용한 다중 요청 처리"
                    aria-label="다음: 코루틴을 이용한 성능 개선 - Flow를 활용한 다중 요청 처리"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/mysql-connection-pool-timeout/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/mysql-connection-pool-timeout/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="5">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/mysql-connection-pool-timeout/"
                        aria-label="Facebook에 공유하기"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Facebook에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/mysql-connection-pool-timeout/"
                        aria-label="Twitter에 공유하기"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Twitter에 공유하기</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
            <h4 id="about-card-name">Yun</h4>
        
            <div id="about-card-bio"><p>기술 블로그</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
