
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="naver-site-verification" content="a37ea649edf26e70c3de94f9cb034f9d6e11de3f" />
    <meta name="generator" content="Yun Blog">
    <title>Kotlin 자주 사용하는 패턴 정리 - Yun Blog</title>
    <meta name="author" content="Yun">
    
        <meta name="keywords" content="Node,Spring,Spring Boot,Spring Batch,Kotlin,기술 블로그,JPA,Mongo,MySQL,OOP,">
    
    
    
        
            <link rel="alternate" type="application/rss+xml" title="RSS" href="/rss2.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg"},"articleBody":"불변 객체의 효율적 관리: copy() 메소드 활용#불변 객체는 데이터의 안정성과 예측 가능성을 제공하여 소프트웨어 개발에서 권장되는 패턴입니다. 특히, 암호화와 같은 데이터의 보안적 처리에 있어서 불변 객체를 사용하면 변경될 필요가 없는 정보의 무결성을 유지할 수 있습니다. Kotlin의 data class는 이러한 불변 객체를 다루기 위한 유용한 기능 중 하나로 copy() 메소드를 제공합니다. 이 메소드를 사용하면 객체의 일부만을 변경한 새로운 객체를 생성할 수 있어, 기존 객체의 불변성을 해치지 않으면서 필요한 부분만 업데이트가 가능합니다.\n코드 예시 및 설명#아래의 테스트 코드는 User라는 데이터 클래스의 인스턴스를 생성한 후, copy() 메소드를 사용하여 이메일 주소만을 암호화된 형태로 변경하는 예를 보여줍니다.\n123456789101112131415161718192021@Testfun `불변 객체의 유지보수를 위한 copy 활용 예시`() &#123;    val user = User(        name = &quot;name&quot;,        email = &quot;email@asd.com&quot;    )    val userCopy = user.copy(        email = &quot;email@asd.com 암호화&quot;    )    // User(name=name, email=email@asd.com)    println(&quot;user: $user&quot;)    // User(name=name, email=email@asd.com 암호화)    println(&quot;userCopy: $userCopy&quot;)    // 428039780    println(&quot;user: $&#123;System.identityHashCode(user)&#125;&quot;)    // 48361312    println(&quot;userCopy: $&#123;System.identityHashCode(userCopy)&#125;&quot;)&#125;\n\n\n원본 객체 출력: user: User(name=name, email=email@asd.com)\n복사 후 업데이트된 객체 출력: userCopy: User(name=name, email=email@asd.com 암호화)\n객체 식별자 비교: 두 객체의 System.identityHashCode 값을 출력하여 각각 다른 객체임을 확인할 수 있습니다.\n\n포인트 정리#\ncopy() 메소드는 원본 객체의 일부 속성을 변경하여 새로운 객체를 생성합니다. 이 방식은 기존 객체의 불변성을 유지하면서 필요한 데이터만 갱신할 수 있는 효율적인 방법을 제공합니다.\nval 키워드를 사용하여 불변성을 명시하는 것은 데이터 보호 및 버그 방지에 중요합니다. 특히 암호화와 같이 데이터 보안이 중요한 작업에서는 불변 객체의 사용이 더욱 중요합니다.\n\n이 방법은 데이터의 무결성을 유지하면서도 효율적인 데이터 관리를 가능하게 하여, 유지보수성을 높이고 시스템의 안정성을 강화합니다. 불변 객체와 copy() 메소드의 적절한 사용은 모던 소프트웨어 개발의 중요한 측면 중 하나입니다.\nPair와 Triple 객체의 유용성과 효율적 사용#코틀린에서는 간단한 객체를 빠르게 생성하고 사용할 수 있도록 Pair와 Triple이라는 두 가지 유틸리티 클래스를 제공합니다. 이러한 클래스는 특히 서비스 내부 로직에서만 사용되는 임시 데이터를 다룰 때, 매번 새로운 DTO(Data Transfer Object)를 만드는 것보다 더 효율적일 수 있습니다. 또한, 멀티 모듈 프로젝트에서 여러 모듈 간에 DTO 클래스를 공유해야 할 때 이러한 객체의 사용이 유용합니다.\n코드 예시 및 설명#다음은 UserPointCalculator 클래스의 구현 예시입니다. 이 클래스는 사용자 정보를 MySQL 데이터베이스에서 가져오고, 사용자의 포인트 정보는 Redis에서 가져와 계산을 진행합니다. 이 과정에서 Triple 객체를 활용하여 각 사용자의 이름, 이메일, 포인트 정보를 효과적으로 관리합니다.\n12345678910111213141516171819202122class UserPointCalculator(    private val userRepository: UserRepository,    private val userPointRepository: UserPointRepository) &#123;    fun calculate() &#123;        val users = userRepository.findUserByIds(listOf(1, 2, 3))        val points = userPointRepository.findUserPoint(listOf(1, 2, 3))            .associateBy &#123; it.id &#125;        val userPoints = users.map &#123;            Triple(                first = it.name,                second = it.email,                third = points[it.id]!!.point            )        &#125;        for (userPoint in userPoints) &#123;            println(&quot;user name: $&#123;userPoint.first&#125;, user email  $&#123;userPoint.second&#125;, user point  $&#123;userPoint.third&#125;&quot;)        &#125;    &#125;&#125;\n\n분석: 이 예에서 Triple 객체는 각 사용자의 이름, 이메일, 포인트를 저장하는데 사용됩니다. 이는 데이터베이스와 다른 저장소에서 정보를 읽어와 조합할 때 유용하게 사용됩니다.\nPair와 Triple 사용 시 가독성 향상#Pair와 Triple은 기본적으로 first, second, third라는 속성명을 사용합니다. 이 속성명은 코드의 가독성을 저하시킬 수 있으므로, 구조 분해 할당(destructuring declaration)을 사용하여 보다 의미 있는 변수명을 사용하는 것이 좋습니다.\n12345678fun calculate() &#123;    // 반복 처리    for ((userName, userEmail, userPoint) in userPoints) &#123;        println(&quot;user name: $&#123;userName&#125;, user email $&#123;userEmail&#125;, user point $userPoint&quot;)    &#125;    // 개별 처리    val (userName, userEmail, userPoint) = userPoints.first()&#125;\n\n이와 같은 처리 방식은 Pair와 Triple을 사용할 때 코드의 명확성을 향상시키고, 데이터를 보다 효율적으로 다루는 데 도움이 됩니다. 데이터를 직관적으로 알아볼 수 있도록 이름을 명확하게 지정함으로써, 코드의 가독성과 유지보수성을 크게 개선할 수 있습니다.\n이 방법은 간단한 데이터 구조를 사용하면서도 프로그램의 복잡성을 줄이고, 클린 코드를 유지하는 데 기여합니다.\n포인트 정리#Pair와 Triple 객체는 임시 데이터 또는 내부 로직에서만 사용되는 데이터를 간편하게 다루기 위한 우수한 도구입니다. 이들은 DTO를 정의하는 복잡성을 피할 수 있으며, 특히 간단한 데이터 그룹을 빠르게 다루어야 할 때 효율적입니다. 하지만, 이들을 사용할 때는 변수명을 명확하게 지정하여 코드의 가독성을 유지하는 것이 중요합니다.\n이 글은 Pair와 Triple 객체의 적절한 사용 사례를 통해 개발자들이 코드의 간결성과 유지보수성을 향상시키는 방법을 제시합니다.\ntypealias를 활용한 코드 개선#코틀린의 typealias 기능은 복잡한 타입 선언에 대한 간결하고 의미 있는 이름을 제공함으로써 코드의 가독성과 유지보수성을 크게 향상시킵니다. 특히, 프로젝트 내에서 자주 사용되는 타입 조합에 별칭을 부여함으로써, 코드의 일관성을 유지하고 타입 변경 시의 유연성을 높일 수 있습니다.\n코드 예시 및 설명#다음 예제에서는 사용자 정보(User)와 사용자의 포인트(UserPoint)를 연결하는 Pair에 UserPointAssociation이라는 typealias를 사용합니다. 이는 Pair&lt;User, UserPoint&gt;의 사용을 간소화하고, 의미를 명확히 합니다.\n12345678910typealias UserPointAssociation = Pair&lt;User, UserPoint&gt;val userPointAssociations = users.map &#123;    UserPointAssociation(        first = it,        second = points[it.id]!!    )&#125;val (user, userPoint) = userPointAssociations.first()\n\n\nUserPointAssociation 타입 별칭은 Pair&lt;User, UserPoint&gt;를 대체하여 코드의 목적을 더 명확하게 표현합니다.\nmap 함수 내에서 UserPointAssociation 생성자를 사용하여 각 사용자와 해당 포인트 객체를 쌍으로 묶습니다. 이는 데이터의 논리적 연관성을 직관적으로 보여줍니다.\n구조 분해 할당을 통해 user와 userPoint 변수에 각각 사용자 정보와 포인트 정보를 할당함으로써, 코드의 가독성을 더욱 향상시킵니다.\n\n포인트 정리#\n명확성: UserPointAssociation과 같은 타입 별칭을 사용하면, 복잡한 타입 조합도 의미 있는 이름으로 대체되어 코드의 목적이 분명해집니다.\n유연성: 타입 별칭을 사용하면, 기본 타입 구조에 변경이 필요할 때 별칭 정의만 수정하면 되므로 코드 전체에 걸쳐 유연하게 변경을 적용할 수 있습니다.\n재사용성: 일단 정의된 타입 별칭은 프로젝트 전반에 걸쳐 재사용될 수 있으며, 코드의 일관성을 유지하는 데 도움이 됩니다.\n\ntypealias는 복잡한 타입을 간소화하고, 코드의 의도를 명확히 전달하는 데 큰 도움을 줍니다. 이는 특히 크고 복잡한 프로젝트에서 타입 관리를 효과적으로 수행하는 데 중요한 역할을 합니다.\nrunCatching 함수와 Result 객체를 활용한 안전한 처리#코틀린의 runCatching 함수는 예외 발생 가능성이 있는 코드 블록을 실행하고 그 결과를 Result 타입으로 캡처합니다. 이 기능은 HTTP 통신과 같은 네트워크 요청에서 매우 유용하게 사용될 수 있습니다. Result 객체는 성공적인 결과 또는 발생한 예외를 안전하게 처리할 수 있는 API를 제공합니다.\n코드 예시 및 설명#다음 예제는 HTTP API를 통해 사용자 데이터를 요청하고 결과를 처리하는 과정을 보여줍니다:\n12345fun getUser(userId: Long): User &#123;    return runCatching &#123; userClient.getUser(userId) &#125;        .onFailure &#123; throw IllegalArgumentException(&quot;Failed to fetch user data for user ID $userId&quot;) &#125;        .getOrThrow()&#125;\n\n\nuserClient.getUser(userId) 함수는 HTTP 요청을 통해 사용자 정보를 가져옵니다. 이 함수는 네트워크 에러나 데이터 문제로 예외를 발생시킬 수 있습니다.\nrunCatching은 이 요청을 감싸 실행하며, 요청 중 발생하는 예외를 Result 객체로 캡처합니다.\nonFailure 블록은 Result 객체가 예외를 캡처했을 경우 실행됩니다. 여기서는 사용자 정의 예외를 던져, 오류 발생을 명확히 알립니다.\ngetOrThrow는 Result 객체에서 값을 추출합니다. 만약 Result가 실패를 나타내는 경우, onFailure에서 설정한 예외가 발생됩니다.\n\n포인트 정리#\n안전한 실행과 예외 처리: runCatching과 Result 객체를 사용하면 예외 처리를 안전하고 효율적으로 수행할 수 있습니다. 이를 통해 프로그램의 견고성이 증가합니다.\n결과 처리의 유연성: Result 타입은 getOrThrow, getOrElse, getOrNull 등 다양한 방법으로 결과를 처리할 수 있는 확장 함수를 제공합니다. 이 함수들은 각 상황에 맞게 결과를 유연하게 처리할 수 있도록 도와줍니다.\n코드의 간결성과 명확성: runCatching을 사용함으로써 전통적인 try-catch 블록보다 코드를 더 간결하고 읽기 쉽게 만들 수 있습니다.\n에러 핸들링의 명확성: onFailure를 통해 에러 발생 시 명확한 처리 로직을 구현할 수 있으며, 에러 메시지를 통해 오류의 원인을 더욱 분명히 할 수 있습니다.\n\n코틀린의 Result 타입은 개발자가 더 유연하고 견고한 코드를 작성할 수 있도록 지원합니다. 특히, HTTP 통신을 많이 다루는 서비스에서는 이러한 패턴을 적극적으로 활용하여 애플리케이션의 안정성과 유연성을 동시에 향상시킬 수 있습니다.  더 자세한 내용과 실용적인 설계 전략은 카카오페이 기술 블로그의 MSA 환경에서의 유연한 HTTP 클라이언트 설계 전략 글에서 확인하실 수 있습니다. 이 글에서는 Result 타입을 활용하여 MSA 환경에서 HTTP 클라이언트를 유연하게 설계하는 방법을 소개하고 있습니다.\n안정적인 서비스 운영을 위해 runCatching과 같은 코틀린의 기능을 적극 활용해보시길 권장드립니다. 이러한 패턴들은 예외가 발생할 가능성이 있는 네트워크 요청을 처리할 때 특히 유용하며, 시스템의 전체적인 에러 관리 능력을 개선할 수 있습니다.\n코틀린에서 by 키워드를 활용한 로깅 설정#코틀린에서 by 키워드는 위임 패턴(delegation)을 간편하게 구현할 수 있도록 도와줍니다. 특히, 로깅과 같은 반복적으로 사용되는 기능을 클래스에 쉽게 통합할 수 있게 하는 강력한 도구입니다. by 키워드를 사용하면 인스턴스 생성을 위임함으로써 코드의 중복을 줄이고 유지보수를 용이하게 만들 수 있습니다.\n코드 예시 및 설명#아래 예제는 by 키워드를 사용하여 Logger 인스턴스를 생성하고 이를 클래스에서 쉽게 사용할 수 있도록 보여줍니다:\n1234567891011121314import org.slf4j.Loggerimport org.slf4j.LoggerFactory// 로거 인스턴스 생성을 위한 제네릭 확장 함수fun &lt;A : Any&gt; A.logger(): Lazy&lt;Logger&gt; = lazy &#123; LoggerFactory.getLogger(this.javaClass) &#125;// 클래스 내부에서 위임을 통해 로그 인스턴스 사용class MyClass &#123;    private val log by logger()    fun performAction() &#123;        log.info(&quot;Action performed&quot;)    &#125;&#125;\n\n\nlogger() 함수는 Lazy&lt;Logger&gt;를 반환합니다. 이 함수는 호출하는 객체의 클래스 이름을 사용하여 Logger 인스턴스를 생성합니다.\nprivate val log by logger() 표현은 실제 로그 인스턴스가 필요할 때까지 로그 객체의 생성을 지연시킵니다(lazy를 사용).\n이 방식을 통해 클래스 내부에서 log를 직접 사용할 수 있으며, 로그 호출 시점에만 로거 인스턴스가 초기화됩니다.\n\n포인트 정리#\n효율적인 자원 사용: lazy를 사용함으로써 로거의 초기화를 실제 로깅이 필요한 시점까지 지연시킬 수 있습니다. 이는 자원을 효율적으로 사용하게 합니다.\n코드 중복 감소: logger() 확장 함수를 사용하면 모든 클래스에서 동일한 로깅 구성을 쉽게 재사용할 수 있습니다. 이는 코드 중복을 크게 줄여줍니다.\n유지보수의 용이성: 로그 인스턴스 생성 코드를 한 곳에 집중시키므로, 로거 설정을 변경할 때 다수의 클래스를 수정할 필요가 없습니다. 이는 전체적인 유지보수를 간단하게 만듭니다.\n\nby 키워드의 사용은 코틀린의 강력한 기능 중 하나로, 개발자가 코드를 보다 효과적이고 깔끔하게 관리할 수 있도록 돕습니다. 위의 예제처럼 by 키워드를 사용하는 것은 반복되는 코드 패턴을 단순화하고 프로젝트의 전반적인 품질을 향상시키는 데 큰 도움이 됩니다.\n코틀린에서 초기화 지연을 안전하게 관리하기#Delegates.notNull()은 코틀린에서 프로퍼티가 사용되기 전에 초기화되어야 함을 보장하는 위임 메커니즘입니다. 이 방법은 특히 프로퍼티의 초기화 시점이 명확하지 않을 때 유용하며, 초기화되지 않은 상태에서의 접근을 방지하여 안전성을 높입니다.\n코드 예시 및 설명#다음 예제는 QuerydslCustomRepositorySupport 클래스에서 Delegates.notNull()을 사용하는 방법을 보여줍니다. 스프링 프레임워크의 의존성 주입 기능을 사용하여 EntityManager가 주입된 후 JPAQueryFactory를 초기화합니다. 이런 경우, 의존성 주입의 시점이 런타임에 결정되므로 Delegates.notNull()을 활용하여 안전하게 초기화를 보장할 수 있습니다. 이는 EntityManager가 설정되기 전에 queryFactory가 사용되는 것을 방지하며, 초기화되지 않은 상태에서의 접근을 효과적으로 차단합니다.\n12345678910abstract class QuerydslCustomRepositorySupport(domainClass: Class&lt;*&gt;) : QuerydslRepositorySupport(domainClass) &#123;    protected var queryFactory: JPAQueryFactory by Delegates.notNull()    @PersistenceContext    override fun setEntityManager(entityManager: EntityManager) &#123;        super.setEntityManager(entityManager)        this.queryFactory = JPAQueryFactory(entityManager)    &#125;&#125;\n\n\nqueryFactory 프로퍼티는 JPAQueryFactory 타입으로 선언되어 있으며, Delegates.notNull()을 통해 위임되고 있습니다. 이는 queryFactory가 사용되기 전에 반드시 초기화되어야 함을 보장합니다.\nsetEntityManager 메소드는 EntityManager를 받아 super 클래스의 같은 메소드를 호출한 후, queryFactory를 초기화합니다. 이 메소드는 @PersistenceContext 애노테이션을 통해 JPA의 영속성 컨텍스트에서 EntityManager가 주입될 때 자동으로 호출됩니다.\n만약 queryFactory가 setEntityManager 메소드 호출 전에 사용되려고 하면, IllegalStateException이 발생하여 개발자에게 초기화 문제를 즉시 알려줍니다.\n\n포인트 정리#\n안전성 보장: 초기화되지 않은 프로퍼티의 사용을 방지하여 애플리케이션의 안정성을 향상시킵니다.\n명시적인 오류 처리: 초기화되지 않은 프로퍼티에 접근하려고 할 때 즉각적으로 예외가 발생함으로써, 초기화 로직의 오류를 빠르게 파악하고 수정할 수 있습니다.\n초기화 유연성: 특정 메소드나 조건 하에서만 초기화가 가능한 경우에 Delegates.notNull()을 사용하여 유연하게 초기화를 관리할 수 있습니다.\n\n이러한 특성 덕분에 Delegates.notNull()은 코틀린에서 프로퍼티의 초기화를 안전하고 효과적으로 관리할 수 있는 강력한 방법을 제공하며, 특히 늦은 초기화가 필요한 상황에서 그 가치가 더욱 빛납니다.\n","dateCreated":"2024-05-06T00:00:00+09:00","dateModified":"2025-01-31T20:24:39+09:00","datePublished":"2024-05-06T00:00:00+09:00","description":"불변 객체는 데이터의 안정성과 예측 가능성을 제공하여 소프트웨어 개발에서 권장되는 패턴입니다. 특히, 암호화와 같은 데이터의 보안적 처리에 있어서 불변 객체를 사용하면 변경될 필요가 없는 정보의 무결성을 유지할 수 있습니다.","headline":"Kotlin 자주 사용하는 패턴 정리","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://cheese10yun.github.io/kotlin-pattern/"},"publisher":{"@type":"Organization","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg","logo":{"@type":"ImageObject","url":"yun-icon.jpg"}},"url":"https://cheese10yun.github.io/kotlin-pattern/","keywords":"Kotlin"}</script>
    <meta name="description" content="불변 객체는 데이터의 안정성과 예측 가능성을 제공하여 소프트웨어 개발에서 권장되는 패턴입니다. 특히, 암호화와 같은 데이터의 보안적 처리에 있어서 불변 객체를 사용하면 변경될 필요가 없는 정보의 무결성을 유지할 수 있습니다.">
<meta property="og:type" content="blog">
<meta property="og:title" content="Kotlin 자주 사용하는 패턴 정리">
<meta property="og:url" content="https://cheese10yun.github.io/kotlin-pattern/index.html">
<meta property="og:site_name" content="Yun Blog">
<meta property="og:description" content="불변 객체는 데이터의 안정성과 예측 가능성을 제공하여 소프트웨어 개발에서 권장되는 패턴입니다. 특히, 암호화와 같은 데이터의 보안적 처리에 있어서 불변 객체를 사용하면 변경될 필요가 없는 정보의 무결성을 유지할 수 있습니다.">
<meta property="og:locale" content="ko_KR">
<meta property="article:published_time" content="2024-05-05T15:00:00.000Z">
<meta property="article:modified_time" content="2025-01-31T11:24:39.823Z">
<meta property="article:author" content="Yun">
<meta property="article:tag" content="Kotlin">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://cheese10yun.github.io/assets/images/yun-icon.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90907312-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-90907312-1');
    </script>


    

    
        
    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5813739623204880" crossorigin="anonymous"></script>
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="5">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Yun Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="링크 열기: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="5">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="저자에 대해 더 알아보기"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
                </a>
                <h4 class="sidebar-profile-name">Yun</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기술 블로그</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="태그"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="아카이브"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">아카이브</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/cheese10yun"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/rss2.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="5"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Kotlin 자주 사용하는 패턴 정리
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2024-05-06T00:00:00+09:00">
	
		    2024/05/06
    	
    </time>
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h2><span id="bulbyeon-gaegceyi-hyoyuljeog-gwanri-copy-mesodeu-hwalyong">불변 객체의 효율적 관리: <code>copy()</code> 메소드 활용</span><a href="#bulbyeon-gaegceyi-hyoyuljeog-gwanri-copy-mesodeu-hwalyong" class="header-anchor">#</a></h2><p>불변 객체는 데이터의 안정성과 예측 가능성을 제공하여 소프트웨어 개발에서 권장되는 패턴입니다. 특히, 암호화와 같은 데이터의 보안적 처리에 있어서 불변 객체를 사용하면 변경될 필요가 없는 정보의 무결성을 유지할 수 있습니다. Kotlin의 <code>data class</code>는 이러한 불변 객체를 다루기 위한 유용한 기능 중 하나로 <code>copy()</code> 메소드를 제공합니다. 이 메소드를 사용하면 객체의 일부만을 변경한 새로운 객체를 생성할 수 있어, 기존 객체의 불변성을 해치지 않으면서 필요한 부분만 업데이트가 가능합니다.</p>
<h3><span id="kodeu-yesi-mic-seolmyeong">코드 예시 및 설명</span><a href="#kodeu-yesi-mic-seolmyeong" class="header-anchor">#</a></h3><p>아래의 테스트 코드는 <code>User</code>라는 데이터 클래스의 인스턴스를 생성한 후, <code>copy()</code> 메소드를 사용하여 이메일 주소만을 암호화된 형태로 변경하는 예를 보여줍니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `불변 객체의 유지보수를 위한 copy 활용 예시`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = User(</span><br><span class="line">        name = <span class="string">&quot;name&quot;</span>,</span><br><span class="line">        email = <span class="string">&quot;email@asd.com&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> userCopy = user.copy(</span><br><span class="line">        email = <span class="string">&quot;email@asd.com 암호화&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// User(name=name, email=email@asd.com)</span></span><br><span class="line">    println(<span class="string">&quot;user: <span class="variable">$user</span>&quot;</span>)</span><br><span class="line">    <span class="comment">// User(name=name, email=email@asd.com 암호화)</span></span><br><span class="line">    println(<span class="string">&quot;userCopy: <span class="variable">$userCopy</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 428039780</span></span><br><span class="line">    println(<span class="string">&quot;user: <span class="subst">$&#123;System.identityHashCode(user)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment">// 48361312</span></span><br><span class="line">    println(<span class="string">&quot;userCopy: <span class="subst">$&#123;System.identityHashCode(userCopy)&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>원본 객체 출력</strong>: <code>user: User(name=name, email=email@asd.com)</code></li>
<li><strong>복사 후 업데이트된 객체 출력</strong>: <code>userCopy: User(name=name, email=email@asd.com 암호화)</code></li>
<li><strong>객체 식별자 비교</strong>: 두 객체의 <code>System.identityHashCode</code> 값을 출력하여 각각 다른 객체임을 확인할 수 있습니다.</li>
</ul>
<h3><span id="pointeu-jeongri">포인트 정리</span><a href="#pointeu-jeongri" class="header-anchor">#</a></h3><ul>
<li><code>copy()</code> 메소드는 원본 객체의 일부 속성을 변경하여 새로운 객체를 생성합니다. 이 방식은 기존 객체의 불변성을 유지하면서 필요한 데이터만 갱신할 수 있는 효율적인 방법을 제공합니다.</li>
<li><code>val</code> 키워드를 사용하여 불변성을 명시하는 것은 데이터 보호 및 버그 방지에 중요합니다. 특히 암호화와 같이 데이터 보안이 중요한 작업에서는 불변 객체의 사용이 더욱 중요합니다.</li>
</ul>
<p>이 방법은 데이터의 무결성을 유지하면서도 효율적인 데이터 관리를 가능하게 하여, 유지보수성을 높이고 시스템의 안정성을 강화합니다. 불변 객체와 <code>copy()</code> 메소드의 적절한 사용은 모던 소프트웨어 개발의 중요한 측면 중 하나입니다.</p>
<h2><span id="pairwa-triple-gaegceyi-yuyongseonggwa-hyoyuljeog-sayong">Pair와 Triple 객체의 유용성과 효율적 사용</span><a href="#pairwa-triple-gaegceyi-yuyongseonggwa-hyoyuljeog-sayong" class="header-anchor">#</a></h2><p>코틀린에서는 간단한 객체를 빠르게 생성하고 사용할 수 있도록 <code>Pair</code>와 <code>Triple</code>이라는 두 가지 유틸리티 클래스를 제공합니다. 이러한 클래스는 특히 서비스 내부 로직에서만 사용되는 임시 데이터를 다룰 때, 매번 새로운 DTO(Data Transfer Object)를 만드는 것보다 더 효율적일 수 있습니다. 또한, 멀티 모듈 프로젝트에서 여러 모듈 간에 DTO 클래스를 공유해야 할 때 이러한 객체의 사용이 유용합니다.</p>
<h3><span id="kodeu-yesi-mic-seolmyeong">코드 예시 및 설명</span><a href="#kodeu-yesi-mic-seolmyeong" class="header-anchor">#</a></h3><p>다음은 <code>UserPointCalculator</code> 클래스의 구현 예시입니다. 이 클래스는 사용자 정보를 MySQL 데이터베이스에서 가져오고, 사용자의 포인트 정보는 Redis에서 가져와 계산을 진행합니다. 이 과정에서 Triple 객체를 활용하여 각 사용자의 이름, 이메일, 포인트 정보를 효과적으로 관리합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserPointCalculator</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> userRepository: UserRepository,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> userPointRepository: UserPointRepository</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> users = userRepository.findUserByIds(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">val</span> points = userPointRepository.findUserPoint(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">            .associateBy &#123; it.id &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> userPoints = users.map &#123;</span><br><span class="line">            Triple(</span><br><span class="line">                first = it.name,</span><br><span class="line">                second = it.email,</span><br><span class="line">                third = points[it.id]!!.point</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (userPoint <span class="keyword">in</span> userPoints) &#123;</span><br><span class="line">            println(<span class="string">&quot;user name: <span class="subst">$&#123;userPoint.first&#125;</span>, user email  <span class="subst">$&#123;userPoint.second&#125;</span>, user point  <span class="subst">$&#123;userPoint.third&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>분석</strong>: 이 예에서 <code>Triple</code> 객체는 각 사용자의 이름, 이메일, 포인트를 저장하는데 사용됩니다. 이는 데이터베이스와 다른 저장소에서 정보를 읽어와 조합할 때 유용하게 사용됩니다.</p>
<h3><span id="pairwa-triple-sayong-si-gadogseong-hyangsang">Pair와 Triple 사용 시 가독성 향상</span><a href="#pairwa-triple-sayong-si-gadogseong-hyangsang" class="header-anchor">#</a></h3><p>Pair와 Triple은 기본적으로 <code>first</code>, <code>second</code>, <code>third</code>라는 속성명을 사용합니다. 이 속성명은 코드의 가독성을 저하시킬 수 있으므로, 구조 분해 할당(destructuring declaration)을 사용하여 보다 의미 있는 변수명을 사용하는 것이 좋습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 반복 처리</span></span><br><span class="line">    <span class="keyword">for</span> ((userName, userEmail, userPoint) <span class="keyword">in</span> userPoints) &#123;</span><br><span class="line">        println(<span class="string">&quot;user name: <span class="subst">$&#123;userName&#125;</span>, user email <span class="subst">$&#123;userEmail&#125;</span>, user point <span class="variable">$userPoint</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 개별 처리</span></span><br><span class="line">    <span class="keyword">val</span> (userName, userEmail, userPoint) = userPoints.first()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이와 같은 처리 방식은 <code>Pair</code>와 <code>Triple</code>을 사용할 때 코드의 명확성을 향상시키고, 데이터를 보다 효율적으로 다루는 데 도움이 됩니다. 데이터를 직관적으로 알아볼 수 있도록 이름을 명확하게 지정함으로써, 코드의 가독성과 유지보수성을 크게 개선할 수 있습니다.</p>
<p>이 방법은 간단한 데이터 구조를 사용하면서도 프로그램의 복잡성을 줄이고, 클린 코드를 유지하는 데 기여합니다.</p>
<h3><span id="pointeu-jeongri">포인트 정리</span><a href="#pointeu-jeongri" class="header-anchor">#</a></h3><p><code>Pair</code>와 <code>Triple</code> 객체는 임시 데이터 또는 내부 로직에서만 사용되는 데이터를 간편하게 다루기 위한 우수한 도구입니다. 이들은 DTO를 정의하는 복잡성을 피할 수 있으며, 특히 간단한 데이터 그룹을 빠르게 다루어야 할 때 효율적입니다. 하지만, 이들을 사용할 때는 변수명을 명확하게 지정하여 코드의 가독성을 유지하는 것이 중요합니다.</p>
<p>이 글은 Pair와 Triple 객체의 적절한 사용 사례를 통해 개발자들이 코드의 간결성과 유지보수성을 향상시키는 방법을 제시합니다.</p>
<h2><span id="typealiasreul-hwalyonghan-kodeu-gaeseon"><code>typealias</code>를 활용한 코드 개선</span><a href="#typealiasreul-hwalyonghan-kodeu-gaeseon" class="header-anchor">#</a></h2><p>코틀린의 <code>typealias</code> 기능은 복잡한 타입 선언에 대한 간결하고 의미 있는 이름을 제공함으로써 코드의 가독성과 유지보수성을 크게 향상시킵니다. 특히, 프로젝트 내에서 자주 사용되는 타입 조합에 별칭을 부여함으로써, 코드의 일관성을 유지하고 타입 변경 시의 유연성을 높일 수 있습니다.</p>
<h3><span id="kodeu-yesi-mic-seolmyeong">코드 예시 및 설명</span><a href="#kodeu-yesi-mic-seolmyeong" class="header-anchor">#</a></h3><p>다음 예제에서는 사용자 정보(<code>User</code>)와 사용자의 포인트(<code>UserPoint</code>)를 연결하는 <code>Pair</code>에 <code>UserPointAssociation</code>이라는 <code>typealias</code>를 사용합니다. 이는 <code>Pair&lt;User, UserPoint&gt;</code>의 사용을 간소화하고, 의미를 명확히 합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> UserPointAssociation = Pair&lt;User, UserPoint&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> userPointAssociations = users.map &#123;</span><br><span class="line">    UserPointAssociation(</span><br><span class="line">        first = it,</span><br><span class="line">        second = points[it.id]!!</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> (user, userPoint) = userPointAssociations.first()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>UserPointAssociation</code> 타입 별칭은 <code>Pair&lt;User, UserPoint&gt;</code>를 대체하여 코드의 목적을 더 명확하게 표현합니다.</li>
<li><code>map</code> 함수 내에서 <code>UserPointAssociation</code> 생성자를 사용하여 각 사용자와 해당 포인트 객체를 쌍으로 묶습니다. 이는 데이터의 논리적 연관성을 직관적으로 보여줍니다.</li>
<li>구조 분해 할당을 통해 <code>user</code>와 <code>userPoint</code> 변수에 각각 사용자 정보와 포인트 정보를 할당함으로써, 코드의 가독성을 더욱 향상시킵니다.</li>
</ul>
<h3><span id="pointeu-jeongri">포인트 정리</span><a href="#pointeu-jeongri" class="header-anchor">#</a></h3><ul>
<li><strong>명확성</strong>: <code>UserPointAssociation</code>과 같은 타입 별칭을 사용하면, 복잡한 타입 조합도 의미 있는 이름으로 대체되어 코드의 목적이 분명해집니다.</li>
<li><strong>유연성</strong>: 타입 별칭을 사용하면, 기본 타입 구조에 변경이 필요할 때 별칭 정의만 수정하면 되므로 코드 전체에 걸쳐 유연하게 변경을 적용할 수 있습니다.</li>
<li><strong>재사용성</strong>: 일단 정의된 타입 별칭은 프로젝트 전반에 걸쳐 재사용될 수 있으며, 코드의 일관성을 유지하는 데 도움이 됩니다.</li>
</ul>
<p><code>typealias</code>는 복잡한 타입을 간소화하고, 코드의 의도를 명확히 전달하는 데 큰 도움을 줍니다. 이는 특히 크고 복잡한 프로젝트에서 타입 관리를 효과적으로 수행하는 데 중요한 역할을 합니다.</p>
<h2><span id="runcatching-hamsuwa-result-gaegcereul-hwalyonghan-anjeonhan-ceori"><code>runCatching</code> 함수와 <code>Result</code> 객체를 활용한 안전한 처리</span><a href="#runcatching-hamsuwa-result-gaegcereul-hwalyonghan-anjeonhan-ceori" class="header-anchor">#</a></h2><p>코틀린의 <code>runCatching</code> 함수는 예외 발생 가능성이 있는 코드 블록을 실행하고 그 결과를 <code>Result</code> 타입으로 캡처합니다. 이 기능은 HTTP 통신과 같은 네트워크 요청에서 매우 유용하게 사용될 수 있습니다. <code>Result</code> 객체는 성공적인 결과 또는 발생한 예외를 안전하게 처리할 수 있는 API를 제공합니다.</p>
<h3><span id="kodeu-yesi-mic-seolmyeong">코드 예시 및 설명</span><a href="#kodeu-yesi-mic-seolmyeong" class="header-anchor">#</a></h3><p>다음 예제는 HTTP API를 통해 사용자 데이터를 요청하고 결과를 처리하는 과정을 보여줍니다:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(userId: <span class="type">Long</span>)</span></span>: User &#123;</span><br><span class="line">    <span class="keyword">return</span> runCatching &#123; userClient.getUser(userId) &#125;</span><br><span class="line">        .onFailure &#123; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Failed to fetch user data for user ID <span class="variable">$userId</span>&quot;</span>) &#125;</span><br><span class="line">        .getOrThrow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>userClient.getUser(userId)</code> 함수는 HTTP 요청을 통해 사용자 정보를 가져옵니다. 이 함수는 네트워크 에러나 데이터 문제로 예외를 발생시킬 수 있습니다.</li>
<li><code>runCatching</code>은 이 요청을 감싸 실행하며, 요청 중 발생하는 예외를 <code>Result</code> 객체로 캡처합니다.</li>
<li><code>onFailure</code> 블록은 <code>Result</code> 객체가 예외를 캡처했을 경우 실행됩니다. 여기서는 사용자 정의 예외를 던져, 오류 발생을 명확히 알립니다.</li>
<li><code>getOrThrow</code>는 <code>Result</code> 객체에서 값을 추출합니다. 만약 <code>Result</code>가 실패를 나타내는 경우, <code>onFailure</code>에서 설정한 예외가 발생됩니다.</li>
</ul>
<h3><span id="pointeu-jeongri">포인트 정리</span><a href="#pointeu-jeongri" class="header-anchor">#</a></h3><ul>
<li><strong>안전한 실행과 예외 처리</strong>: <code>runCatching</code>과 <code>Result</code> 객체를 사용하면 예외 처리를 안전하고 효율적으로 수행할 수 있습니다. 이를 통해 프로그램의 견고성이 증가합니다.</li>
<li><strong>결과 처리의 유연성</strong>: <code>Result</code> 타입은 <code>getOrThrow</code>, <code>getOrElse</code>, <code>getOrNull</code> 등 다양한 방법으로 결과를 처리할 수 있는 확장 함수를 제공합니다. 이 함수들은 각 상황에 맞게 결과를 유연하게 처리할 수 있도록 도와줍니다.</li>
<li><strong>코드의 간결성과 명확성</strong>: <code>runCatching</code>을 사용함으로써 전통적인 <code>try-catch</code> 블록보다 코드를 더 간결하고 읽기 쉽게 만들 수 있습니다.</li>
<li><strong>에러 핸들링의 명확성</strong>: <code>onFailure</code>를 통해 에러 발생 시 명확한 처리 로직을 구현할 수 있으며, 에러 메시지를 통해 오류의 원인을 더욱 분명히 할 수 있습니다.</li>
</ul>
<p>코틀린의 <code>Result</code> 타입은 개발자가 더 유연하고 견고한 코드를 작성할 수 있도록 지원합니다. 특히, HTTP 통신을 많이 다루는 서비스에서는 이러한 패턴을 적극적으로 활용하여 애플리케이션의 안정성과 유연성을 동시에 향상시킬 수 있습니다.  더 자세한 내용과 실용적인 설계 전략은 카카오페이 기술 블로그의 <a target="_blank" rel="noopener" href="https://tech.kakaopay.com/post/make-http-client-design-flexible/">MSA 환경에서의 유연한 HTTP 클라이언트 설계 전략</a> 글에서 확인하실 수 있습니다. 이 글에서는 <code>Result</code> 타입을 활용하여 MSA 환경에서 HTTP 클라이언트를 유연하게 설계하는 방법을 소개하고 있습니다.</p>
<p>안정적인 서비스 운영을 위해 <code>runCatching</code>과 같은 코틀린의 기능을 적극 활용해보시길 권장드립니다. 이러한 패턴들은 예외가 발생할 가능성이 있는 네트워크 요청을 처리할 때 특히 유용하며, 시스템의 전체적인 에러 관리 능력을 개선할 수 있습니다.</p>
<h2><span id="koteulrineseo-by-kiweodeureul-hwalyonghan-roging-seoljeong">코틀린에서 <code>by</code> 키워드를 활용한 로깅 설정</span><a href="#koteulrineseo-by-kiweodeureul-hwalyonghan-roging-seoljeong" class="header-anchor">#</a></h2><p>코틀린에서 <code>by</code> 키워드는 위임 패턴(delegation)을 간편하게 구현할 수 있도록 도와줍니다. 특히, 로깅과 같은 반복적으로 사용되는 기능을 클래스에 쉽게 통합할 수 있게 하는 강력한 도구입니다. <code>by</code> 키워드를 사용하면 인스턴스 생성을 위임함으로써 코드의 중복을 줄이고 유지보수를 용이하게 만들 수 있습니다.</p>
<h3><span id="kodeu-yesi-mic-seolmyeong">코드 예시 및 설명</span><a href="#kodeu-yesi-mic-seolmyeong" class="header-anchor">#</a></h3><p>아래 예제는 <code>by</code> 키워드를 사용하여 <code>Logger</code> 인스턴스를 생성하고 이를 클래스에서 쉽게 사용할 수 있도록 보여줍니다:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory</span><br><span class="line"></span><br><span class="line"><span class="comment">// 로거 인스턴스 생성을 위한 제네릭 확장 함수</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;A : Any&gt;</span> A.<span class="title">logger</span><span class="params">()</span></span>: Lazy&lt;Logger&gt; = lazy &#123; LoggerFactory.getLogger(<span class="keyword">this</span>.javaClass) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 클래스 내부에서 위임을 통해 로그 인스턴스 사용</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> log <span class="keyword">by</span> logger()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">performAction</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Action performed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>logger()</code> 함수는 <code>Lazy&lt;Logger&gt;</code>를 반환합니다. 이 함수는 호출하는 객체의 클래스 이름을 사용하여 <code>Logger</code> 인스턴스를 생성합니다.</li>
<li><code>private val log by logger()</code> 표현은 실제 로그 인스턴스가 필요할 때까지 로그 객체의 생성을 지연시킵니다(<code>lazy</code>를 사용).</li>
<li>이 방식을 통해 클래스 내부에서 <code>log</code>를 직접 사용할 수 있으며, 로그 호출 시점에만 로거 인스턴스가 초기화됩니다.</li>
</ul>
<h3><span id="pointeu-jeongri">포인트 정리</span><a href="#pointeu-jeongri" class="header-anchor">#</a></h3><ul>
<li><strong>효율적인 자원 사용</strong>: <code>lazy</code>를 사용함으로써 로거의 초기화를 실제 로깅이 필요한 시점까지 지연시킬 수 있습니다. 이는 자원을 효율적으로 사용하게 합니다.</li>
<li><strong>코드 중복 감소</strong>: <code>logger()</code> 확장 함수를 사용하면 모든 클래스에서 동일한 로깅 구성을 쉽게 재사용할 수 있습니다. 이는 코드 중복을 크게 줄여줍니다.</li>
<li><strong>유지보수의 용이성</strong>: 로그 인스턴스 생성 코드를 한 곳에 집중시키므로, 로거 설정을 변경할 때 다수의 클래스를 수정할 필요가 없습니다. 이는 전체적인 유지보수를 간단하게 만듭니다.</li>
</ul>
<p><code>by</code> 키워드의 사용은 코틀린의 강력한 기능 중 하나로, 개발자가 코드를 보다 효과적이고 깔끔하게 관리할 수 있도록 돕습니다. 위의 예제처럼 <code>by</code> 키워드를 사용하는 것은 반복되는 코드 패턴을 단순화하고 프로젝트의 전반적인 품질을 향상시키는 데 큰 도움이 됩니다.</p>
<h2><span id="koteulrineseo-cogihwa-jiyeoneul-anjeonhage-gwanrihagi">코틀린에서 초기화 지연을 안전하게 관리하기</span><a href="#koteulrineseo-cogihwa-jiyeoneul-anjeonhage-gwanrihagi" class="header-anchor">#</a></h2><p><code>Delegates.notNull()</code>은 코틀린에서 프로퍼티가 사용되기 전에 초기화되어야 함을 보장하는 위임 메커니즘입니다. 이 방법은 특히 프로퍼티의 초기화 시점이 명확하지 않을 때 유용하며, 초기화되지 않은 상태에서의 접근을 방지하여 안전성을 높입니다.</p>
<h3><span id="kodeu-yesi-mic-seolmyeong">코드 예시 및 설명</span><a href="#kodeu-yesi-mic-seolmyeong" class="header-anchor">#</a></h3><p>다음 예제는 <code>QuerydslCustomRepositorySupport</code> 클래스에서 <code>Delegates.notNull()</code>을 사용하는 방법을 보여줍니다. 스프링 프레임워크의 의존성 주입 기능을 사용하여 <code>EntityManager</code>가 주입된 후 <code>JPAQueryFactory</code>를 초기화합니다. 이런 경우, 의존성 주입의 시점이 런타임에 결정되므로 <code>Delegates.notNull()</code>을 활용하여 안전하게 초기화를 보장할 수 있습니다. 이는 <code>EntityManager</code>가 설정되기 전에 <code>queryFactory</code>가 사용되는 것을 방지하며, 초기화되지 않은 상태에서의 접근을 효과적으로 차단합니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">QuerydslCustomRepositorySupport</span>(domainClass: Class&lt;*&gt;) : QuerydslRepositorySupport(domainClass) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> queryFactory: JPAQueryFactory <span class="keyword">by</span> Delegates.notNull()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PersistenceContext</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setEntityManager</span><span class="params">(entityManager: <span class="type">EntityManager</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setEntityManager(entityManager)</span><br><span class="line">        <span class="keyword">this</span>.queryFactory = JPAQueryFactory(entityManager)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>queryFactory</code> 프로퍼티는 <code>JPAQueryFactory</code> 타입으로 선언되어 있으며, <code>Delegates.notNull()</code>을 통해 위임되고 있습니다. 이는 <code>queryFactory</code>가 사용되기 전에 반드시 초기화되어야 함을 보장합니다.</li>
<li><code>setEntityManager</code> 메소드는 <code>EntityManager</code>를 받아 <code>super</code> 클래스의 같은 메소드를 호출한 후, <code>queryFactory</code>를 초기화합니다. 이 메소드는 <code>@PersistenceContext</code> 애노테이션을 통해 JPA의 영속성 컨텍스트에서 <code>EntityManager</code>가 주입될 때 자동으로 호출됩니다.</li>
<li>만약 <code>queryFactory</code>가 <code>setEntityManager</code> 메소드 호출 전에 사용되려고 하면, <code>IllegalStateException</code>이 발생하여 개발자에게 초기화 문제를 즉시 알려줍니다.</li>
</ul>
<h3><span id="pointeu-jeongri">포인트 정리</span><a href="#pointeu-jeongri" class="header-anchor">#</a></h3><ul>
<li><strong>안전성 보장</strong>: 초기화되지 않은 프로퍼티의 사용을 방지하여 애플리케이션의 안정성을 향상시킵니다.</li>
<li><strong>명시적인 오류 처리</strong>: 초기화되지 않은 프로퍼티에 접근하려고 할 때 즉각적으로 예외가 발생함으로써, 초기화 로직의 오류를 빠르게 파악하고 수정할 수 있습니다.</li>
<li><strong>초기화 유연성</strong>: 특정 메소드나 조건 하에서만 초기화가 가능한 경우에 <code>Delegates.notNull()</code>을 사용하여 유연하게 초기화를 관리할 수 있습니다.</li>
</ul>
<p>이러한 특성 덕분에 <code>Delegates.notNull()</code>은 코틀린에서 프로퍼티의 초기화를 안전하고 효과적으로 관리할 수 있는 강력한 방법을 제공하며, 특히 늦은 초기화가 필요한 상황에서 그 가치가 더욱 빛납니다.</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">태그</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/Kotlin/" rel="tag">Kotlin</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/kotlin-flow/"
                    data-tooltip="코루틴을 이용한 성능 개선 - Flow를 활용한 다중 요청 처리"
                    aria-label="이전: 코루틴을 이용한 성능 개선 - Flow를 활용한 다중 요청 처리"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/locust-part-2/"
                    data-tooltip="Locust 성능 테스트 도구 소개 Part 2"
                    aria-label="다음: Locust 성능 테스트 도구 소개 Part 2"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/kotlin-pattern/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/kotlin-pattern/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>


<!-- Comment -->
<!--  utteranc comment -->

<script src="https://utteranc.es/client.js"
        repo="cheese10yun/blog-comment"
        issue-term="title"
        label="Comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2025 Yun. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/kotlin-flow/"
                    data-tooltip="코루틴을 이용한 성능 개선 - Flow를 활용한 다중 요청 처리"
                    aria-label="이전: 코루틴을 이용한 성능 개선 - Flow를 활용한 다중 요청 처리"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/locust-part-2/"
                    data-tooltip="Locust 성능 테스트 도구 소개 Part 2"
                    aria-label="다음: Locust 성능 테스트 도구 소개 Part 2"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/kotlin-pattern/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/kotlin-pattern/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="5">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/kotlin-pattern/"
                        aria-label="Facebook에 공유하기"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Facebook에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/kotlin-pattern/"
                        aria-label="Twitter에 공유하기"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Twitter에 공유하기</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
            <h4 id="about-card-name">Yun</h4>
        
            <div id="about-card-bio"><p>기술 블로그</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
