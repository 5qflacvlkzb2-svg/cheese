<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Yun Blog</title>
    <link>https://cheese10yun.github.io/</link>
    
    <atom:link href="https://cheese10yun.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>기술 블로그</description>
    <pubDate>Thu, 30 Jan 2025 21:29:31 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Spring Data MongoDB Repository 확장</title>
      <link>https://cheese10yun.github.io/spring-data-mongo-repository/</link>
      <guid>https://cheese10yun.github.io/spring-data-mongo-repository/</guid>
      <pubDate>Thu, 30 Jan 2025 21:29:31 GMT</pubDate>
      
      <description>Spring Data JPA에서 흔히 사용하는 Repository 확장 패턴을 Spring Data MongoDB에도 적용할 수 있습니다.</description>
      
      
      
      <content:encoded><![CDATA[<p>Spring Data JPA에서 흔히 사용하는 Repository 확장 패턴을 Spring Data MongoDB에도 적용할 수 있습니다. 이 패턴은 'CustomRepository’와 'CustomRepositoryImpl’의 조합으로 구성되며, <a href="https://cheese10yun.github.io/spring-jpa-best-15/">Spring-JPA Best Practices step-15</a>에서 이전에 포스팅한적 있습니다. 이 방법을 사용하면 복잡한 조회 작업을 'CustomRepositoryImpl’에서 처리할 수 있게 됩니다. 이 구조를 사용하면, 사용자는 Repository 인터페이스만을 이용하여 데이터를 조회할 수 있게 되어 코드의 간결성과 유지보수성이 향상됩니다. 예를 들어, CustomRepositoryImpl에서 복잡한 쿼리 로직을 구현하면, 상위 레벨에서는 이러한 구현 디테일을 신경 쓰지 않고 데이터 접근 로직을 단순화할 수 있습니다. Spring Data MongoDB에서 동일하게 적용하는 방법을 살펴보겠습니다.</p><h2 id="Custom-Repository">Custom Repository</h2><h3 id="Custom-Repository-구성">Custom Repository 구성</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document(collection = <span class="string">&quot;members&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span>(</span><br><span class="line">    <span class="meta">@Field(name = <span class="string">&quot;name&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = <span class="string">&quot;email&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> email: String</span><br><span class="line">) : Auditable()</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MemberRepository</span> : <span class="type">MongoRepository</span>&lt;<span class="type">Member, ObjectId</span>&gt;, <span class="type">MemberCustomRepository</span>, <span class="type">QuerydslPredicateExecutor</span>&lt;<span class="type">Member</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MemberCustomRepository</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemberCustomRepositoryImpl</span>(<span class="keyword">private</span> <span class="keyword">val</span> mongoTemplate: MongoTemplate) : MemberCustomRepository</span><br></pre></td></tr></table></figure><p>코드의 각 부분은 MongoDB를 사용하는 스프링 애플리케이션에서 도메인 객체를 정의하고, 저장소를 구성하는 데 필요한 요소들을 포함하고 있습니다. 아래는 코드 구조를 기반으로 한 정리입니다:</p><ol><li><strong><code>Member</code></strong> - MongoDB의 <code>members</code> 컬렉션에 매핑되는 도메인 객체입니다. <code>name</code>과 <code>email</code> 필드를 가지고 있으며, 각 필드는 MongoDB의 문서 필드에 맞추어 <code>@Field</code> 애노테이션을 사용하여 지정되어 있습니다.</li><li><strong><code>MemberRepository</code></strong> - MongoDB의 기본 CRUD 작업을 위한 <code>MongoRepository</code>와 사용자 정의 쿼리를 위한 <code>MemberCustomRepository</code>, Querydsl 지원을 위한 <code>QuerydslPredicateExecutor</code>를 확장하는 저장소 인터페이스입니다. 이로 인해 <code>Member</code> 객체에 대한 표준 데이터 접근 패턴과 함께 복잡한 쿼리 기능을 제공합니다.</li><li><strong><code>MemberCustomRepository</code></strong> - 사용자 정의 쿼리를 위한 인터페이스로, 실제 사용자 정의 로직을 위한 메소드의 시그니처를 포함할 수 있습니다.</li><li><strong><code>MemberCustomRepositoryImpl</code></strong> - <code>MemberCustomRepository</code>의 구현체로, 실제 사용자 정의 쿼리 로직을 실행하는 메소드를 포함합니다. <code>MongoTemplate</code>을 주입받아 MongoDB의 복잡한 작업을 처리하는 데 사용됩니다.</li></ol><p>이 구성을 통해, 애플리케이션은 MongoDB에 대한 데이터 액세스를 추상화하고 효율적으로 관리할 수 있으며, <code>MemberRepository를</code> 통해 비즈니스 로직에 맞는 복잡한 데이터 접근 패턴을 구현할 수 있어 애플리케이션의 유연성을 증가시키고 코드의 관리를 간소화합니다.</p><h3 id="MemberCustomRepositoryImpl-구현">MemberCustomRepositoryImpl 구현</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MemberCustomRepository</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findByName</span><span class="params">(name: <span class="type">String</span>)</span></span>: List&lt;Member&gt;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findByEmail</span><span class="params">(email: <span class="type">String</span>)</span></span>: List&lt;Member&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemberCustomRepositoryImpl</span>(<span class="keyword">private</span> <span class="keyword">val</span> mongoTemplate: MongoTemplate) : MemberCustomRepository &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findByName</span><span class="params">(name: <span class="type">String</span>)</span></span>: List&lt;Member&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> query = Query(Criteria.<span class="keyword">where</span>(<span class="string">&quot;name&quot;</span>).`<span class="keyword">is</span>`(name))</span><br><span class="line">        <span class="keyword">return</span> mongoTemplate.find(query, Member::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findByEmail</span><span class="params">(email: <span class="type">String</span>)</span></span>: List&lt;Member&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> query = Query(Criteria.<span class="keyword">where</span>(<span class="string">&quot;email&quot;</span>).`<span class="keyword">is</span>`(email))</span><br><span class="line">        <span class="keyword">return</span> mongoTemplate.find(query, Member::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MemberCustomRepositoryImpl</code> 클래스에서는 <code>MemberCustomRepository</code> 인터페이스에 선언된 메소드의 구체적인 구현이 이루어집니다. 처음에는 <code>override</code> 키워드 없이 구현을 시작할 수 있습니다. 구현을 완료한 후, IntelliJ의 <code>Refactoring</code> 메뉴에서 <code>Pull Members Up...</code> 옵션을 선택함으로써 해당 메소드를 상위 인터페이스로 이동시킬 수 있습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/mongo-study/images/custom-01.png" alt=""></p><p>인터페이스의 메서드 시그니처를 처음부터 명확히 정의하지 않고, 구현 클래스에서 메서드의 세부 구현을 확정한 후에 이를 상위 인터페이스로 옮기는 방식을 개인적으로 선호합니다.</p><h2 id="CustomRepositoryImpl를-서포트하는-MongoCustomRepositorySupport">CustomRepositoryImpl를 서포트하는 MongoCustomRepositorySupport</h2><h3 id="MongoCustomRepositorySupport-구현체">MongoCustomRepositorySupport 구현체</h3><p><a href="https://cheese10yun.github.io/querydsl-support/">Querydsl Repository Support 활용</a> 포스팅에서는 <code>QuerydslRepositorySupport</code>를 사용해 <code>CustomRepositoryImpl</code>의 반복적이고 복잡한 쿼리 로직을 단순화한 방법을 소개했습니다. 이와 유사하게, <code>MongoCustomRepositorySupport</code>를 생성하여 <code>CustomRepositoryImpl</code>에 공통 메서드를 중앙화시키면, 코드 중복을 줄이고 재사용성을 높일 수 있습니다. 이러한 방식은 Mongo DB 환경에서도 Querydsl의 장점을 활용하게 해주며, 코드 관리 및 유지보수의 효율성을 향상시킵니다. 대표적으로 페이징 처리 관련된 기능들을 통합해서 제공해줄 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MongoCustomRepositorySupport</span>&lt;<span class="type">T</span>&gt;(</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> documentClass: Class&lt;T&gt;,</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> mongoTemplate: MongoTemplate</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> logger <span class="keyword">by</span> logger()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">logQuery</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        query: <span class="type">Query</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        name: <span class="type">String</span>? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Executing MongoDB <span class="variable">$name</span> Query: <span class="variable">$query</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;S : T&gt;</span> <span class="title">applyPagination</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        contentQuery: (<span class="type">Query</span>) -&gt; <span class="type">List</span>&lt;<span class="type">S</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        countQuery: (<span class="type">Query</span>) -&gt; <span class="type">Long</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> = runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> content = async &#123; contentQuery(Query().with(pageable)) &#125;</span><br><span class="line">        <span class="keyword">val</span> totalCount = async &#123; countQuery(Query()) &#125;</span><br><span class="line">        PageImpl(content.await(), pageable, totalCount.await())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;S : T&gt;</span> <span class="title">applySlicePagination</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        contentQuery: (<span class="type">Query</span>) -&gt; <span class="type">List</span>&lt;<span class="type">S</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Slice&lt;S&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> content = contentQuery(Query().with(pageable))</span><br><span class="line">        <span class="keyword">val</span> hasNext = content.size &gt;= pageable.pageSize</span><br><span class="line">        <span class="keyword">return</span> SliceImpl(content, pageable, hasNext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/mongo-study/images/query-result.png" alt=""></p><p>JPA 페이징 성능을 향상시키는 방법으로, 내용을 담은 콘텐츠 쿼리와 개수를 세는 카운트 쿼리를 분리하여 구현하는 것이 유익하다는 내용을 <a href="https://cheese10yun.github.io/page-performance/">JPA 페이징 Performance 향상 방법</a>에서 다루었습니다. 이 두 쿼리는 상호 의존적이지 않아 병렬 처리를 함으로써 성능을 높일 수 있습니다. 또한, 슬라이스 쿼리의 경우, '다음 페이지가 있는지’를 확인하는 <code>hasNext</code> 메서드를 포함한 공통된 로직을 사용함으로써 코드 중복을 방지하고 재사용성을 극대화합니다. <code>MongoCustomRepositorySupport</code> 클래스는 이러한 공통 기능을 제공하여 효율적인 데이터 조회와 페이지 처리를 가능하게 합니다.&quot;</p><h3 id="MongoCustomRepositorySupport">MongoCustomRepositorySupport</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MemberCustomRepository</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findPageBy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        name: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        email: <span class="type">String</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Page&lt;Member&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemberCustomRepositoryImpl</span>(mongoTemplate: MongoTemplate) : MemberCustomRepository, MongoCustomRepositorySupport&lt;Member&gt;(</span><br><span class="line">    Member::<span class="keyword">class</span>.java,</span><br><span class="line">    mongoTemplate</span><br><span class="line">) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findPageBy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        name: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        email: <span class="type">String</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Page&lt;Member&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> queryBuilder: (Query) -&gt; Query = &#123; query -&gt;</span><br><span class="line">            <span class="keyword">val</span> criteria = Criteria().apply &#123;</span><br><span class="line">                name?.let &#123; and(<span class="string">&quot;name&quot;</span>).regex(<span class="string">&quot;.*<span class="variable">$it</span>.*&quot;</span>, <span class="string">&quot;i&quot;</span>) &#125;</span><br><span class="line">                email?.let &#123; and(<span class="string">&quot;email&quot;</span>).regex(<span class="string">&quot;.*<span class="variable">$it</span>.*&quot;</span>, <span class="string">&quot;i&quot;</span>) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            query.addCriteria(criteria)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> applyPagination(</span><br><span class="line">            pageable = pageable,</span><br><span class="line">            contentQuery = &#123; query -&gt;</span><br><span class="line">                mongoTemplate.find(queryBuilder(query), documentClass)</span><br><span class="line">            &#125;,</span><br><span class="line">            countQuery = &#123; query -&gt;</span><br><span class="line">                mongoTemplate.count(queryBuilder(query), documentClass)</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MemberCustomRepositoryImpl</code> 클래스는 <code>MongoCustomRepositorySupport</code> 추상 클래스를 상속받아, MongoDB와의 데이터 교환을 더 효율적으로 관리하는 특수한 저장소 구현을 제공합니다. <code>MongoCustomRepositorySupport</code>는 몽고디비의 <code>mongoTemplate</code>와 작업할 클래스 타입을 받아 초기화합니다. 이는 <code>MemberRepository</code> 구현에 필수적인 기반 구조를 제공하여 보일러플레이트 코드를 줄이고 코드의 재사용성을 향상시킵니다.</p>]]></content:encoded>
      
      
      
      <category domain="https://cheese10yun.github.io/tags/Coroutines/">Coroutines</category>
      
      <category domain="https://cheese10yun.github.io/tags/Mongo/">Mongo</category>
      
      
      <comments>https://cheese10yun.github.io/spring-data-mongo-repository/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring Batch HTTP Page Item Reader</title>
      <link>https://cheese10yun.github.io/spring-batch-http-page-item-reader/</link>
      <guid>https://cheese10yun.github.io/spring-batch-http-page-item-reader/</guid>
      <pubDate>Thu, 30 Jan 2025 21:29:31 GMT</pubDate>
      
      <description>Spring Batch로 애플리케이션을 작성하는 경우 내부 데이터가 아니라 외부의 데이터를 가져와서 가공해야 하는 경우 데이터 파이프라인은 어떻게 구축해야 할지 결정해야 합니다.</description>
      
      
      
      <content:encoded><![CDATA[<p>Spring Batch로 애플리케이션을 작성하는 경우 내부 데이터가 아니라 외부의 데이터를 가져와서 가공해야 하는 경우 데이터 파이프라인은 어떻게 구축해야 할지 결정해야 합니다. 예를 들어 데이터베이스에 직접 연결해서 필요한 데이터를 쿼리 하여 가져올 것인지, 아니면 csv 등 파일을 주고받는 방식, HTTP API를 통해서 가져오는 방식 등등 여러 가지 방식이 있습니다. 데이터베이스 연결 방식, 파일방식은 스프링 배치에서 기본 제공해 주고 있지만 HTTP Paging 기반 Reader는 제공해 주고 있지 않아 해당 기능을 Item Reader를 직접 구현해 보겠습니다. 부족한 부분은 프로젝트에 맞게 추가하셔도 좋을 거 같습니다.</p><h2 id="Spring-Batch-기본-소개">Spring Batch 기본 소개</h2><p><img src="https://raw.githubusercontent.com/cheese10yun/TIL/master/assets/batch-obejct-relrationship.png" alt=""></p><ul><li>읽기(read) : 데이터 저장소(일반적으로 데이터베이스)에서 특정 데이터 레코드를 읽습니다.</li><li>처리(processing) : 원하는 방식으로 데이터 가공/처리합니다.</li><li>쓰기(write) : 수정된 데이터를 다시 저장소에 저장합니다.</li></ul><p><img src="https://raw.githubusercontent.com/cheese10yun/TIL/master/assets/chun-process.png" alt=""></p><ul><li>Reader에서 데이터를 하나 읽어 옵니다.</li><li>읽어온 데이터를 Processor에서 가공합니다.</li><li>가공된 데이터들을 별도의 공간에 모은뒤, Chunk 단위만큼 쌓이게 되면 Writer에 전달하고 Writer는 일괄 저장합니다.</li></ul><p><strong>Reader와 Processor에서는 1건씩 다뤄지고, Writer에선 Chunk 단위로 처리된다는 것이 중요합니다.</strong></p><p>Chunk 지향 처리를 Java 코드로 표현하면 아래처럼 될 것 같습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun Chunk_처리_방법(chunkSize: Int, totalSize: Int) &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; totalSize) &#123;</span><br><span class="line">        val items: MutableList&lt;*&gt; = ArrayList&lt;Any?&gt;()</span><br><span class="line">        <span class="keyword">for</span> (j in <span class="number">0</span> until chunkSize) &#123;</span><br><span class="line">            val item: Any = itemReader.read()</span><br><span class="line">            val processedItem: Any = itemProcessor.process(item)</span><br><span class="line">            items.add(processedItem)</span><br><span class="line">        &#125;</span><br><span class="line">        itemWriter.write(items)</span><br><span class="line">        i = i + chunkSize</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>즉 chunkSize 별로 묶는 다는 것은 total_size에서 chunk_size 만큼 읽어 자장한다는 의미입니다.</strong></p><h3 id="HttpPageItemReader">HttpPageItemReader</h3><h3 id="HTTP-Response">HTTP Response</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;bookId&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;bookStatus&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OPEN&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;userId&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">&quot;number&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;numberOfElements&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;empty&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>HTTP Response는 위와 같이 구성되어 있다고 가정하겠습니다.</p><table><thead><tr><th>Page</th><th>size</th><th>URL</th><th>Content</th></tr></thead><tbody><tr><td>0</td><td>10</td><td><a href="http://localhost:8080/api/members?page=0&amp;size=10">http://localhost:8080/api/members?page=0&amp;size=10</a></td><td>10</td></tr><tr><td>1</td><td>10</td><td><a href="http://localhost:8080/api/members?page=1&amp;size=10">http://localhost:8080/api/members?page=1&amp;size=10</a></td><td>10</td></tr><tr><td>2</td><td>10</td><td><a href="http://localhost:8080/api/members?page=2&amp;size=10">http://localhost:8080/api/members?page=2&amp;size=10</a></td><td>3</td></tr><tr><td>3</td><td>10</td><td><a href="http://localhost:8080/api/members?page=3&amp;size=10">http://localhost:8080/api/members?page=3&amp;size=10</a></td><td>0</td></tr></tbody></table><p>실제 데이터는 rows 23개가 저장되어 있다면 size를 10을 기준으로 2페이지 까지 읽으면 모든 데이터를 다 읽게 됩니다. 2페이지에서는 남은 데이터 rows 3개가 응답되며 3페이지를 조회하면 빈 응답 페이지가 넘어오게 됩니다. 즉 HttpPageItemReader는 <code>content</code>가 빈 배열이 나올 때까지 page를 1식 증가 시키며 다음 페이지를 계속 읽어 나가는 형태로 구성됩니다.</p><h2 id="Code">Code</h2><h3 id="HttpPageItemReader-2">HttpPageItemReader</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">HttpPageItemReader</span>&lt;<span class="type">T : Any</span>&gt;(</span><br><span class="line">    name: String = <span class="string">&quot;HttpPageItemReader&quot;</span>,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> url: String,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> size: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> page: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> parameters: List&lt;Pair&lt;String, Any&gt;&gt;? = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> contentClass: KClass&lt;T&gt;,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> objectMapper: ObjectMapper = ObjectMapper().registerKotlinModule()</span><br><span class="line">        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="literal">false</span>)</span><br><span class="line">        .apply &#123; <span class="keyword">this</span>.propertyNamingStrategy = PropertyNamingStrategies.SNAKE_CASE &#125;</span><br><span class="line">) : AbstractItemCountingItemStreamItemReader&lt;T&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> log <span class="keyword">by</span> logger()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> contents = mutableListOf&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setName(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doOpen</span><span class="params">()</span></span> &#123; </span><br><span class="line">        log.info(<span class="string">&quot;HttpPageItemReader doOpen page: <span class="variable">$page</span>, size: <span class="variable">$size</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;HttpPageItemReader doClose page: <span class="variable">$page</span>, size: <span class="variable">$size</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doRead</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.contents.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.contents = readRow()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.contents.isEmpty() -&gt; <span class="literal">null</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">this</span>.contents.removeAt(<span class="keyword">this</span>.contents.size - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (4)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">readRow</span><span class="params">()</span></span> =</span><br><span class="line">        url</span><br><span class="line">            .httpGet(generateQueryParameter())</span><br><span class="line">            .responseString()</span><br><span class="line">            .run &#123;</span><br><span class="line">                <span class="keyword">when</span> &#123;</span><br><span class="line">                    second.isSuccessful -&gt; &#123;</span><br><span class="line">                        page++</span><br><span class="line">                        serializeResponseBody(responseBody = third.<span class="keyword">get</span>())</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;...&quot;</span>) <span class="comment">// 2xx 응답을 받지 못한 경우는 각 상황에 맞게 구현</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (5)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">generateQueryParameter</span><span class="params">()</span></span> = <span class="keyword">when</span> (parameters) &#123;</span><br><span class="line">        <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">            listOf(</span><br><span class="line">                <span class="string">&quot;page&quot;</span> to page,</span><br><span class="line">                <span class="string">&quot;size&quot;</span> to size,</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            mutableListOf(</span><br><span class="line">                <span class="string">&quot;page&quot;</span> to page,</span><br><span class="line">                <span class="string">&quot;size&quot;</span> to size,</span><br><span class="line">            )</span><br><span class="line">                .plus(parameters)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (6)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">serializeResponseBody</span><span class="params">(responseBody: <span class="type">String</span>)</span></span>: MutableList&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> rootNode = objectMapper.readTree(responseBody)</span><br><span class="line">        <span class="keyword">val</span> contentNode = rootNode.path(<span class="string">&quot;content&quot;</span>)</span><br><span class="line"></span><br><span class="line">        require(rootNode.isEmpty.not()) &#123; <span class="string">&quot;Response Body 값이 비어 있을 수 없습니다.&quot;</span> &#125;</span><br><span class="line">        require(contentNode.isArray) &#123; <span class="string">&quot;Response content 필드는 Array 타입 이어야 합니다.&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (7)</span></span><br><span class="line">        <span class="keyword">return</span> objectMapper.convertValue&lt;List&lt;T&gt;&gt;(</span><br><span class="line">            contentNode,</span><br><span class="line">            objectMapper.typeFactory.constructCollectionType(List::<span class="keyword">class</span>.java, contentClass.java)</span><br><span class="line">        ).toMutableList()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(1), (2) 커넥션을 맺거나 자원을 할당하고 해제하는 케이스가 없기 때문에 단순히 로그만 작성</li><li>(3) 1건식 읽어서 처리합니다. 해당 1건을 읽어 처리한 부분은 item processor로 넘어갈 수 있게 합니다.</li><li>(4) 실제로 HTTP 통신을 진행합니다.</li><li>(5) page, size 외 쿼리 파라미터를 처리합니다.</li><li>(6) HTTP Response Body를 객체로 시리얼라이즈 작업을 진행합니다. 이때 예외 처리를 진행하게 합니다.</li><li>(7) content 리스트 시리얼라이즈 진행</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;bookId&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;bookStatus&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OPEN&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;userId&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">&quot;number&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;numberOfElements&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;empty&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>content에 해당하는 내용들만 사용하기 때문에 content 노드를 찾아 해당 정보만 시리얼 라이즈를 진행합니다. HTTP Paging API에 대한 응답 형태를 통일화하여 특정 응답에 대해서만 지원 가능하게 유효성 검사 코드가 있습니다. 유연하게 사용 하기를 원하시면 해당 부분을 외부에는 변경이 가능하게 파라미터로 받는 방식으로 진행해도 무방합니다. 다만 통일된 응답 포맷을 갖는 것이 더 바람직하다고 생각합니다.</p><h2 id="Batch-Code">Batch Code</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpPageReaderJobConfiguration</span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> jobBuilderFactory: JobBuilderFactory,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> stepBuilderFactory: StepBuilderFactory</span><br><span class="line">) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@StepScope</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">httpPageReaderReader</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            entityManagerFactory: <span class="type">EntityManagerFactory</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> = HttpPageItemReader(</span><br><span class="line">            url = <span class="string">&quot;http://localhost:8080/api/members&quot;</span>, <span class="comment">// API 주소 </span></span><br><span class="line">            size = <span class="number">10</span>, <span class="comment">// 응답받을 content size로 대부분 chunk size와 동일하게 구성</span></span><br><span class="line">            page = <span class="number">0</span>, <span class="comment">// page start 값으로 대부분 0 부터 시작</span></span><br><span class="line">            parameters = listOf(</span><br><span class="line">                    <span class="string">&quot;age&quot;</span> to <span class="number">10</span>,</span><br><span class="line">                    <span class="string">&quot;email&quot;</span> to <span class="string">&quot;1232@asd.com&quot;</span></span><br><span class="line">            ), <span class="comment">// 쿼리 파라미터, page, size 외에 값을 사용</span></span><br><span class="line">            contentClass = BookReservation::<span class="keyword">class</span> <span class="comment">// 시리얼라이즈 대상 클래스</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@StepScope</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">httpPageReaderWriter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: ItemWriter&lt;BookReservation&gt; = ItemWriter &#123; contents -&gt;</span><br><span class="line">        <span class="keyword">for</span> (content <span class="keyword">in</span> contents) &#123;</span><br><span class="line">            println(content)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">BookReservation</span>(</span><br><span class="line">        <span class="keyword">val</span> bookId: <span class="built_in">Long</span>,</span><br><span class="line">        <span class="keyword">val</span> bookStatus:String,</span><br><span class="line">        <span class="keyword">val</span> userId: <span class="built_in">Long</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Local API를 호출하여 로그를 찍는 간단한 애플리케이션입니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/batch-study/docs/img/http-reader-1.png" alt=""></p><p>1~20 개의 모든 데이터를 조회하고 로그를 찍는 것을 확인할 수 있습니다.</p><h2 id="참고">참고</h2><ul><li><a href="https://kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;ejkGb=KOR&amp;barcode=9791162241264&amp;orderClick=JAj">처음 배우는 스프링 부트 2</a></li><li><a href="https://jojoldu.tistory.com/331">Spring Batch 가이드 - Chunk 지향 처리</a></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://cheese10yun.github.io/tags/Spring-Batch/">Spring Batch</category>
      
      
      <comments>https://cheese10yun.github.io/spring-batch-http-page-item-reader/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring Data MongoDB Repository 확장 - Aggregation 기반 페이징 처리</title>
      <link>https://cheese10yun.github.io/spring-data-mongo-repository-2/</link>
      <guid>https://cheese10yun.github.io/spring-data-mongo-repository-2/</guid>
      <pubDate>Thu, 30 Jan 2025 01:00:00 GMT</pubDate>
      
      <description>기존 Spring Data MongoDB Repository 확장 포스팅에서는 복잡한 쿼리 로직을 분리하여 상위 레벨에서는 구현 디테일을 신경 쓰지 않고, 데이터 접근 로직을 단순화할 수 있는 방법을 다루었습니다.</description>
      
      
      
      <content:encoded><![CDATA[<p>기존 <a href="https://cheese10yun.github.io/spring-data-mongo-repository/">Spring Data MongoDB Repository 확장</a> 포스팅에서는 복잡한 쿼리 로직을 분리하여 상위 레벨에서는 구현 디테일을 신경 쓰지 않고, 데이터 접근 로직을 단순화할 수 있는 방법을 다루었습니다.  특히, <strong>Slice 기반 및 Page 기반의 페이징 처리</strong>를 적용하여 다음과 같은 장점을 얻을 수 있었습니다.</p><ul><li><strong>Page 기반 페이징 처리</strong>:<ul><li>카운트 쿼리와 컨텐츠 쿼리를 <strong>병렬로 실행</strong>하여 성능 최적화</li></ul></li><li><strong>Slice 기반 페이징 처리</strong>:<ul><li><code>hasNext</code> 처리를 위임하여 반복적인 코드 없이 페이징을 처리</li></ul></li></ul><p>그러나 이러한 방식은 <strong>단순히 도큐먼트 객체(<code>T</code>) 타입</strong>을 기준으로 설계되어, <strong>복잡한 데이터 변환</strong>, <strong>조인</strong>, <strong>그룹화</strong> 등 다양한 데이터 처리 작업을 다루는 데 한계가 있었습니다. 특히, <strong>프로젝션</strong>을 활용한 <strong>데이터 조회</strong>나 <strong>복잡한 쿼리</strong>는 <code>Aggregation</code>을 사용하여 해결해야 하기 때문에, <strong><code>Aggregation</code>을 기반으로 하는 페이징 처리</strong>가 필요합니다.<br>따라서, 이번 포스팅에서는 <strong><code>MongoTemplate</code>을 기반으로 <code>Aggregation</code>을 활용한 페이징 처리</strong> 방법을 확장하여 이 문제를 해결하는 방법을 다루겠습니다.</p><h2 id="기존-Query-기반-Pagination과-Slice-처리">기존 Query 기반 Pagination과 Slice 처리</h2><p>기존 <code>applyPagination</code>과 <code>applySlice</code>는 <code>MongoTemplate</code>을 활용하여 <code>Query</code> 기반으로 페이징을 처리하는 방식이었습니다.</p><h3 id="Query-기반-Pagination-및-Slice-추상화">Query 기반 Pagination 및 Slice 추상화</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;S : T&gt;</span> <span class="title">applyPagination</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    contentQuery: (<span class="type">Query</span>) -&gt; <span class="type">List</span>&lt;<span class="type">S</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    countQuery: (<span class="type">Query</span>) -&gt; <span class="type">Long</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> content = async &#123; contentQuery(Query().with(pageable)) &#125;</span><br><span class="line">    <span class="keyword">val</span> totalCount = async &#123; countQuery(Query()) &#125;</span><br><span class="line">    PageImpl(content.await(), pageable, totalCount.await())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;S : T&gt;</span> <span class="title">applySlice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    contentQuery: (<span class="type">Query</span>) -&gt; <span class="type">List</span>&lt;<span class="type">S</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Slice&lt;S&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> content = contentQuery(Query().with(pageable))</span><br><span class="line">    <span class="keyword">val</span> hasNext = content.size &gt;= pageable.pageSize</span><br><span class="line">    <span class="keyword">return</span> SliceImpl(content, pageable, hasNext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="사용-예시">사용 예시</h3><p>기존 <code>applyPagination</code>과 <code>applySlice</code>를 활용하면 <code>MongoTemplate</code>을 사용하여 데이터를 간단하게 조회할 수 있습니다.</p><h4 id="Slice-조회">Slice 조회</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findSlice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    email: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    memberId: <span class="type">String</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Slice&lt;Member&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> criteria = Criteria()</span><br><span class="line">        .apply &#123;</span><br><span class="line">            name?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;name&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">            email?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;email&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">            memberId?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;member_id&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> applySlice(</span><br><span class="line">        pageable = pageable,</span><br><span class="line">        contentQuery = &#123;</span><br><span class="line">            mongoTemplate.find&lt;Member&gt;(it.addCriteria(criteria))</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Page-조회">Page 조회</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findPage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    email: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    memberId: <span class="type">String</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Page&lt;Member&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> criteria = Criteria().apply &#123;</span><br><span class="line">        name?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;name&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">        email?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;email&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">        memberId?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;member_id&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> applyPagination(</span><br><span class="line">        pageable = pageable,</span><br><span class="line">        contentQuery = &#123; mongoTemplate.find&lt;Member&gt;(it.addCriteria(criteria)) &#125;,</span><br><span class="line">        countQuery = &#123; mongoTemplate.count(it.addCriteria(criteria), documentClass) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 방식은 기본적인 도큐먼트(<code>T</code>) 조회에는 적합 하지만, 프로젝션을 활용한 데이터 조회에는 적용할 수 없는 한계가 있습니다.</p><h2 id="Aggregation을-활용한-Projection-및-Pagination-확장">Aggregation을 활용한 Projection 및 Pagination 확장</h2><p>MongoDB에서는 <strong>Aggregation</strong>을 활용하여 특정 필드만 선택하거나, 데이터를 변환하는 <strong>프로젝션</strong> 외에도, <strong>조인(<code>$lookup</code>)</strong>, <strong>그룹화(<code>$group</code>)</strong>, <strong>집계(<code>$count</code>)</strong>, <strong>정렬(<code>$sort</code>)</strong> 등 다양한 작업을 수행할 수 있습니다. 이러한 복잡한 데이터 처리 작업을 효율적으로 다루기 위해서는 <strong>Aggregation</strong> 기반의 페이징을 활용하는 것이 필요합니다. 이 방식은 기존 <code>Query</code> 기반 페이징 처리 방식에 비해 더 유연하고 강력한 쿼리 작성이 가능하며, 복잡한 데이터 변환 및 집계도 손쉽게 처리할 수 있습니다.</p><h3 id="Aggregation-기반-Pagination-및-Slice-추상화-코드-설명">Aggregation 기반 Pagination 및 Slice 추상화 코드 설명</h3><p>이 두 메서드는 MongoDB에서 <strong>Aggregation</strong>을 사용하여 페이징 처리 및 Slice 또는 Page 결과를 반환하는 기능을 제공합니다. 각 메서드는 <strong>Aggregation의 파이프라인</strong>을 동적으로 수정하고, <code>skip</code>과 <code>limit</code>을 추가하여 페이지네이션을 처리합니다.</p><h3 id="applyPaginationAggregation-메서드">applyPaginationAggregation 메서드</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;S&gt;</span> <span class="title">applyPaginationAggregation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    contentAggregation: <span class="type">Aggregation</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    countAggregation: <span class="type">Aggregation</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    contentQuery: (<span class="type">Aggregation</span>) -&gt; <span class="type">AggregationResults</span>&lt;<span class="type">S</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    countQuery: (<span class="type">Aggregation</span>) -&gt; <span class="type">AggregationResults</span>&lt;<span class="type">MongoCount</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: PageImpl&lt;S&gt; = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> skip = pageable.pageNumber * pageable.pageSize</span><br><span class="line">    <span class="keyword">val</span> limit = pageable.pageSize</span><br><span class="line"></span><br><span class="line">    contentAggregation.pipeline.apply &#123;</span><br><span class="line">        <span class="keyword">this</span>.add(Aggregation.skip(skip.toLong()))</span><br><span class="line">        <span class="keyword">this</span>.add(Aggregation.limit(limit.toLong()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    countAggregation.pipeline.apply &#123;</span><br><span class="line">        <span class="keyword">this</span>.add(Aggregation.count().`<span class="keyword">as</span>`(<span class="string">&quot;count&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform queries asynchronously</span></span><br><span class="line">    <span class="keyword">val</span> contentDeferred = async &#123; contentQuery(contentAggregation) &#125;</span><br><span class="line">    <span class="keyword">val</span> countDeferred = async &#123; countQuery(countAggregation) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> content = contentDeferred.await().mappedResults</span><br><span class="line">    <span class="keyword">val</span> totalCount = countDeferred.await().uniqueMappedResult?.count ?: <span class="number">0L</span></span><br><span class="line"></span><br><span class="line">    PageImpl(content, pageable, totalCount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="설명">설명</h3><ol><li><strong><code>contentAggregation</code></strong>:<ul><li>페이지네이션을 적용하기 위해 <code>skip</code>과 <code>limit</code>을 <code>contentAggregation</code>에 추가합니다. <code>skip</code>은 현재 페이지의 첫 번째 항목부터 건너뛸 수 있도록 하며, <code>limit</code>은 페이지당 보여줄 항목의 개수를 설정합니다.</li></ul></li><li><strong><code>countAggregation</code></strong>:<ul><li>카운트 쿼리를 처리하기 위해 <code>countAggregation</code>에서 <code>$count</code>를 사용하여 총 항목 수를 계산합니다. 이 단계에서는 <code>skip</code>과 <code>limit</code>을 적용하지 않고, 전체 항목 수만 계산합니다.</li></ul></li><li><strong><code>runBlocking</code></strong>:<ul><li>비동기 처리를 위해 <code>runBlocking</code>을 사용하여 <code>contentQuery</code>와 <code>countQuery</code>를 동시에 실행합니다. 이렇게 함으로써 <strong>페이징 처리 쿼리</strong>와 <strong>카운트 쿼리</strong>를 병렬로 실행하여 성능을 최적화합니다.</li></ul></li><li><strong>쿼리 실행</strong>:<ul><li><strong><code>contentQuery(contentAggregation)</code></strong>: <code>contentAggregation</code>을 기반으로 데이터를 조회합니다.</li><li><strong><code>countQuery(countAggregation)</code></strong>: <code>countAggregation</code>을 기반으로 총 개수를 조회합니다.</li></ul></li><li><strong>응답 생성</strong>:<ul><li><strong><code>content</code></strong>: 페이징된 결과 목록.</li><li><strong><code>totalCount</code></strong>: 전체 항목 수.</li><li><code>PageImpl</code> 객체를 생성하여 결과를 반환합니다.</li></ul></li></ol><h3 id="사용된-MongoDB-쿼리">사용된 MongoDB 쿼리</h3><h4 id="페이징-쿼리">페이징 쿼리</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">db.members.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$match&quot;: &#123;</span><br><span class="line">      &quot;member_id&quot;: &quot;memberId&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$project&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: 1.0,</span><br><span class="line">      &quot;email&quot;: 1.0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$skip&quot;: 0.0</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$limit&quot;: 10.0</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h4 id="카운트-쿼리">카운트 쿼리</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.members.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$match&quot;: &#123;</span><br><span class="line">      &quot;member_id&quot;: &quot;memberId&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$count&quot;: &quot;count&quot;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>이 두 쿼리는 각각 페이징 처리된 결과와 전체 항목 수를 계산하는 쿼리입니다. <code>contentAggregation</code>에서는 <code>skip</code>과 <code>limit</code>을 적용하여 데이터를 제한하고, <code>countAggregation</code>에서는 총 항목 수를 계산합니다.</p><h3 id="applySliceAggregation-메서드">applySliceAggregation 메서드</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;S&gt;</span> <span class="title">applySliceAggregation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    contentAggregation: <span class="type">Aggregation</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    contentQuery: (<span class="type">Aggregation</span>) -&gt; <span class="type">AggregationResults</span>&lt;<span class="type">S</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Slice&lt;S&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> skip = pageable.pageNumber * pageable.pageSize</span><br><span class="line">    <span class="keyword">val</span> limit = pageable.pageSize</span><br><span class="line">   contentAggregation.pipeline.apply &#123;</span><br><span class="line">        <span class="keyword">this</span>.add(Aggregation.skip(skip.toLong()))</span><br><span class="line">        <span class="keyword">this</span>.add(Aggregation.limit(limit.toLong()))</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">val</span> results = contentQuery(contentAggregation)</span><br><span class="line">    <span class="keyword">val</span> content = results.mappedResults</span><br><span class="line">    <span class="keyword">val</span> hasNext = content.size &gt;= pageable.pageSize</span><br><span class="line">    <span class="keyword">return</span> SliceImpl(content, pageable, hasNext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="설명-2"><strong>설명</strong>:</h3><ol><li><strong><code>contentAggregation</code></strong>:<ul><li><strong><code>contentAggregation</code></strong> 는 사용자가 제공한 Aggregation 객체입니다. 이 객체에는 <code>$match</code>, <code>$project</code>와 같은 데이터 변환 및 필터링 로직이 포함됩니다.</li><li><code>contentAggregation</code>에 <strong><code>skip</code></strong> 과 <strong><code>limit</code></strong> 을 추가하여 페이징을 처리합니다. 이를 통해 주어진 <code>pageable</code>에 맞게 데이터를 조회할 수 있습니다.</li></ul></li><li><strong><code>contentQuery</code></strong>:<ul><li><code>contentAggregation</code>을 기반으로 데이터를 조회하는 <code>contentQuery</code> 함수입니다. 이 함수는 <code>Aggregation</code>을 받아서 <code>mongoTemplate.aggregate</code>를 사용해 데이터를 가져옵니다.</li></ul></li><li><strong>쿼리 실행</strong>:<ul><li><code>contentQuery(contentAggregation)</code>를 실행하여 페이징된 결과를 가져옵니다.</li><li><code>skip</code>과 <code>limit</code>을 포함한 <code>contentAggregation</code>을 전달하여 데이터를 필터링합니다.</li></ul></li><li><strong>응답 생성</strong>:<ul><li><strong><code>content</code></strong>: 페이징된 결과.</li><li><strong><code>hasNext</code></strong>: <code>content</code>의 크기가 <code>pageable.pageSize</code>보다 크거나 같으면, 더 많은 데이터가 있다는 뜻으로 <code>hasNext</code>를 설정합니다.</li><li><code>SliceImpl</code> 객체를 생성하여 결과를 반환합니다.</li></ul></li></ol><h3 id="사용된-MongoDB-쿼리-2">사용된 MongoDB 쿼리</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">db.members.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;11-name&quot;,</span><br><span class="line">      &quot;email&quot;: &quot;11-asd@asd.com&quot;,</span><br><span class="line">      &quot;member_id&quot;: &quot;memberId&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$project&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: 1.0,</span><br><span class="line">      &quot;email&quot;: 1.0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$skip&quot;: 0.0</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$limit&quot;: 10.0</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="Aggregation-기반-Page-및-Slice-조회-예시">Aggregation 기반 <code>Page</code> 및 <code>Slice</code> 조회 예시</h3><h4 id="Slice-조회-2">Slice 조회</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findSliceAggregation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    email: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    memberId: <span class="type">String</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Slice&lt;MemberProjection&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> match = Aggregation.match(</span><br><span class="line">        Criteria().apply &#123;</span><br><span class="line">            name?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;name&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">            email?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;email&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">            memberId?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;member_id&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">val</span> projection = Aggregation.project()</span><br><span class="line">        .andInclude(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">        .andInclude(<span class="string">&quot;email&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.applySliceAggregation(</span><br><span class="line">        pageable = pageable,</span><br><span class="line">       contentAggregation = Aggregation.newAggregation(match, projection),</span><br><span class="line">        contentQuery = &#123; mongoTemplate.aggregate(it, Member.DOCUMENT_NAME, MemberProjection::<span class="keyword">class</span>.java) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Page-조회-2">Page 조회</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findPageAggregation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    email: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    memberId: <span class="type">String</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Page&lt;MemberProjection&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> match = Aggregation.match(</span><br><span class="line">        Criteria().apply &#123;</span><br><span class="line">            name?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;name&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">            email?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;email&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">            memberId?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;member_id&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">val</span> projection = Aggregation.project()</span><br><span class="line">        .andInclude(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">        .andInclude(<span class="string">&quot;email&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> applyPaginationAggregation(</span><br><span class="line">        pageable = pageable,</span><br><span class="line">        contentAggregation = Aggregation.newAggregation(match, projection),</span><br><span class="line">        countAggregation = Aggregation.newAggregation(match),</span><br><span class="line">        contentQuery = &#123; mongoTemplate.aggregate(it, Member.DOCUMENT_NAME, MemberProjection::<span class="keyword">class</span>.java) &#125;,</span><br><span class="line">        countQuery = &#123; mongoTemplate.aggregate(it, Member.DOCUMENT_NAME, MongoCount::<span class="keyword">class</span>.java) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="결론"><strong>결론</strong></h2><ul><li>기존 <code>Query</code> 기반 페이징에서 <code>T</code> 타입 한계를 벗어나 <strong>Projection을 지원</strong>하도록 확장</li><li><strong><code>Aggregation</code>을 활용한 페이징 처리</strong>로 다양한 데이터 변환 및 성능 최적화 가능</li><li><strong>비동기(<code>async</code>) 처리로 성능 최적화</strong>하며, 코드 재사용성을 높임</li></ul><p>이제 Spring Data MongoDB에서 <strong>확장 가능한 Projection 기반 Pagination을 활용한 Repository를 구축</strong>할 수 있습니다.</p>]]></content:encoded>
      
      
      
      <category domain="https://cheese10yun.github.io/tags/Spring/">Spring</category>
      
      <category domain="https://cheese10yun.github.io/tags/MongoDB/">MongoDB</category>
      
      <category domain="https://cheese10yun.github.io/tags/Pagination/">Pagination</category>
      
      
      <comments>https://cheese10yun.github.io/spring-data-mongo-repository-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring Data MongoDB에서의 Update 전략과 경험</title>
      <link>https://cheese10yun.github.io/spring-data-mongo-update-guide-1/</link>
      <guid>https://cheese10yun.github.io/spring-data-mongo-update-guide-1/</guid>
      <pubDate>Fri, 17 Jan 2025 15:00:00 GMT</pubDate>
      
      <description>이 글에서는 Spring Data MongoDB에서 업데이트 전략을 중심으로 개발 경험에서 얻은 인사이트를 공유하며, 각 메서드의 동작 방식과 적절한 사용 방법에 대해 논의합니다.</description>
      
      
      
      <content:encoded><![CDATA[<p>Spring Data MongoDB를 활용한 애플리케이션 개발 과정에서, 데이터를 업데이트하는 방법은 프로젝트의 설계와 성능에 큰 영향을 미칩니다. 특히, <code>mongoRepository.save</code>, <code>mongoTemplate.save</code>, 그리고 <code>mongoTemplate.updateFirst</code>와 같은 메서드들은 각각의 특성과 적합한 상황이 다릅니다. 이 글에서는 Spring Data MongoDB에서 <strong>업데이트 전략</strong>을 중심으로 개발 경험에서 얻은 인사이트를 공유하며, 각 메서드의 동작 방식과 적절한 사용 방법에 대해 논의합니다.</p><h2 id="Update-메서드-비교">Update 메서드 비교</h2><p>Spring Data MongoDB에서 사용되는 주요 업데이트 메서드들은 아래와 같이 동작 방식과 적합한 시나리오에서 차이가 있습니다:</p><table><thead><tr><th><strong>특징</strong></th><th><strong>mongoRepository.save</strong></th><th><strong>mongoTemplate.save</strong></th><th><strong>mongoTemplate.updateFirst</strong></th></tr></thead><tbody><tr><td><strong>작업 대상</strong></td><td>단일 문서</td><td>단일 문서</td><td>단일 문서</td></tr><tr><td><strong>저장 방식</strong></td><td>변경된 필드만 업데이트</td><td>전체 문서 교체</td><td>변경된 필드만 업데이트</td></tr><tr><td><strong>문서가 없을 경우</strong></td><td>새로 삽입</td><td>새로 삽입</td><td>기본적으로 아무 작업도 수행하지 않음</td></tr><tr><td><strong>업데이트 범위</strong></td><td>필드 단위</td><td>전체 문서</td><td>필드 단위</td></tr><tr><td><strong>조건 지정</strong></td><td><code>_id</code> 기준</td><td><code>_id</code> 기준</td><td>사용자 정의 쿼리</td></tr><tr><td><strong>Spring Data 통합</strong></td><td>페이징, 정렬 등 지원</td><td>미지원</td><td>미지원</td></tr><tr><td><strong>적합한 상황</strong></td><td>간단한 CRUD 작업</td><td>전체 문서 교체 또는 삽입</td><td>조건에 맞는 단일 문서 필드 수정</td></tr></tbody></table><h3 id="mongoTemplate-save">mongoTemplate.save</h3><p>문서 전체 교체(Replace)를 수행합니다.</p><h4 id="동작-방식">동작 방식</h4><ul><li><code>_id</code> 필드를 기준으로 MongoDB에서 문서를 검색.</li><li>문서가 존재하면 <strong>전체 문서를 교체</strong>합니다.</li><li>문서가 존재하지 않으면 새로 삽입합니다.</li><li>저장 객체에 없는 필드는 기존 문서에서 삭제됩니다.</li></ul><h4 id="예제">예제</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> user = User(id = <span class="string">&quot;123&quot;</span>, name = <span class="string">&quot;John Doe&quot;</span>, age = <span class="number">30</span>)</span><br><span class="line">mongoTemplate.save(user)</span><br></pre></td></tr></table></figure><h4 id="결과">결과</h4><ul><li>기존 문서: <code>&#123; &quot;_id&quot;: &quot;123&quot;, &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25, &quot;email&quot;: &quot;alice@example.com&quot; &#125;</code></li><li>업데이트 후: <code>&#123; &quot;_id&quot;: &quot;123&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 30 &#125;</code></li><li>변경 사항: <code>email</code> 필드가 삭제됨.</li></ul><h3 id="mongoRepository-save">mongoRepository.save</h3><p>문서의 일부 필드만 업데이트(Partial Update)를 수행합니다.</p><h4 id="동작-방식-2">동작 방식</h4><ul><li><code>_id</code> 필드를 기준으로 MongoDB에서 문서를 검색.</li><li>문서가 존재하면 <strong>변경된 필드만 업데이트</strong>하고, 나머지 필드는 유지됩니다.</li><li>문서가 존재하지 않으면 새로 삽입합니다.</li></ul><h4 id="예제-2">예제</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> user = User(id = <span class="string">&quot;123&quot;</span>, name = <span class="string">&quot;John Doe&quot;</span>)</span><br><span class="line">userRepository.save(user)</span><br></pre></td></tr></table></figure><h4 id="결과-2">결과</h4><ul><li>기존 문서: <code>&#123; &quot;_id&quot;: &quot;123&quot;, &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25, &quot;email&quot;: &quot;alice@example.com&quot; &#125;</code></li><li>업데이트 후: <code>&#123; &quot;_id&quot;: &quot;123&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 25, &quot;email&quot;: &quot;alice@example.com&quot; &#125;</code></li><li>변경 사항: <code>name</code> 필드만 업데이트, 나머지 필드는 유지됨.</li></ul><h3 id="mongoTemplate-updateFirst">mongoTemplate.updateFirst</h3><p>MongoDB의 <strong><code>updateFirst</code></strong> 명령어를 실행하여 <strong>단일 문서를 부분 업데이트</strong>합니다.</p><h4 id="동작-방식-3">동작 방식</h4><ul><li>조건을 지정하여 MongoDB에서 문서를 검색.</li><li>첫 번째로 매칭된 문서의 <strong>일부 필드만 업데이트</strong>합니다.</li><li>문서가 존재하지 않으면 기본적으로 아무 작업도 수행하지 않습니다(삽입하지 않음).</li><li><code>$set</code>과 같은 MongoDB 연산자를 사용하여 지정된 필드만 업데이트합니다.</li></ul><h4 id="예제-3">예제</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = Query(Criteria.<span class="keyword">where</span>(<span class="string">&quot;name&quot;</span>).`<span class="keyword">is</span>`(<span class="string">&quot;Alice&quot;</span>))</span><br><span class="line"><span class="keyword">val</span> update = Update().<span class="keyword">set</span>(<span class="string">&quot;age&quot;</span>, <span class="number">30</span>)</span><br><span class="line">mongoTemplate.updateFirst(query, update, User::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure><h4 id="결과-3">결과</h4><ul><li>기존 문서: <code>&#123; &quot;_id&quot;: &quot;123&quot;, &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25, &quot;email&quot;: &quot;alice@example.com&quot; &#125;</code></li><li>업데이트 후: <code>&#123; &quot;_id&quot;: &quot;123&quot;, &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 30, &quot;email&quot;: &quot;alice@example.com&quot; &#125;</code></li><li>변경 사항: <code>age</code> 필드만 업데이트, 나머지 필드는 유지됨.</li></ul><h2 id="효율적인-MongoDB-업데이트-전략">효율적인 MongoDB 업데이트 전략</h2><p><code>mongoTemplate.save</code>는 문서 전체를 교체하기 때문에 일반적인 경우에는 거의 사용되지 않습니다. 반면, <code>mongoRepository.save</code>는 더 직관적이며, 특히 Spring Data JPA 경험이 있는 개발자에게는 익숙하고 이해하기 쉬운 방식입니다. 그럼에도 불구하고, 저는 업데이트 작업에 <code>mongoTemplate</code>기반의 업데이트만을 사용하고 있습니다. 그 이유는 다음과 같습니다.</p><h3 id="대량-처리에서의-성능-차이">대량 처리에서의 성능 차이</h3><p><a href="https://cheese10yun.github.io/spring-data-mongodb-update-performance/">MongoDB Update 성능 측정 및 분석</a>에서 업데이트 성능을 측정한 결과를 참고할 수 있습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/5fc6127a0800ca9bce5de5a6c73931b2025b0791/mongo-study/images/performance-update.png" alt=""></p><table><thead><tr><th><strong>Rows</strong></th><th><strong>saveAll</strong></th><th><strong>updateFirst</strong></th><th><strong>bulkOps (UNORDERED)</strong></th><th><strong>bulkOps (ORDERED)</strong></th></tr></thead><tbody><tr><td>100</td><td>1,052 ms</td><td>1,176 ms</td><td>46 ms</td><td>79 ms</td></tr><tr><td>200</td><td>2,304 ms</td><td>2,196 ms</td><td>103 ms</td><td>124 ms</td></tr><tr><td>500</td><td>5,658 ms</td><td>5,250 ms</td><td>309 ms</td><td>257 ms</td></tr><tr><td>1,000</td><td>11,106 ms</td><td>10,846 ms</td><td>418 ms</td><td>412 ms</td></tr><tr><td>2,000</td><td>22,592 ms</td><td>21,427 ms</td><td>1,060 ms</td><td>1,004 ms</td></tr><tr><td>5,000</td><td>54,407 ms</td><td>52,075 ms</td><td>2,663 ms</td><td>2,292 ms</td></tr><tr><td>10,000</td><td>107,651 ms</td><td>110,884 ms</td><td>4,514 ms</td><td>4,496 ms</td></tr></tbody></table><p><code>saveAll</code> 방식은 각 문서의 <code>_id</code>를 확인하여 데이터베이스에 해당 문서가 존재하는지 판단합니다. 존재하는 경우에는 이를 업데이트로 인식하고, 내부적으로 반복문을 돌면서 <code>save</code>를 개별적으로 호출합니다. 이로 인해 각 문서에 대해 별도의 데이터베이스 요청이 발생하며, 처리 성능이 문서 수에 비례하여 저하될 수 있습니다. 특히, 요청 수가 많아질수록 이러한 방식은 응답 시간이 급격히 증가하는 원인이 됩니다.</p><p>반면, <code>bulkOps</code>는 여러 업데이트 작업을 한 번의 연산으로 묶어서 실행하므로 대량 처리에서 훨씬 효율적입니다. 이를 통해 처리 시간을 크게 단축할 수 있지만, <code>save</code>와 <code>saveAll</code> 방식으로는 <code>bulkOps</code>를 활용할 수 없다는 한계가 있습니다. 이러한 이유로 저는 대량 처리 작업에서 <code>updateFirst</code>와 함께 <code>bulkOps</code>를 활용하는 방식을 선호합니다.</p><p>또한, 대량 데이터를 업데이트할 때 <strong><code>where in</code> 절</strong>을 활용하면 효과적입니다. 이 경우, <code>mongoTemplate.updateMulti</code>를 사용하면 <code>bulkOps</code> 방식과 유사한 성능을 얻을 수 있습니다. <code>saveAll</code>을 사용하면 성능이 급격히 저하되므로, 대량 데이터를 업데이트할 때는 반드시 <code>mongoTemplate</code>을 사용하는 것이 좋습니다. 이러한 접근 방식은 대량 처리의 효율성과 성능 최적화를 보장하며, 대량 데이터를 다루는 애플리케이션에서 더욱 유용합니다.</p><h3 id="명확한-변경-사항-추적">명확한 변경 사항 추적</h3><p><code>mongoRepository.save</code>를 사용하여 데이터를 업데이트할 경우, 정확히 어떤 필드가 변경되었는지 추적하기 어렵습니다. MongoDB는 비정형 데이터베이스로, 다양한 필드와 그 필드들이 다루는 컨텍스트가 매우 다양합니다. 이런 상황에서 <code>mongoRepository.save</code>를 통해 업데이트가 이루어지면, 어떤 필드가 어떤 조건에서 업데이트되었는지 명확히 파악하기 어렵기 때문에 데이터 변경 사항을 추적하고 관리하는 데 어려움이 발생할 수 있습니다.</p><p>반면, <code>mongoTemplate</code>을 기반으로 업데이트 쿼리를 작성하면 특정 필드에 대해 명확히 정의된 업데이트를 수행할 수 있습니다. 각 업데이트가 어디에서 이루어졌는지, 어떤 필드가 변경되었는지를 코드 레벨에서 명확히 확인할 수 있어 추적이 용이합니다. 특히 프로젝트가 복잡해지거나 엄격한 변경 관리가 요구될수록, 이러한 명확성은 유지보수와 협업 측면에서 큰 장점으로 작용합니다. 이를 통해 데이터 업데이트의 불확실성을 줄이고, 코드의 가독성과 신뢰성을 높일 수 있습니다.</p><h2 id="실제-사용-예시">실제 사용 예시</h2><h3 id="Document-정의">Document 정의</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document(collection = <span class="string">&quot;members&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span>(</span><br><span class="line">    <span class="meta">@Field(name = <span class="string">&quot;name&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = <span class="string">&quot;address&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> address: Address,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = <span class="string">&quot;member_id&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> memberId: String,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = <span class="string">&quot;email&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> email: String,</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = <span class="string">&quot;status&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> status: MemberStatus</span><br><span class="line">) : Auditable()</span><br></pre></td></tr></table></figure><p>위 예시와 같이 <code>Member</code> 도큐먼트가 정의되어 있다고 가정하겠습니다. 이 도큐먼트는 <code>MongoRepository</code>를 사용하여 업데이트하지 않기 때문에, 필드들이 <code>val</code>로 지정되어 있습니다. 필드를 <code>val</code>로 지정하면 도큐먼트의 특정 필드를 변경하기 위해 객체를 직접 수정한 뒤 <code>save</code>를 호출하는 방식이 불가능합니다. 이렇게 필드를 <code>val</code>로 지정하면 도큐먼트의 불변성을 보장하며, 특정 필드의 변경을 엄격히 관리할 수 있습니다.</p><h3 id="Repository-정의">Repository 정의</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MemberRepository</span> : <span class="type">MongoRepository</span>&lt;<span class="type">Member, ObjectId</span>&gt;, <span class="type">MemberCustomRepository</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MemberCustomRepository</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateName</span><span class="params">(targets: <span class="type">List</span>&lt;<span class="type">MemberQueryForm</span>.<span class="type">UpdateName</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemberCustomRepositoryImpl</span>(mongoTemplate: MongoTemplate) : MemberCustomRepository, MongoCustomRepositorySupport&lt;Member&gt;(Member::<span class="keyword">class</span>.java, mongoTemplate) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateName</span><span class="params">(targets: <span class="type">List</span>&lt;<span class="type">MemberQueryForm</span>.<span class="type">UpdateName</span>&gt;)</span></span> &#123;</span><br><span class="line">        bulkUpdate(</span><br><span class="line">            targets.map &#123;</span><br><span class="line">                Pair(</span><br><span class="line">                    &#123; Query(Criteria.<span class="keyword">where</span>(<span class="string">&quot;id&quot;</span>).`<span class="keyword">is</span>`(it.id)) &#125;,</span><br><span class="line">                    &#123; Update().<span class="keyword">set</span>(<span class="string">&quot;name&quot;</span>, it.name) &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MongoCustomRepositorySupport</code>를 상속받아 <code>bulkUpdate</code> 메서드를 통해 <code>bulkOps</code>를 사용한 대량 업데이트를 수행합니다. 이를 활용하면 대량 데이터를 효율적으로 처리할 수 있으며, 단일 업데이트만 필요한 경우 <code>updateFirst</code>를 사용하여 업데이트를 수행할 수도 있습니다. 그러나 특별한 이유가 없다면 <code>MongoCustomRepositorySupport</code> 기반으로 대량 업데이트를 지원하는 <code>bulkUpdate</code>를 사용하는 것을 권장합니다.</p><p>이 방식에 대한 자세한 구현 방법은 이전 포스팅 <a href="https://cheese10yun.github.io/spring-data-mongodb-update-performance/">MongoDB Update 성능 측정 및 분석 - MongoCustomRepositorySupport을 통한 bulkOps 기능 제공</a>에서 확인할 수 있습니다.</p><h3 id="업데이트-쿼리에-사용할-객체-정의">업데이트 쿼리에 사용할 객체 정의</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> MemberQueryForm &#123;</span><br><span class="line">    <span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">UpdateName</span>(</span><br><span class="line">        <span class="keyword">val</span> id: ObjectId,</span><br><span class="line">        <span class="keyword">val</span> name: String</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MemberQueryForm</code> 객체를 정의하여 쿼리에 필요한 필드와 데이터를 명확하게 관리합니다. 이를 통해 업데이트 작업에서 어떤 필드가 업데이트되는지 명확히 파악할 수 있습니다. 만약 <code>MemberQueryForm</code>에 정의되지 않은 필드가 있다면, 해당 필드는 현재 업데이트 대상이 아니거나 정책적으로 업데이트되지 않는 필드라고 간주할 수 있습니다.</p><h3 id="테스트-코드-예시">테스트 코드 예시</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MongoTestSupport</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemberRepositoryTest</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> memberRepository: MemberRepository</span><br><span class="line">) : MongoStudyApplicationTests() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `updateName test`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// given</span></span><br><span class="line">        <span class="keyword">val</span> members = (<span class="number">1.</span><span class="number">.20</span>).map &#123;</span><br><span class="line">            Member(</span><br><span class="line">                name = <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                ...</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> targets = mongoTemplate</span><br><span class="line">            .insertAll(members).map &#123;</span><br><span class="line">                MemberQueryForm.UpdateName(</span><br><span class="line">                    id = it.id!!,</span><br><span class="line">                    name = <span class="string">&quot;newName&quot;</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// when</span></span><br><span class="line">        memberRepository.updateName(targets)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// then</span></span><br><span class="line">        <span class="keyword">val</span> results = mongoTemplate.findAll&lt;Member&gt;()</span><br><span class="line"></span><br><span class="line">        then(results).hasSize(<span class="number">20</span>)</span><br><span class="line">        then(results).allSatisfy &#123;</span><br><span class="line">            then(it.name).isEqualTo(<span class="string">&quot;newName&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>해당 테스트 코드는 <code>MemberRepository</code>의 <code>updateName</code> 메서드를 검증합니다.</p><ol><li>먼저 <code>Member</code> 객체를 생성하고 MongoDB에 저장한 뒤, 저장된 데이터를 조회하여 <code>UpdateName</code> 객체를 생성합니다.</li><li>이후 <code>updateName</code> 메서드를 호출하여 업데이트를 수행합니다.</li><li>마지막으로 MongoDB에서 데이터를 다시 조회해, 업데이트가 성공적으로 이루어졌는지 확인합니다.</li></ol><p>이처럼 <code>MemberQueryForm</code> 객체를 사용해 업데이트 대상 필드를 명확히 정의함으로써, 변경 작업의 범위를 명확히 관리하고 추적할 수 있습니다. 테스트 코드 역시 이러한 명확성을 기반으로 업데이트 로직을 확인하도록 작성되었습니다.</p><h2 id="정리">정리</h2><p>제가 담당하는 도메인은 특정 필드마다 업데이트 권한이 다르게 설정되어 있어, 업데이트 필드를 보다 명확하고 엄격하게 관리해야 하는 상황입니다. 또한, 대량의 데이터를 처리해야 하며, 빠른 처리를 보장해야 하는 요구사항도 있습니다. 이러한 이유로, 위에서 설명한 방식의 업데이트 전략을 선택했습니다. 각자의 상황과 요구사항에 맞는 적절한 방법을 선택하는 것이 가장 중요합니다.</p>]]></content:encoded>
      
      
      
      <category domain="https://cheese10yun.github.io/tags/Guide/">Guide</category>
      
      <category domain="https://cheese10yun.github.io/tags/Performance/">Performance</category>
      
      <category domain="https://cheese10yun.github.io/tags/Mongo/">Mongo</category>
      
      
      <comments>https://cheese10yun.github.io/spring-data-mongo-update-guide-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hikari와 비교하며 알아보는 Redis Lettuce 커넥션 풀의 특징</title>
      <link>https://cheese10yun.github.io/redis-lettuce-connection/</link>
      <guid>https://cheese10yun.github.io/redis-lettuce-connection/</guid>
      <pubDate>Sun, 17 Nov 2024 07:13:12 GMT</pubDate>
      
      <description>Redis는 싱글 스레드로 동작하는 인메모리 데이터베이스로, 모든 요청을 순차적으로 처리합니다. 이러한 특성 때문에 많은 개발자들은 Redis 클라이언트인 Lettuce에서 제공하는 커넥션 풀의 필요성과 이점에 대해 의문을 가질 수 있습니다.</description>
      
      
      
      <content:encoded><![CDATA[<p>Redis는 싱글 스레드로 동작하는 인메모리 데이터베이스로, 모든 요청을 순차적으로 처리합니다. 이러한 특성 때문에 많은 개발자들은 Redis 클라이언트인 Lettuce에서 제공하는 <strong>커넥션 풀의 필요성과 이점</strong>에 대해 의문을 가질 수 있습니다. 특히, &quot;<strong>Redis는 싱글 스레드로 동작하기 때문에 여러 개의 커넥션을 사용해도 동시성을 처리할 수 없을 텐데, 이런 커넥션 풀이 무슨 의미가 있을까?</strong>&quot;라는 생각을 할 수 있습니다.</p><p>Redis 클라이언트에서 커넥션 풀을 사용하는 이유는 서버의 동작 방식과 클라이언트 애플리케이션에서의 요구사항이 다르기 때문입니다. Redis는 서버 레벨에서 요청을 순차적으로 처리하지만, 클라이언트 애플리케이션은 <strong>동시성과 성능을 최적화하기 위해 비동기 및 넌블로킹 I/O를 지원하는 Lettuce</strong>와 같은 클라이언트를 통해 여러 요청을 효과적으로 관리합니다. Lettuce는 이러한 특성을 활용해 적은 수의 커넥션으로도 높은 효율을 발휘할 수 있도록 설계되었습니다.</p><p>이번 글에서는 Hikari Connection Pool과 비교하며 Lettuce 커넥션 풀이 애플리케이션 성능에 미치는 영향을 실제 사례를 통해 구체적으로 살펴보겠습니다.</p><h2 id="JDBC-Hikari-Connection-Pool의-동작-방식">JDBC Hikari Connection Pool의 동작 방식</h2><p>Redis Lettuce 커넥션 풀의 역할을 이해하기 위해, 먼저 전통적인 데이터베이스 커넥션 풀의 대표적인 예인 <strong>JDBC Hikari Connection Pool</strong>을 살펴보겠습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/refs/heads/master/redis/docs/lettuce-000.png" alt=""></p><p>전통적인 Hikari Connection Pool에서는 애플리케이션이 주문 정보를 조회하기 위해 커넥션 풀에서 하나의 커넥션을 가져옵니다. 아래 그림에서 볼 수 있듯이, <strong>idleConnections</strong>가 10개라면, 그 중 하나의 커넥션을 가져와 <strong>activeConnections</strong>로 전환하게 됩니다. 이 경우 <strong>idleConnections</strong>는 9개로 줄고, <strong>activeConnections</strong>는 1개가 됩니다. 전체 <strong>totalConnections</strong>는 변하지 않고 유지됩니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/refs/heads/master/redis/docs/connection-pool-001.png" alt="Hikari Connection Pool - Idle to Active"></p><p>만약 요청이 많이 들어와 응답이 지연되고 있는 경우를 생각해 봅시다. 아래 그림처럼 <strong>maximum-pool-size</strong>가 10개인 상황에서, 모든 10개의 커넥션이 <strong>activeConnections</strong>로 전환되어 사용 중이라면, 추가적인 요청은 <strong>threadsAwaitingConnection</strong>으로 들어가 대기하게 됩니다. 즉, 사용 가능한 커넥션이 없기 때문에 요청 스레드는 커넥션이 반환될 때까지 기다려야 합니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/refs/heads/master/redis/docs/connection-pool-002.png" alt="Hikari Connection Pool - Threads Awaiting Connection"></p><p>이와 같이 전통적인 커넥션 풀의 개념에서는, <strong>요청 스레드마다 활성화된 커넥션을 사용</strong>하며, 해당 스레드가 작업을 끝내기 전까지는 <strong>커넥션을 점유</strong>하게 됩니다. 이는 데이터베이스의 동시 연결 수와 처리 능력을 효과적으로 관리할 수 있는 방법이지만, 커넥션이 사용 중일 때 대기하는 요청들이 발생할 수 있다는 단점이 있습니다.</p><p>이제 이러한 전통적인 커넥션 풀과 비교하여, <strong>Redis Lettuce Connection Pool</strong>이 어떻게 다른 방식으로 동작하는지에 대해 알아보겠습니다.</p><h2 id="Redis-Lettuce-Connection-Pool의-동작-방식">Redis Lettuce Connection Pool의 동작 방식</h2><p>Redis Lettuce Connection Pool의 동작 방식을 이해하기 위해, <strong>Redis 조회와 MySQL 조회가 함께 사용되는 시나리오</strong>를 살펴보겠습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/refs/heads/master/redis/docs/lettuce-001.png" alt=""></p><p>위의 시나리오에서 애플리케이션은 먼저 Redis에서 쿠폰 정보를 조회한 후, MySQL에서 주문 정보를 조회합니다. Redis 쿠폰 조회는 10ms 만에 응답이 오지만, 이후 이어지는 MySQL 조회는 2,500ms가 걸립니다. 이 상황에서 Redis Lettuce 커넥션 풀이 어떻게 동작하는지를 이해하는 것이 중요합니다.</p><p>Redis에 쿠폰 조회 요청을 보내면, 10ms 내에 쿠폰 정보가 응답됩니다. 여기서 Lettuce 커넥션 풀이 1개만 있다고 가정해 보겠습니다. 만약 이 상황이 전통적인 커넥션 풀 구조였다면, MySQL 데이터 조회(2,500ms)가 완료되기 전까지 하나뿐인 Redis 커넥션이 블록되어 Redis에 대한 추가적인 요청을 처리할 수 없었을 것입니다. 이는 Redis 서버가 이미 응답을 완료했음에도 불구하고, 애플리케이션 측에서 더 이상 Redis에 대한 요청을 처리할 수 없게 된다는 문제를 야기합니다.</p><p>그러나 Redis Lettuce의 경우 비동기적으로 동작할 수 있습니다. Redis 서버에서 응답을 내린 후 해당 커넥션이 즉시 반환된다면, MySQL 조회가 진행 중이더라도 Redis에 대한 새로운 요청을 처리할 수 있게 됩니다. 이는 Redis 서버가 싱글 스레드로 동작하더라도 Lettuce 클라이언트 측에서는 추가적인 요청을 계속해서 보낼 수 있는 가능성을 열어줍니다. 그렇다면 실제로 Redis Lettuce가 이러한 방식으로 동작하는지, 아니면 다른 방식으로 동작하는지 <strong>코드를 통해 더 자세히 살펴보겠습니다</strong>.</p><h2 id="Redis-Lettuce와-Hikari-동작-비교를-위한-코드">Redis Lettuce와 Hikari 동작 비교를 위한 코드</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemberController</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> redisConnectionPoolSample: RedisConnectionPoolSample,</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(<span class="string">&quot;/api/redis&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getRedis</span><span class="params">(<span class="meta">@RequestParam(<span class="string">&quot;id&quot;</span>)</span> id: <span class="type">String</span>)</span></span> = redisConnectionPoolSample.getRedis(id)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(<span class="string">&quot;/api/mysql&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getMySql</span><span class="params">(<span class="meta">@RequestParam(<span class="string">&quot;id&quot;</span>)</span> id: <span class="type">Long</span>)</span></span> = redisConnectionPoolSample.getMySql(id)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(<span class="string">&quot;/api/composite&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getRedis2</span><span class="params">(<span class="meta">@RequestParam(<span class="string">&quot;id&quot;</span>)</span> id: <span class="type">String</span>)</span></span> = redisConnectionPoolSample.getComposite(id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisConnectionPoolSample</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> couponRepository: CouponRepository,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> orderRepository: OrderRepository</span><br><span class="line"></span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getRedis</span><span class="params">(id: <span class="type">String</span>)</span></span>: Coupon? &#123;</span><br><span class="line">        <span class="keyword">return</span> couponRepository.findByIdOrNull(id)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getMySql</span><span class="params">(id: <span class="type">Long</span>)</span></span>: Order? &#123;</span><br><span class="line">        printHikariConnection()</span><br><span class="line">        <span class="keyword">return</span> orderRepository.findByIdOrNull(id)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getComposite</span><span class="params">(id: <span class="type">String</span>)</span></span>: Pair&lt;Coupon?, Order?&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> coupon = couponRepository.findByIdOrNull(id)</span><br><span class="line">        <span class="keyword">val</span> order = orderRepository.findByIdOrNull(id.toLong())</span><br><span class="line">        Thread.sleep(<span class="number">2500</span>) <span class="comment">// 2.5초 대기</span></span><br><span class="line">        printHikariConnection()</span><br><span class="line">        <span class="keyword">return</span> Pair(coupon, order)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">printHikariConnection</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> targetDataSource = dataSource.unwrap(HikariDataSource::<span class="keyword">class</span>.java)</span><br><span class="line">        <span class="keyword">val</span> hikariDataSource = targetDataSource <span class="keyword">as</span> HikariDataSource</span><br><span class="line">        <span class="keyword">val</span> hikariPoolMXBean = hikariDataSource.hikariPoolMXBean</span><br><span class="line">        <span class="keyword">val</span> hikariConfigMXBean = hikariDataSource.hikariConfigMXBean</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> log = buildString &#123;</span><br><span class="line">            append(<span class="string">&quot;totalConnections: <span class="subst">$&#123;hikariPoolMXBean.totalConnections&#125;</span>, &quot;</span>)</span><br><span class="line">            append(<span class="string">&quot;activeConnections: <span class="subst">$&#123;hikariPoolMXBean.activeConnections&#125;</span>, &quot;</span>)</span><br><span class="line">            append(<span class="string">&quot;idleConnections: <span class="subst">$&#123;hikariPoolMXBean.idleConnections&#125;</span>, &quot;</span>)</span><br><span class="line">            append(<span class="string">&quot;threadsAwaitingConnection: <span class="subst">$&#123;hikariPoolMXBean.threadsAwaitingConnection&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        println(log)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드에서 <code>/api/redis</code>는 단순히 Redis에서 쿠폰 정보를 조회하는 API입니다. <code>/api/mysql</code>은 MySQL에서 주문 정보를 조회하는 API이며, <code>/api/composite</code>는 Redis 조회 후 MySQL 조회를 수행하고 2.5초 동안 대기한 후 응답을 반환하는 API입니다.</p><p>특히 <code>/api/composite</code>는 Redis에서 쿠폰을 조회한 후 MySQL 조회를 수행하며, 이때 <code>Thread.sleep(2500)</code>으로 인해 2.5초 동안 대기하게 됩니다. 이 상황에서 Lettuce의 커넥션 풀이 어떻게 동작하는지 살펴볼 수 있습니다.</p><h2 id="시나리오별-Hikari와-Lettuce의-차이점">시나리오별 Hikari와 Lettuce의 차이점</h2><p>이 섹션에서는 Hikari와 Lettuce의 동작 방식을 서로 비교하면서 각 시나리오에서 어떤 차이점이 발생하는지에 대해 구체적으로 살펴보겠습니다. 이를 통해 각 커넥션 풀이 어떤 차이점을 갖고 있는지 명확히 이해할 수 있습니다.</p><h3 id="시나리오-getComposite-호출-이후-getMySql-호출">시나리오: getComposite 호출 이후 getMySql 호출</h3><p>Hikari 설정은 <code>maximum-pool-size=1</code>, <code>minimum-idle=1</code>로 구성되어 있으며, <code>getComposite</code> 호출 시 사용 가능한 단 하나의 커넥션을 사용하여 작업이 진행됩니다. 이번 테스트의 목적은 <strong><code>/api/composite</code> 호출 이후 <code>getMySql</code> 호출의 응답 속도를 확인</strong>하는 것입니다. 만약 Hikari Connection Pool이 블로킹 방식으로 동작한다면 <code>getComposite</code> 호출 중 MySQL 조회 요청으로 점유된 커넥션이 반환되지 않아 <code>getMySql</code> 요청은 대기 상태에 놓이고 응답 시간이 지연될 것입니다. 반대로 MySQL 조회 요청이 빠르게 완료되거나, 추가적인 idle 커넥션이 있다면 <code>getMySql</code> 요청은 지연 없이 처리될 수 있습니다.</p><p>이 상태에서 <code>getMySql</code> 호출을 시도하면, 사용 가능한 <strong>idle 커넥션</strong>이 없기 때문에 <code>getComposite</code> 호출이 끝난 후 반환된 커넥션을 사용해야 합니다. 이로 인해 <strong>threadsAwaitingConnection</strong> 상태에서 대기하게 되고, 지연이 발생합니다. 이후 <strong>threadsAwaitingConnection</strong>에서 대기하던 요청이 <strong>activeConnections</strong>로 전환되면, <code>getMySql</code> 호출에서 해당 커넥션을 사용할 수 있게 됩니다.</p><h4 id="테스트-결과">테스트 결과</h4><ol><li><p><code>/api/mysql</code> 단독 호출 시:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Connection totalConnections: 1, activeConnections: 1, idleConnections: 0, threadsAwaitingConnection: 0</span><br><span class="line"># HTTP 응답 Response code: 200; Time: 24ms (24 ms); Content length: 64 bytes (64 B)</span><br></pre></td></tr></table></figure></li><li><p><code>/api/composite</code> 호출 이후 바로 <code>/api/mysql</code>를 호출한 경우:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Connection totalConnections: 1, activeConnections: 1, idleConnections: 0, threadsAwaitingConnection: 1</span><br><span class="line"># HTTP 응답 Response code: 200; Time: 1112ms (1 s 112 ms); Content length: 64 bytes (64 B)</span><br></pre></td></tr></table></figure></li></ol><p>테스트 결과, <code>/api/composite</code> 호출 이후 <code>getMySql</code> 요청은 대기 상태에 놓이며, MySQL 조회 작업이 완료되어 커넥션이 반환된 이후에 처리되는 것을 확인할 수 있었습니다. 이는 Hikari Connection Pool이 동기적이며, 사용 중인 커넥션이 반환될 때까지 대기 상태에 놓이는 블로킹 방식으로 동작하기 때문입니다.</p><h4 id="동작-흐름">동작 흐름</h4><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/refs/heads/master/redis/docs/lettuce-002.png" alt=""></p><p>Hikari Connection Pool의 동작 방식은 아래와 같습니다.</p><ol><li><strong><code>getComposite</code> 호출</strong>: <code>Service</code>는 MySQL A 조회를 요청하고, 사용 가능한 idle 커넥션을 가져옵니다. 이 요청은 2,500ms가 소요되며, 해당 커넥션은 점유된 상태로 유지됩니다.</li><li><strong><code>getMySql</code> 호출</strong>: <code>Controller</code>는 <code>Service</code>로 <code>getMySql</code> 호출을 보냅니다. 그러나 MySQL A 조회 요청이 아직 진행 중이므로 사용 가능한 커넥션이 없습니다. 이에 따라 요청은 <strong>threadsAwaitingConnection</strong> 상태로 대기하게 됩니다.</li><li><strong>MySQL A 응답 반환</strong>: MySQL A 조회 요청이 완료되면서 커넥션이 반환됩니다. 반환된 커넥션은 대기 중이던 <code>getMySql</code>의 MySQL B 조회 요청에서 다시 사용됩니다.</li><li><strong>MySQL B 조회 요청 및 응답</strong>: 반환된 커넥션을 사용해 MySQL B 조회 요청이 처리됩니다. B 조회는 지연 없이 완료되며, 응답이 반환됩니다.</li><li><strong>최종 응답 반환</strong>: <code>getComposite</code>와 <code>getMySql</code> 요청이 순차적으로 완료되며, 최종적으로 각각의 결과가 <code>Controller</code>로 반환됩니다.</li></ol><h4 id="블로킹-방식의-한계">블로킹 방식의 한계</h4><p>이 시나리오에서 Hikari Connection Pool의 블로킹 특성으로 인해 다음과 같은 한계가 발생합니다. MySQL A 조회 요청이 완료되기 전까지 커넥션이 반환되지 않아 <code>getMySql</code> 호출이 대기 상태에 놓이고, 동시 요청 수가 증가하면 <strong>threadsAwaitingConnection</strong> 상태가 늘어나면서 대기 시간이 길어질 가능성이 있습니다. 반면, Redis Lettuce 커넥션 풀은 이러한 상황에서 다르게 동작할 수 있습니다. Lettuce가 스레드를 블록시키는 방식으로 작동한다면 비슷한 지연 문제가 발생하지만, 논블로킹 방식이라면 MySQL의 지연과 관계없이 추가적인 Redis 요청에 빠르게 응답할 수 있습니다.</p><h3 id="시나리오-getComposite-호출-이후-getRedis-호출">시나리오: getComposite 호출 이후 getRedis 호출</h3><p>Lettuce 설정은 <code>max-active=1</code>, <code>max-idle=1</code>, <code>min-idle=1</code>로 구성되어 있으며, <code>getComposite</code> 호출 시 사용 가능한 단 하나의 커넥션을 사용하여 작업이 진행됩니다. 이번 테스트의 목적은 <strong><code>/api/composite</code> 호출 이후 <code>getRedis</code> 호출의 응답 속도를 확인</strong>하는 것입니다. 만약 Lettuce가 블록되는 방식으로 동작한다면 <code>getComposite</code> 호출 중 Redis 조회 요청으로 점유된 커넥션이 MySQL 작업이 끝날 때까지 반환되지 않아 <code>getRedis</code> 요청은 대기 상태에 놓이고 응답 시간이 지연될 것입니다. 반대로 Lettuce가 비동기적이며 블로킹되지 않는 방식으로 동작한다면 <code>getComposite</code> 호출 중에도 커넥션이 Redis 요청 응답 후 즉시 반환되므로, <code>getRedis</code> 요청이 지연 없이 처리될 것입니다.</p><h4 id="테스트-결과-2">테스트 결과</h4><ol><li><code>/api/composite</code> 호출 이후 바로 <code>/api/redis</code>를 호출한 경우:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response code: 200; Time: 8ms (8 ms); Content length: 56 bytes (56 B)</span><br></pre></td></tr></table></figure></li><li><code>/api/redis</code> 단독 호출 시:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response code: 200; Time: 6ms (6 ms); Content length: 56 bytes (56 B)</span><br></pre></td></tr></table></figure></li></ol><p>테스트 결과, <code>/api/composite</code> 호출 중에도 <code>/api/redis</code> 요청은 지연 없이 빠르게 응답하는 것을 확인할 수 있었습니다. 이는 Lettuce가 비동기적으로 동작하며, 스레드를 블록하지 않음을 시사합니다.</p><h4 id="동작-흐름-2">동작 흐름</h4><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/refs/heads/master/redis/docs/lettuce-003.png" alt=""></p><ol><li><strong><code>getComposite</code> 호출</strong>: <code>Controller</code>가 <code>getComposite</code> 요청을 보냅니다. <code>Service</code>는 먼저 Redis 조회를 수행하며, 이 작업은 10ms 만에 완료되고 커넥션은 즉시 반환됩니다. 이후 MySQL 조회를 시작하며, MySQL 조회 작업은 2,500ms가 소요됩니다.</li><li><strong><code>getRedis</code> 호출</strong>: MySQL 조회가 진행 중인 상태에서 <code>Controller</code>가 <code>getRedis</code> 요청을 보냅니다. Redis는 MySQL 작업과는 독립적으로 동작하므로, Redis 조회 요청은 지연 없이 처리됩니다. 반환된 Redis 커넥션이 즉시 재사용되어 <code>getRedis</code> 요청이 빠르게 완료됩니다.</li><li><strong><code>getComposite</code> 응답 반환</strong>: MySQL 작업이 완료되면 <code>getComposite</code> 응답이 반환됩니다.</li><li><strong><code>getRedis</code> 응답 반환</strong>: hRedis 조회 요청이 완료된 후 응답이 반환됩니다. Redis 작업이 MySQL 작업의 지연과 상관없이 즉시 처리되었기 때문에 빠른 응답 시간을 유지합니다.</li></ol><h4 id="논블로킹의-장점">논블로킹의 장점</h4><p>테스트 결과를 통해 Lettuce가 비동기적이고 논블로킹 방식으로 동작한다는 것을 확인할 수 있었습니다. Redis 조회는 10ms 만에 응답을 완료하고 커넥션을 즉시 반환하므로, MySQL 작업이 진행 중이라도 Redis 커넥션이 점유된 상태로 남아있지 않습니다. 결과적으로, 추가적인 Redis 요청(<code>getRedis</code>)은 MySQL의 작업 지연과 관계없이 빠르게 처리됩니다.</p><p>이는 MySQL의 Hikari Connection Pool이 스레드를 블록하여 대기 시간을 유발하는 방식과 대비됩니다. Hikari에서는 커넥션이 반환될 때까지 다른 요청이 대기 상태에 놓이지만, Lettuce는 커넥션 반환이 즉시 이루어져 이러한 지연 없이 요청을 처리할 수 있습니다.</p><p>Redis의 비동기 I/O와 Lettuce의 설계가 결합되어 높은 동시성 환경에서도 안정적인 성능을 유지할 수 있음을 보여주는 사례라 할 수 있습니다. 이러한 특성은 Redis와 같이 빠른 응답성을 요구하는 환경에서 Lettuce가 얼마나 효율적인지를 잘 보여줍니다.</p><h3 id="Hikari와-Lettuce의-차이점-정리">Hikari와 Lettuce의 차이점 정리</h3><ol><li><strong>동작 방식의 차이</strong>:<ul><li>Hikari Connection Pool은 <strong>전통적인 동기식 동작</strong>을 기반으로 하며, 스레드 블로킹이 발생합니다. MySQL 같은 관계형 데이터베이스와 함께 사용하는 경우, 데이터 조회 시 커넥션이 점유된 상태로 유지되므로 다른 요청들은 사용 가능한 커넥션이 없어 대기하게 됩니다.</li><li>Redis Lettuce Connection Pool은 <strong>비동기 및 넌블로킹 I/O</strong>를 지원하여, Redis 서버에서 응답을 받은 후에도 바로 커넥션을 반환할 수 있습니다. 이를 통해 <strong>커넥션 점유 시간이 짧아져</strong> Redis에 대한 다른 요청들도 빠르게 처리될 수 있습니다.</li></ul></li><li><strong>커넥션 풀의 활용도</strong>:<ul><li>Hikari Connection Pool은 <strong>threadsAwaitingConnection</strong>을 관리하며, 커넥션 풀이 모두 사용 중일 경우 새 요청들은 대기하게 됩니다. 따라서 <strong>커넥션 풀 크기 설정</strong>이 성능에 큰 영향을 미칩니다.</li><li>Redis Lettuce Connection Pool은 커넥션을 빠르게 반환하기 때문에, <strong>커넥션 풀 크기를 크게 설정하지 않아도 효율적으로 동작</strong>할 수 있습니다. Redis의 비동기 처리 덕분에 서버의 응답이 빠르다면, 적은 수의 커넥션으로도 많은 요청을 처리할 수 있습니다.</li></ul></li><li><strong>특정 상황에서의 블로킹 차이</strong>:<ul><li>Hikari Connection Pool은 요청이 지연되면, 다른 커넥션이 점유되지 않는 한 <strong>대기 스레드</strong>가 계속 늘어날 수 있습니다. 이는 높은 동시성에서 성능 저하를 야기할 수 있습니다.</li><li>Redis Lettuce는 비동기적이며, Redis 서버로부터 응답을 받은 후에는 <strong>커넥션을 빠르게 반환</strong>하므로, <strong>서버 응답 시간</strong>이 Lettuce의 성능에 직접적인 영향을 미칩니다. 즉, Redis 명령어가 복잡하고 시간이 오래 걸리면(예: <code>keys *</code> 사용), 그 시간 동안 다른 요청들이 블록될 수 있습니다.</li></ul></li><li><strong>블로킹/넌블로킹의 영향</strong>:<ul><li>Hikari의 경우 <strong>스레드 블로킹</strong>이 빈번히 발생하는 반면, Lettuce는 넌블로킹으로 <strong>추가적인 스레드 리소스를 사용하지 않고도</strong> 더 많은 요청을 처리할 수 있는 장점이 있습니다.</li><li>이는 특히 <strong>IO 작업이 많은 환경</strong>에서 Lettuce가 더 효율적으로 동작하도록 만듭니다. 반면, Hikari는 <strong>동기적 처리</strong>로 인해 CPU 자원을 더 많이 사용하게 되며, 이는 고비용의 대기 시간이 발생할 가능성을 증가시킵니다.</li></ul></li></ol><h2 id="Lettuce-Connection-Pool-설정과-의미">Lettuce Connection Pool 설정과 의미</h2><h3 id="Lettuce-Connection-Pool-Properties">Lettuce Connection Pool Properties</h3><p>Spring Data Redis에서는 <code>application.yml</code> 파일을 통해 Lettuce Connection Pool의 설정을 손쉽게 구성할 수 있습니다. 아래는 주요 프로퍼티와 그 설명입니다:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">        <span class="attr">lettuce:</span></span><br><span class="line">            <span class="attr">pool:</span></span><br><span class="line">                <span class="attr">max-active:</span> <span class="number">1</span></span><br><span class="line">                <span class="attr">max-idle:</span> <span class="number">1</span></span><br><span class="line">                <span class="attr">min-idle:</span> <span class="number">1</span></span><br><span class="line">                <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">                <span class="attr">max-wait:</span> <span class="string">1000ms</span></span><br><span class="line">                <span class="attr">time-between-eviction-runs:</span> <span class="string">1000ms</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>설정 항목</th><th>설명</th><th>기본 값</th></tr></thead><tbody><tr><td><code>max-active</code></td><td>Connection Pool에서 사용할 수 있는 최대 커넥션 수로, 동시 연결 수를 제한합니다.</td><td>8</td></tr><tr><td><code>max-idle</code></td><td>Connection Pool에서 유지할 수 있는 최대 유휴 커넥션 수입니다. 이 값을 초과하는 유휴 커넥션은 폐기됩니다.</td><td>8</td></tr><tr><td><code>min-idle</code></td><td>Connection Pool에서 유지할 최소 유휴 커넥션 수입니다. 유휴 커넥션이 부족하면 새 커넥션을 생성합니다.</td><td>0</td></tr><tr><td><code>enabled</code></td><td>Lettuce Connection Pool 사용 여부를 설정합니다. <code>true</code>로 설정 시 Pool이 활성화됩니다.</td><td><code>false</code></td></tr><tr><td><code>max-wait</code></td><td>커넥션이 사용 중일 때 새로운 요청이 대기할 수 있는 최대 시간입니다. 설정된 시간이 초과되면 예외가 발생합니다.</td><td>-1 (무제한 대기)</td></tr><tr><td><code>time-between-eviction-runs</code></td><td>유휴 커넥션 검사 및 제거 작업의 주기를 설정합니다. (단위: 밀리초)</td><td>-1 (검사하지 않음)</td></tr></tbody></table><p>이러한 설정은 Lettuce Connection Pool의 동작을 세부적으로 제어하며, 애플리케이션의 요구 사항에 맞게 성능과 리소스 사용량을 조정할 수 있습니다. 특히, <code>max-active</code>, <code>min-idle</code>, <code>max-wait</code>와 같은 설정은 TPS가 높은 환경이나 트래픽 변동이 큰 상황에서 애플리케이션의 안정성을 보장하는 데 중요한 역할을 합니다.</p><h3 id="Lettuce-Connection-Pool의-개수가-갖는-의미">Lettuce Connection Pool의 개수가 갖는 의미</h3><p>Redis Lettuce Connection은 비동기 방식으로 동작하며, 요청을 처리한 후 커넥션을 즉시 반환하는 구조를 가지고 있습니다. 이는 적은 수의 커넥션으로도 높은 효율을 발휘할 수 있다는 점에서 큰 장점입니다. 하지만, Hikari와 같은 전통적인 동기 커넥션 풀처럼 미리 커넥션을 확보하여 동시성을 처리하는 방식은 아니기 때문에, &quot;Lettuce Connection Pool의 개수가 많다고 해서 이점이 있을까?&quot;라는 의문을 가질 수 있습니다.</p><p>사실, Lettuce Connection Pool의 개수는 TPS가 높아지고 Redis 서버의 응답이 느려질 때 중요한 의미를 가집니다. 다음은 Lettuce Connection Pool의 개수가 많을 때 가지는 이점을 설명합니다.</p><ol><li><p><strong>Redis 응답 지연 시 동시 요청 처리 가능</strong>:<br>Redis 서버가 응답을 지연하는 경우, 요청이 커넥션을 점유하는 시간이 길어집니다. 이때 Connection Pool의 크기가 작다면 모든 커넥션이 점유된 상태에서 새로운 요청이 대기 상태로 전환될 가능성이 높습니다. 하지만 Connection Pool 크기가 충분히 크다면, 지연된 요청과 별개로 다른 요청을 처리할 여유를 확보할 수 있습니다. 이는 TPS가 몰리는 상황에서도 전체 시스템의 성능 저하를 방지합니다.</p></li><li><p><strong>Burst 트래픽에서의 안정성 확보</strong>:<br>트래픽이 순간적으로 폭증하는 경우, Pool 크기가 충분히 크면 새로운 요청을 대기시키지 않고 처리할 수 있습니다. 이는 특히 Redis 응답 시간이 일관되지 않은 상황에서 더욱 중요한데, Pool 크기가 충분하지 않으면 요청 처리 시간이 예측 불가능하게 증가할 수 있습니다.</p></li><li><p><strong>멀티 인스턴스 활용 가능성</strong>:<br>Redis는 싱글 스레드로 동작하지만, 애플리케이션 인스턴스가 여러 개일 경우 각 인스턴스에서 동시에 Redis에 접근합니다. Pool 크기가 충분히 크다면, 여러 인스턴스가 Redis와 병렬로 통신하면서도 효율적으로 커넥션을 재사용할 수 있습니다.</p></li><li><p><strong>비동기 요청 처리 속도 향상</strong>:<br>Lettuce는 비동기적으로 여러 요청을 처리할 수 있지만, Pool 크기가 제한적이라면 커넥션 재사용의 병목이 발생할 수 있습니다. Pool 크기를 늘리면 이러한 병목을 완화하고, Redis 서버의 응답 속도에 따라 더 많은 요청을 처리할 수 있습니다.</p></li><li><p><strong>장시간 실행되는 명령어의 영향 완화</strong>:<br>일부 Redis 명령어(예: <code>zrange</code>, <code>keys</code>)는 실행 시간이 길어질 수 있습니다. Pool 크기가 작다면 이런 명령이 다른 요청 처리에 직접적인 영향을 미치지만, 충분한 Pool 크기는 이런 상황에서도 다른 요청을 지연 없이 처리할 수 있도록 합니다.</p></li></ol><p>Lettuce Connection Pool의 개수는 TPS와 Redis 서버의 응답 지연이 증가하는 상황에서 중요한 역할을 합니다. 비록 Lettuce가 비동기적이고 효율적인 구조를 가졌더라도, Pool 크기를 적절히 설정하지 않으면 요청 대기가 발생할 수 있습니다.</p><p>따라서 Lettuce Connection Pool의 개수는 단순히 많은 요청을 처리하기 위한 것이 아니라, Redis 서버 응답 시간의 변동성, Burst 트래픽, 그리고 장시간 실행되는 명령어 처리와 같은 다양한 상황에 대비하기 위한 안정성을 제공한다고 볼 수 있습니다. Connection Pool 크기를 TPS와 트래픽 패턴에 맞게 조정하는 것이 Lettuce의 효율성을 극대화하는 핵심 전략입니다.</p><h2 id="결론">결론</h2><p>논블로킹 방식이 항상 절대적으로 좋은 것은 아닙니다. Redis Lettuce와 Hikari Connection Pool은 서로 다른 특성과 장점을 가지고 있으며, 각 환경에 따라 적절히 선택해야 합니다.</p><p>Lettuce의 경우, Redis 서버로부터 응답을 받으면 커넥션을 즉시 반환하고 다음 요청을 처리할 준비를 합니다. 이는 커넥션 점유 시간이 짧아져 더 작은 풀 크기로 효율적인 요청 처리가 가능하다는 큰 장점이 있습니다. 하지만 Redis 서버 자체가 응답을 지연한다면, 다른 요청이 대기 상태에 놓이게 되어 성능 저하로 이어질 수 있습니다. 이러한 상황에서는 Lettuce의 비동기적 특성이 한계를 보일 수 있습니다.</p><p>반면, Hikari Connection Pool은 유휴 커넥션이 있는 경우 한 요청이 오래 걸리더라도 다른 커넥션을 사용하여 추가적인 요청을 처리할 수 있습니다. 이는 Redis와 같은 싱글 스레드 구조가 아닌, 다중 커넥션을 사용하는 데이터베이스 환경에 잘 맞는 전략입니다. 그러나 Hikari는 요청 중 커넥션이 블록되는 방식으로 동작하기 때문에, 풀 크기가 제한적이거나 동시 요청이 많아지면 대기 시간이 길어질 가능성이 있습니다.</p><p>이러한 차이는 Redis가 싱글 스레드로 모든 요청을 처리하도록 설계된 서버라는 점에서 기인합니다. Lettuce는 Redis 서버의 메커니즘과 잘 맞는 전략을 선택하여 구현되었으며, 비동기와 논블로킹을 통해 Redis의 성능 특성을 최대한 활용합니다. 이는 Hikari Connection Pool과는 다른 접근 방식으로, Redis 서버와의 높은 호환성을 유지하며 효율적인 자원 관리를 가능하게 합니다.</p><p>소프트웨어 개발에서는 항상 트레이드오프가 존재합니다. 특정 기술이 모든 상황에서 우월하다고 말할 수는 없습니다. Lettuce와 Hikari의 차이는 각기 다른 환경에 적합한 도구를 제공하며, 사용자는 자신의 애플리케이션 요구사항에 따라 적합한 전략을 선택해야 합니다. 결국, 어떤 도구가 &quot;좋다&quot;라고 단정짓기보다는, 각 기술의 장단점을 이해하고 상황에 맞게 활용하는 것이 중요합니다.</p>]]></content:encoded>
      
      
      
      <category domain="https://cheese10yun.github.io/tags/Redis/">Redis</category>
      
      
      <comments>https://cheese10yun.github.io/redis-lettuce-connection/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Mermaid 코드로 그리는 다이어그램</title>
      <link>https://cheese10yun.github.io/mermaid/</link>
      <guid>https://cheese10yun.github.io/mermaid/</guid>
      <pubDate>Sat, 16 Nov 2024 06:17:10 GMT</pubDate>
      
      <description>Mermaid는 간단한 텍스트 형식의 코드를 통해 다양한 다이어그램을 생성할 수 있는 강력한 도구입니다. 특히, 개발자들에게 큰 이점을 제공하며, 프로젝트 문서화 작업에서 필수적인 역할을 할 수 있습니다.</description>
      
      
      
      <content:encoded><![CDATA[<p>Mermaid는 간단한 텍스트 형식의 코드를 통해 다양한 다이어그램을 생성할 수 있는 강력한 도구입니다. 특히, 개발자들에게 큰 이점을 제공하며, 프로젝트 문서화 작업에서 필수적인 역할을 할 수 있습니다. 이번 글에서는 Mermaid가 어떤 이점을 가지고 있는지, 그리고 이를 활용하여 프로젝트 문서화를 어떻게 개선할 수 있는지에 대해 설명드리겠습니다.</p><h2 id="코드-베이스-관리의-큰-이점">코드 베이스 관리의 큰 이점</h2><p>Mermaid의 가장 큰 이점 중 하나는 <strong>코드 베이스 관리의 용이성</strong>입니다. 다이어그램을 코드로 관리하면 다음과 같은 장점이 있습니다:</p><ul><li><strong>유지보수성</strong>: 다이어그램이 코드로 작성되어 있기 때문에, 코드와 함께 버전 관리 시스템에서 추적할 수 있어 변경 이력을 쉽게 관리할 수 있습니다. 새로운 기능 추가나 수정이 있을 때 다이어그램을 업데이트하는 것도 매우 간단합니다.</li><li><strong>수정의 용이성</strong>: GUI로 그려진 다이어그램은 수정이 어렵고 시간이 많이 걸리지만, Mermaid는 텍스트 기반이므로 코드를 수정하는 것만으로 빠르게 다이어그램을 변경할 수 있습니다.</li><li><strong>검색의 용이성</strong>: 코드로 작성된 다이어그램은 텍스트 파일이기 때문에 프로젝트 내에서 검색이 가능하여, 유지보수 작업을 더 쉽게 할 수 있습니다.</li></ul><h2 id="Markdown에서-직접-사용-가능">Markdown에서 직접 사용 가능</h2><p>Mermaid는 <strong>Markdown 프리뷰 플러그인</strong>을 제공하기 때문에, Markdown 문서 내에서 다이어그램을 바로 작성하고 확인할 수 있습니다. 이는 프로젝트의 <strong>README 파일</strong>에 다이어그램을 포함시켜 팀원들이 쉽게 접근할 수 있도록 만들어줍니다. 문서화를 프로젝트의 중심에서 관리할 수 있어 <strong>프로젝트의 가독성과 접근성을 크게 향상</strong>시킬 수 있습니다.</p><h2 id="다양한-다이어그램-형식-제공">다양한 다이어그램 형식 제공</h2><p>Mermaid는 다양한 다이어그램 형식을 제공합니다. 몇 가지 주요 다이어그램 유형은 다음과 같습니다:</p><h3 id="Flowchart">Flowchart</h3><p>프로세스 흐름을 나타내는 데 적합합니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/refs/heads/master/redis/docs/Flowchart.png" alt=""></p><p>Mermaid 코드 (Flowchart):</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    A[Christmas] --&gt;|Get money| B(Go shopping)</span><br><span class="line">    B --&gt; C&#123;Let me think&#125;</span><br><span class="line">    C --&gt;|One| D[Laptop]</span><br><span class="line">    C --&gt;|Two| E[iPhone]</span><br><span class="line">    C --&gt;|Three| F[fa:fa-car Car]</span><br></pre></td></tr></table></figure><h3 id="Class-Diagram">Class Diagram</h3><p>객체지향 프로그램의 클래스 구조를 표현할 수 있습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/refs/heads/master/redis/docs/diagram.png" alt=""></p><p>Mermaid 코드 (Class Diagram):</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    Animal &lt;|-- Duck</span><br><span class="line">    Animal &lt;|-- Fish</span><br><span class="line">    Animal &lt;|-- Zebra</span><br><span class="line">    Animal : +int age</span><br><span class="line">    Animal : +String gender</span><br><span class="line">    Animal: +isMammal()</span><br><span class="line">    Animal: +mate()</span><br><span class="line">    class Duck&#123;</span><br><span class="line">      +String beakColor</span><br><span class="line">      +swim()</span><br><span class="line">      +quack()</span><br><span class="line">    &#125;</span><br><span class="line">    class Fish&#123;</span><br><span class="line">      -int sizeInFeet</span><br><span class="line">      -canEat()</span><br><span class="line">    &#125;</span><br><span class="line">    class Zebra&#123;</span><br><span class="line">      +bool is_wild</span><br><span class="line">      +run()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Sequence-Diagram-Zenuml">Sequence Diagram (Zenuml)</h3><p>Zenuml을 사용하여 시퀀스 다이어그램을 쉽게 표현할 수 있습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/refs/heads/master/redis/docs/zenuml.png" alt=""></p><p>Zenuml 코드 (Sequence Diagram):</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">title Order Service</span><br><span class="line">@Actor Client #FFEBE6</span><br><span class="line">@Boundary OrderController #0747A6</span><br><span class="line">@EC2 &lt;&lt;BFF&gt;&gt; OrderService #E3FCEF</span><br><span class="line">group BusinessService &#123;</span><br><span class="line">  @Lambda PurchaseService</span><br><span class="line">  @AzureFunction InvoiceService</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Starter(Client)</span><br><span class="line">// `POST /orders`</span><br><span class="line">OrderController.post(payload) &#123;</span><br><span class="line">  OrderService.create(payload) &#123;</span><br><span class="line">    order = new Order(payload)</span><br><span class="line">    if(order != null) &#123;</span><br><span class="line">      par &#123;</span><br><span class="line">        PurchaseService.createPO(order)</span><br><span class="line">        InvoiceService.createInvoice(order)      </span><br><span class="line">      &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="XYChart">XYChart</h3><p>XYChart를 사용하여 매출 데이터를 시각화할 수 있습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/refs/heads/master/redis/docs/XYChart.png" alt=""></p><p>XYChart 코드:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xychart-beta</span><br><span class="line">title &quot;Sales Revenue&quot;</span><br><span class="line">x-axis [jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec]</span><br><span class="line">y-axis &quot;Revenue (in $)&quot; 4000 --&gt; 11000</span><br><span class="line">bar [5000, 6000, 7500, 8200, 9500, 10500, 11000, 10200, 9200, 8500, 7000, 6000]</span><br><span class="line">line [5000, 6000, 7500, 8200, 9500, 10500, 11000, 10200, 9200, 8500, 7000, 6000]</span><br></pre></td></tr></table></figure><h3 id="Block-Diagram">Block Diagram</h3><p>여러 블록을 사용하여 시스템의 구성 요소를 표현할 수 있습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/refs/heads/master/redis/docs/Block%20Diagram.png" alt=""></p><p>Block Diagram 코드:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">block-beta</span><br><span class="line">    columns 3</span><br><span class="line">    doc&gt;&quot;Document&quot;]:3</span><br><span class="line">    space down1&lt;[&quot; &quot;](down) space</span><br><span class="line">    </span><br><span class="line">    block:e:3</span><br><span class="line">          l[&quot;left&quot;]</span><br><span class="line">          m(&quot;A wide one in the middle&quot;)</span><br><span class="line">          r[&quot;right&quot;]</span><br><span class="line">    end</span><br><span class="line">    space down2&lt;[&quot; &quot;](down) space</span><br><span class="line">    db[(&quot;DB&quot;)]:3</span><br><span class="line">    space:3</span><br><span class="line">    D space C</span><br><span class="line">    db --&gt; D</span><br><span class="line">    C --&gt; db</span><br><span class="line">    D --&gt; C</span><br><span class="line">    style m fill:#d6d,stroke:#333,stroke-width:4px</span><br></pre></td></tr></table></figure><p>이 외에도 <strong>시퀀스 다이어그램</strong>, <strong>상태도</strong>, <strong>피에조 차트</strong> 등 다양한 다이어그램을 제공하여 개발뿐 아니라 프로젝트 관리, 사용자 경험 디자인까지 다양한 분야에서 활용할 수 있습니다.</p><h2 id="Mermaid-Live-실시간-다이어그램-작성">Mermaid Live: 실시간 다이어그램 작성</h2><p>Mermaid는 <a href="https://mermaid.live/edit"><strong>Mermaid Live Editor</strong></a>라는 웹 기반 도구를 제공하여 실시간으로 다이어그램을 작성하고 미리 볼 수 있습니다. 이 도구를 사용하면 빠르게 다이어그램을 시각화할 수 있으며, 다양한 <strong>템플릿</strong>도 제공되어 누구나 쉽게 시작할 수 있습니다. 복잡한 다이어그램도 빠르게 그릴 수 있기 때문에 협업 시에 유용하게 활용될 수 있습니다.</p><h2 id="마무리">마무리</h2><p>Mermaid는 코드 기반의 다이어그램 도구로서, 유지보수성, 수정의 용이성, 그리고 프로젝트 문서화의 접근성을 크게 향상시킵니다. Markdown과 통합하여 프로젝트 문서에 쉽게 다이어그램을 포함시킬 수 있으며, 다양한 다이어그램 형식을 통해 개발 과정에서 발생하는 다양한 시각적 요구를 충족시킬 수 있습니다. Mermaid Live를 통해 실시간으로 다이어그램을 작성하고 협업할 수 있는 기능도 매우 유용합니다.</p><p>프로젝트 문서화 작업에서 Mermaid를 활용해 보세요. 코드와 문서의 통합을 통해 더 나은 협업과 유지보수를 경험할 수 있을 것입니다.</p><h2 id="출처">출처</h2><ul><li><a href="https://mermaid.live/">Mermaid Live Editor</a></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://cheese10yun.github.io/tags/Tool/">Tool</category>
      
      
      <comments>https://cheese10yun.github.io/mermaid/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Kotlin 객체 생성의 안전성과 유효성 강화하기</title>
      <link>https://cheese10yun.github.io/kotlin-pattern-2/</link>
      <guid>https://cheese10yun.github.io/kotlin-pattern-2/</guid>
      <pubDate>Fri, 01 Nov 2024 15:00:00 GMT</pubDate>
      
      <description>코틀린에서 객체 생성과 값 타입 관리의 안전성을 강화하는 다양한 방법에 대해 알아보겠습니다. 이번 포스팅에서는 User라는 엔티티 클래스를 예로 들어 생성자 제약 사항을 안전하게 처리하는 방법과, value class를 활용해 값 타입을 효율적으로 관리하는 방법에 대해 설명하겠습니다.</description>
      
      
      
      <content:encoded><![CDATA[<p>코틀린에서 객체 생성과 값 타입 관리의 안전성을 강화하는 다양한 방법에 대해 알아보겠습니다. 이번 포스팅에서는 <code>User</code>라는 엔티티 클래스를 예로 들어 생성자 제약 사항을 안전하게 처리하는 방법과, <code>value class</code>를 활용해 값 타입을 효율적으로 관리하는 방법에 대해 설명하겠습니다.</p><h2 id="기존-생성자-코드의-문제점">기존 생성자 코드의 문제점</h2><p>아래는 간단한 <code>User</code> 클래스입니다. 이 클래스는 JPA 엔티티로 정의되어 있으며, 데이터베이스와 매핑되는 사용자 정보를 나타냅니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity(name = <span class="string">&quot;user&quot;</span>)</span></span><br><span class="line"><span class="meta">@Table(name = <span class="string">&quot;user&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">var</span> name: String,</span><br><span class="line">    <span class="keyword">val</span> email: String,</span><br><span class="line">    <span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line">    <span class="keyword">var</span> stats: UserStats</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>위 코드를 보면 객체 생성 시 다음과 같은 문제가 발생할 수 있습니다:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 잘못된 객체 생성 예시</span></span><br><span class="line"><span class="keyword">val</span> user = User(</span><br><span class="line">    id = <span class="number">1L</span>,  <span class="comment">// 외부에서 설정하면 안 됨</span></span><br><span class="line">    name = <span class="string">&quot;  John Doe  &quot;</span>,  <span class="comment">// 공백 제거 불가</span></span><br><span class="line">    email = <span class="string">&quot;  john.doe@example.com  &quot;</span>,  <span class="comment">// 공백 제거 불가</span></span><br><span class="line">    stats = UserStats.ACTIVE  <span class="comment">// 생성 시 초기값은 무조건 NORMAL이어야 함</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li><code>id</code>는 데이터베이스에서 자동으로 생성되기 때문에, 외부에서 객체 생성 시 값을 전달하면 안 됩니다.</li><li><code>stats</code> 필드는 초기 생성 시 무조건 <code>UserStats.NORMAL</code>이어야 하므로, 외부에서 제어권을 가지면 안 됩니다.</li><li><code>name</code>과 <code>email</code> 필드는 공백을 제거해야 하는데, 현재 생성자로는 이러한 처리가 어렵습니다.</li><li>그 외에도 객체 생성 시 내부적으로 유효성 검사를 하는 것이 제한적입니다.</li></ol><p>이러한 문제들을 해결하기 위해, 우리는 안전한 객체 생성 방식을 도입할 수 있습니다.</p><h4 id="Companion-Object를-활용한-객체-생성-안전성-강화">Companion Object를 활용한 객체 생성 안전성 강화</h4><p>이 문제를 해결하기 위해, <code>companion object</code>와 <code>operator fun invoke</code>를 활용한 객체 생성 방식을 제안합니다. 아래는 수정된 코드입니다:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(</span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">var</span> name: String,</span><br><span class="line">    <span class="keyword">val</span> email: String,</span><br><span class="line">    <span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line">    <span class="keyword">var</span> stats: UserStats</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            email: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>: User &#123;</span><br><span class="line">            <span class="comment">// 유효성 검사 로직 추가</span></span><br><span class="line">            require(name.isNotBlank()) &#123; <span class="string">&quot;Name must not be blank&quot;</span> &#125;</span><br><span class="line">            require(email.isNotBlank()) &#123; <span class="string">&quot;Email must not be blank&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> User(</span><br><span class="line">                name = name.trim(),</span><br><span class="line">                email = email.trim(),</span><br><span class="line">                id = <span class="literal">null</span>,</span><br><span class="line">                stats = UserStats.NORMAL</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 외부에서 객체를 생성할 때는 다음과 같이 사용할 수 있습니다:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 안전한 객체 생성 예시</span></span><br><span class="line"><span class="keyword">val</span> user = User(</span><br><span class="line">    name = <span class="string">&quot;  John Doe  &quot;</span>,</span><br><span class="line">    email = <span class="string">&quot;  john.doe@example.com  &quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>위 코드는 기존의 생성자 호출 방식과 동일하게 사용할 수 있지만, 내부적으로는 안전한 로직을 적용하여 객체를 생성하도록 유도합니다. 이를 통해 불필요한 오류를 방지하고 객체 생성 과정을 간소화할 수 있습니다.</p><h3 id="주요-개선-사항">주요 개선 사항</h3><ol><li><strong>기본 생성자 막기</strong>: <code>private constructor</code>를 사용해 기본 생성자를 외부에서 호출하지 못하게 막았습니다. 이를 통해 객체 생성을 <code>companion object</code> 내부의 로직으로만 유도할 수 있게 되었습니다.</li><li><strong>invoke 연산자 활용</strong>: <code>companion object</code>에 <code>operator fun invoke</code>를 정의하여 객체 생성 시 사용자가 보다 명확한 API를 사용할 수 있게 했습니다. 이는 기존의 생성자 호출 방식과 동일하게 사용할 수 있으면서도 <code>name</code>과 <code>email</code>의 앞뒤 공백을 자동으로 제거하고, <code>stats</code> 필드는 무조건 <code>UserStats.NORMAL</code>로 설정하게 되었습니다.</li><li><strong>안전한 필드 초기화</strong>: <code>id</code>와 같이 외부에서 설정되면 안 되는 필드는 생성자에서 제외하여, 개발자가 실수로 이를 설정하는 것을 방지했습니다.</li></ol><h2 id="Value-Class를-활용한-값-타입-관리">Value Class를 활용한 값 타입 관리</h2><p>또한, 이메일과 같은 값 타입을 별도로 관리하기 위해 코틀린의 <code>value class</code>를 활용하는 것도 좋은 방법입니다. 아래는 <code>Email</code>이라는 값 클래스를 정의하고 사용하는 예시입니다:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmInline</span></span><br><span class="line">value <span class="keyword">class</span> <span class="title class_">Email</span>(<span class="keyword">val</span> value: String) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        require(value.isNotBlank()) &#123; <span class="string">&quot;Email must not be blank&quot;</span> &#125;</span><br><span class="line">        require(value.contains(<span class="string">&quot;@&quot;</span>)) &#123; <span class="string">&quot;Email must contain &#x27;@&#x27;&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Email-Value-Class-적용">Email Value Class 적용</h3><p>위에서 정의한 <code>Email</code> 클래스를 <code>User</code> 클래스와 <code>Order</code> 클래스에 적용해보겠습니다:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(</span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">var</span> name: String,</span><br><span class="line">    <span class="keyword">val</span> email: Email,</span><br><span class="line">    <span class="keyword">var</span> stats: UserStats</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            email: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>: User &#123;</span><br><span class="line">            <span class="comment">// 유효성 검사 로직 추가</span></span><br><span class="line">            require(name.isNotBlank()) &#123; <span class="string">&quot;Name must not be blank&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> User(</span><br><span class="line">                name = name.trim(),</span><br><span class="line">                email = Email(email),</span><br><span class="line">                id = <span class="literal">null</span>,</span><br><span class="line">                stats = UserStats.NORMAL</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order 클래스 정의</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(</span><br><span class="line">    <span class="keyword">var</span> id: <span class="built_in">Long</span>? = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">val</span> email: Email,</span><br><span class="line">    <span class="keyword">var</span> amount: <span class="built_in">Double</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            email: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            amount: <span class="type">Double</span></span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span>: Order &#123;</span><br><span class="line">            <span class="comment">// 유효성 검사 로직 추가</span></span><br><span class="line">            require(amount &gt; <span class="number">0</span>) &#123; <span class="string">&quot;Amount must be greater than zero&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Order(</span><br><span class="line">                email = Email(email),</span><br><span class="line">                id = <span class="literal">null</span>,</span><br><span class="line">                amount = amount</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Value-Class를-통한-객체-관리의-이점">Value Class를 통한 객체 관리의 이점</h3><ol><li><strong>명확한 타입 정의</strong>: <code>Email</code>이라는 값 클래스를 사용함으로써, 이메일 주소를 단순히 문자열로 다루는 대신 명확한 타입으로 관리할 수 있습니다. 이를 통해 이메일 값이 기대하는 형태로만 사용되도록 강제할 수 있습니다.</li><li><strong>유효성 검사 통합</strong>: 이메일과 관련된 유효성 검사 로직을 <code>Email</code> 클래스 내부에 정의함으로써, 이메일이 생성되는 모든 곳에서 일관된 유효성 검사를 적용할 수 있습니다. 이를 통해 코드 중복을 줄이고 유지보수성을 높일 수 있습니다.</li><li><strong>가독성 향상</strong>: 이메일과 같은 값 타입을 별도로 정의함으로써, 코드의 가독성을 높이고, 객체의 의미를 보다 명확하게 전달할 수 있습니다. 이를 통해 코드가 더 직관적이며 이해하기 쉬워집니다.</li><li><strong>재사용성</strong>: <code>Email</code> 클래스는 <code>User</code> 클래스뿐만 아니라, 예를 들어 <code>Order</code>와 같은 다른 도메인 객체에서도 재사용할 수 있습니다. 이를 통해 일관된 이메일 관리와 유효성 검사를 보장하며, 코드 중복을 최소화할 수 있습니다. 이렇게 공통적으로 사용되는 값 타입을 재사용함으로써 코드의 유지보수성과 확장성을 크게 향상시킬 수 있습니다.</li></ol><h3 id="Value-Class-사용-시-주의-사항">Value Class 사용 시 주의 사항</h3><p><code>value class</code>로 감싼 타입은 JPA나 MongoDB와 같은 데이터베이스 접근 라이브러리를 사용할 때 자동으로 매핑되지 않기 때문에, 적절한 컨버터를 정의해줘야 합니다. 예를 들어, JPA에서는 <code>AttributeConverter</code>를 사용하여 <code>Email</code> 클래스를 문자열로 변환하고 다시 복원할 수 있는 컨버터를 구현해야 합니다.</p><h2 id="결론">결론</h2><p>코틀린에서 객체를 생성하는 다양한 방법이 있지만, 제약 사항이 많은 경우에는 <code>companion object</code>와 <code>invoke</code> 연산자를 활용하는 방식이 매우 유용합니다. 또한, 값 타입을 별도로 관리하기 위해 <code>value class</code>를 사용하는 것도 좋은 접근법입니다. 이를 통해 외부에서 설정하지 말아야 할 필드를 보호하고, 객체 생성 시 발생할 수 있는 오류를 줄일 수 있으며, 값 타입에 대한 유효성 검사와 관리도 일관되게 할 수 있습니다.</p><p>여러분도 코틀린을 사용할 때, 이러한 안전한 객체 생성 방식과 값 타입 관리를 적용해보세요! 필요에 따라 객체의 생성 로직을 유연하고 안전하게 제어할 수 있을 것입니다.</p>]]></content:encoded>
      
      
      
      <category domain="https://cheese10yun.github.io/tags/Kotlin/">Kotlin</category>
      
      
      <comments>https://cheese10yun.github.io/kotlin-pattern-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>HikariCP로 MySQL Connection Pool 최적화하기</title>
      <link>https://cheese10yun.github.io/mysql-connection-pool-timeout-1/</link>
      <guid>https://cheese10yun.github.io/mysql-connection-pool-timeout-1/</guid>
      <pubDate>Fri, 25 Oct 2024 15:00:00 GMT</pubDate>
      
      <description>Spring Boot는 기본적으로 HikariCP를 내장된 커넥션 풀로 지원하며, 이를 통해 데이터베이스 연결을 효율적으로 관리할 수 있습니다. 이번 포스팅에서는 Spring Boot 환경에서 HikariCP의 설정을 최적화하여 TPS 변화에 유연하게 대응하는 방법을 알아보겠습니다.</description>
      
      
      
      <content:encoded><![CDATA[<p>Spring Boot는 기본적으로 HikariCP를 내장된 커넥션 풀로 지원하며, 이를 통해 데이터베이스 연결을 효율적으로 관리할 수 있습니다. 이번 포스팅에서는 Spring Boot 환경에서 HikariCP의 설정을 최적화하여 TPS 변화에 유연하게 대응하는 방법을 알아보겠습니다.</p><h2 id="HikariCP-설정-예시">HikariCP 설정 예시</h2><p>Spring Boot에서 application.yml 또는 application.properties 파일을 통해 HikariCP 설정을 정의할 수 있습니다. 이번 예시에서는 다음과 같은 설정을 적용하였습니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">hikari:</span></span><br><span class="line">            <span class="attr">minimum-idle:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">maximum-pool-size:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">idle-timeout:</span> <span class="number">30000</span></span><br><span class="line">            <span class="attr">connection-timeout:</span> <span class="number">20000</span></span><br></pre></td></tr></table></figure><ul><li><strong>minimum-idle</strong>: 최소 유휴 커넥션 수입니다. 초기 설정 시 최소한의 커넥션(여기서는 10개)만 유지하여, TPS가 낮을 때 리소스를 절약할 수 있습니다.</li><li><strong>maximum-pool-size</strong>: 커넥션 풀의 최대 크기입니다. TPS가 높아질 때 최대 10개의 커넥션까지 생성하여 요청을 처리할 수 있게 설정합니다.</li><li><strong>idle-timeout</strong>: 지정된 시간(밀리초) 동안 유휴 상태인 커넥션이 있을 경우 풀에서 제거합니다. 트래픽이 낮아질 때 자동으로 풀 크기를 줄이는 데 기여합니다.</li><li><strong>connection-timeout</strong>: 커넥션을 얻기 위해 대기하는 최대 시간입니다. 이 시간 내에 커넥션을 확보하지 못하면 예외가 발생합니다.</li></ul><h2 id="TPS-변화에-따른-커넥션-풀의-동작">TPS 변화에 따른 커넥션 풀의 동작</h2><ol><li><strong>TPS가 낮은 경우</strong>: Spring Boot 애플리케이션이 유휴 상태이거나 트래픽이 적은 경우, HikariCP는 최소 커넥션(minimum-idle)만 유지하여 리소스 사용을 최적화합니다.</li><li><strong>TPS가 높아질 경우</strong>: TPS가 증가하여 커넥션이 필요한 상황이 되면, HikariCP는 최대 커넥션(maximum-pool-size)까지 확장하여 대량의 요청을 처리할 수 있게 합니다. 이를 통해 성능 저하 없이 안정적으로 트래픽을 소화할 수 있습니다.</li><li><strong>TPS가 다시 낮아지는 경우</strong>: TPS가 다시 낮아지면 HikariCP는 <code>idle-timeout</code>에 따라 불필요한 커넥션을 풀에서 제거하고, <code>minimum-idle</code>만 유지하여 리소스를 절약합니다.</li></ol><p>이 케이스는 MySQL Connection Pool에서 <code>minimum-idle</code>과 <code>maximum-pool-size</code>를 동일하게 설정한 상황에서, TPS가 200대에 도달할 때 발생하는 성능 문제를 다루고 있습니다. 그래프와 로그를 바탕으로 아래와 같이 분석할 수 있습니다.</p><h2 id="TPS가-높아지는-상황에서의-커넥션-풀-동작-분석">TPS가 높아지는 상황에서의 커넥션 풀 동작 분석</h2><p>Spring Boot 애플리케이션에서 TPS가 높아질 때, HikariCP의 커넥션 풀이 어떻게 반응하고 성능에 어떤 영향을 미치는지 살펴보겠습니다. 이 테스트는 <code>minimum-idle: 10</code>과 <code>maximum-pool-size: 10</code> 설정을 사용해, 커넥션 풀의 확장성과 한계점을 확인하는 데 중점을 두었습니다.</p><p>애플리케이션은 지속적으로 증가하는 사용자 요청을 처리하며, TPS가 증가함에 따라 커넥션 풀이 최대에 도달하는 시점에서 성능 지연과 요청 실패가 발생하는 과정을 시각적으로 분석했습니다.</p><h3 id="상황-설명">상황 설명</h3><p>다음 코드는 Spring Boot와 Kotlin 환경에서 설정된 컨트롤러와 서비스 로직입니다. 컨트롤러에서는 <code>SampleService</code>의 <code>getMember()</code> 메서드를 호출하며, 이 메서드는 1~100 사이의 랜덤 ID로 <code>Member</code> 엔티티를 PK를 기반으로 조회한 후, 1초의 지연 시간을 둔 뒤 커넥션 풀의 현재 상태를 로깅합니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SampleController</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> SampleService: SampleService</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(<span class="string">&quot;/api/v1/members&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sample</span><span class="params">()</span></span>: Member &#123;</span><br><span class="line">        <span class="comment">// 1 ~ 100 사이의 랜덤으로 member 조회</span></span><br><span class="line">        <span class="keyword">return</span> SampleService.getMember()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SampleService</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> dataSource: DataSource,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> memberRepository: MemberRepository</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> log = LoggerFactory.getLogger(javaClass)!!</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getMember</span><span class="params">()</span></span>: Member &#123;</span><br><span class="line">        <span class="keyword">val</span> findById = memberRepository.findById(Random.nextInt(<span class="number">1</span>, <span class="number">100</span>).toLong()).<span class="keyword">get</span>()</span><br><span class="line">        runBlocking &#123; delay(<span class="number">1000</span>) &#125;</span><br><span class="line">        <span class="keyword">val</span> targetDataSource = dataSource.unwrap(HikariDataSource::<span class="keyword">class</span>.java)</span><br><span class="line">        <span class="keyword">val</span> hikariDataSource = targetDataSource <span class="keyword">as</span> HikariDataSource</span><br><span class="line">        <span class="keyword">val</span> hikariPoolMXBean = hikariDataSource.hikariPoolMXBean</span><br><span class="line">        <span class="keyword">val</span> hikariConfigMXBean = hikariDataSource.hikariConfigMXBean</span><br><span class="line">        <span class="keyword">val</span> log =</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            totalConnections : <span class="subst">$&#123;hikariPoolMXBean.totalConnections&#125;</span></span></span><br><span class="line"><span class="string">            activeConnections : <span class="subst">$&#123;hikariPoolMXBean.activeConnections&#125;</span></span></span><br><span class="line"><span class="string">            idleConnections : <span class="subst">$&#123;hikariPoolMXBean.idleConnections&#125;</span></span></span><br><span class="line"><span class="string">            threadsAwaitingConnection : <span class="subst">$&#123;hikariPoolMXBean.threadsAwaitingConnection&#125;</span></span></span><br><span class="line"><span class="string">            maxLifetime : <span class="subst">$&#123;hikariConfigMXBean.maxLifetime&#125;</span></span></span><br><span class="line"><span class="string">            maximumPoolSize : <span class="subst">$&#123;hikariConfigMXBean.maximumPoolSize&#125;</span></span></span><br><span class="line"><span class="string">            minimumIdle : <span class="subst">$&#123;hikariConfigMXBean.minimumIdle&#125;</span></span></span><br><span class="line"><span class="string">            connectionTimeout : <span class="subst">$&#123;hikariConfigMXBean.connectionTimeout&#125;</span></span></span><br><span class="line"><span class="string">            validationTimeout : <span class="subst">$&#123;hikariConfigMXBean.validationTimeout&#125;</span></span></span><br><span class="line"><span class="string">            idleTimeout : <span class="subst">$&#123;hikariConfigMXBean.idleTimeout&#125;</span></span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line">        <span class="keyword">this</span>.log.info(log)</span><br><span class="line">        <span class="keyword">return</span> findById</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드는 지연을 위해 1초 동안 대기한 후, HikariCP 커넥션 풀의 상태를 로깅하여 현재 커넥션 풀 상황을 모니터링할 수 있게 합니다.</p><h3 id="성능-테스트-결과-위-이미지-설명">성능 테스트 결과 (위 이미지 설명)</h3><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-1-1.png" alt=""></p><p>위 이미지는 커넥션 풀 설정이 <strong>minimum-idle: 10, maximum-pool-size: 10</strong>으로 설정된 상황에서, TPS가 증가함에 따라 성능이 어떻게 변화하는지를 시각화한 결과입니다.</p><ul><li><strong>Total Requests per Second</strong>:<ul><li>이 그래프는 초당 요청 처리량(RPS, 초록색 라인)과 실패한 요청(Failures, 빨간색 라인)을 보여줍니다.</li><li>TPS가 점진적으로 증가하여 초당 12 요청 수준에 도달했을 때, 실패한 요청이 발생하기 시작했습니다. 이는 커넥션 풀이 최대 용량인 10에 도달하여 더 이상 추가 요청을 처리하지 못하는 상황을 나타냅니다.</li><li>이후 TPS는 유지되지만, 실패한 요청이 지속적으로 발생하면서 커넥션 풀의 제한에 따른 성능 저하가 명확히 드러납니다. 이후 TPS는 응답 지연으로 인해 더 이상 올라가지 않습니다.</li></ul></li><li><strong>Response Times</strong>:<ul><li>응답 시간 그래프에서는 <strong>50th 퍼센타일</strong>(주황색 라인)과 <strong>95th 퍼센타일</strong>(보라색 라인)의 응답 시간이 시간이 지남에 따라 증가하는 모습이 보입니다.</li><li>특히 TPS가 증가함에 따라 95th 퍼센타일 응답 시간은 약 20,000ms 이상으로 치솟아, 사용자 요청이 큰 지연을 겪고 있음을 나타냅니다.</li><li>이는 커넥션 풀이 가득 차서 새로운 요청이 대기 상태로 전환되었기 때문이며, 트래픽 증가와 함께 시스템의 성능 한계에 도달했음을 보여줍니다.</li></ul></li><li><strong>Number of Users</strong>:<ul><li>사용자의 수가 점진적으로 증가하며 시스템에 부하를 가하고 있습니다. 사용자가 약 300명 이상일 때부터 시스템은 커넥션 풀이 한계에 도달하여, 그 이후로는 성능 저하가 본격적으로 발생합니다.</li><li>커넥션 풀 크기를 초과하는 사용자 요청은 실패하거나 긴 대기 시간을 초래하게 되며, 이는 응답 시간 증가와 TPS 유지의 원인이 됩니다.</li></ul></li></ul><p>이 이미지에서는 커넥션 풀이 최대 용량에 도달함에 따라, 시스템이 추가적인 요청을 감당하지 못하고 지연 시간과 실패율이 증가하는 과정을 시각적으로 확인할 수 있습니다.</p><h3 id="로그-분석">로그 분석</h3><ul><li><strong>activeConnections</strong>: 10 - 현재 활성 상태인 모든 커넥션이 사용 중입니다.</li><li><strong>idleConnections</strong>: 0 - 유휴 상태의 커넥션은 없습니다.</li><li><strong>threadsAwaitingConnection</strong>: 84 - 84개의 스레드가 커넥션을 기다리고 있습니다.</li><li><strong>maxLifetime</strong>: 1800000 (밀리초) - 커넥션의 최대 수명입니다.</li><li><strong>maximumPoolSize</strong>: 10 - 최대 커넥션 풀 크기가 10으로 설정되어 있습니다.</li><li><strong>minimumIdle</strong>: 10 - 최소 유휴 커넥션이 10으로 설정되어 있습니다.</li><li><strong>connectionTimeout</strong>: 30000 (밀리초) - 커넥션을 얻기 위해 대기할 수 있는 최대 시간입니다.</li><li><strong>validationTimeout</strong>: 5000 (밀리초) - 커넥션 유효성 검사를 위한 시간입니다.</li><li><strong>idleTimeout</strong>: 600000 (밀리초) - 유휴 커넥션을 유지하는 최대 시간입니다.</li></ul><p>이 로그는 커넥션 풀이 한계에 도달하여 더 이상 커넥션을 확장할 수 없고, 여러 스레드가 커넥션을 기다리면서 성능 저하가 발생하고 있음을 보여줍니다.</p><h3 id="문제-원인">문제 원인</h3><ol><li><strong>커넥션 풀 크기 제한</strong>: 현재 <code>maximum-pool-size</code>가 10으로 설정되어 있어 초당 12개 이상의 요청(TPS)을 처리하기에는 커넥션 풀 크기가 부족합니다. 모든 커넥션이 이미 사용 중이기 때문에, 추가적인 요청이 들어오면 커넥션을 기다리게 되고, 이로 인해 요청 실패가 발생하거나 응답 시간이 길어집니다.</li><li><strong>스레드 대기</strong>: 커넥션 풀이 최대 용량에 도달하면서 <code>threadsAwaitingConnection</code> 수가 증가하게 됩니다. 이는 커넥션을 얻지 못한 요청이 대기 상태로 전환되는 상황을 나타내며, TPS가 증가할 때 시스템이 추가 요청을 즉각적으로 처리하지 못하고 성능 저하를 초래하는 주요 원인이 됩니다.</li><li><strong>connectionTimeout 설정</strong>: 현재 <code>connectionTimeout</code>이 30000밀리초(30초)로 설정되어 있어, 커넥션을 기다리는 요청은 최대 30초까지 대기할 수 있습니다. 그러나 이 대기 시간이 길어질수록 전체 응답 시간이 증가하게 되며, 대기 중인 요청이 많아지면 TPS가 상승하기 어려워지고 응답 지연으로 인한 성능 저하가 발생할 수 있습니다.</li></ol><p>이러한 문제들은 TPS가 높아질수록 커넥션 풀의 제한으로 인해 전체적인 성능 저하가 발생하게 되는 이유입니다.</p><h2 id="해결-방안">해결 방안</h2><ol><li><strong>maximum-pool-size 증가</strong>: 현재의 TPS 수요를 충족하기 위해 <code>maximum-pool-size</code> 값을 늘려야 합니다. 예를 들어, 10 이상으로 설정하여 커넥션 풀이 더 많은 요청을 처리할 수 있도록 하면, 요청 대기 시간과 실패를 줄일 수 있습니다.</li><li><strong>동적 커넥션 관리</strong>: HikariCP의 특성을 활용해 <code>minimum-idle</code>과 <code>maximum-pool-size</code>를 적절히 조정하여 트래픽 변화에 유연하게 대응할 수 있도록 합니다. TPS가 높아질 때는 커넥션 풀이 자동으로 확장되도록 하고, TPS가 감소할 때는 최소한의 커넥션만 유지해 리소스를 절약하도록 설정하는 것이 좋습니다.</li><li><strong>모니터링 및 지속적인 튜닝</strong>: 커넥션 풀의 상태를 지속적으로 모니터링하여, 트래픽 패턴에 맞게 적절히 튜닝하는 것이 필요합니다. 정기적인 모니터링을 통해 TPS와 응답 시간 변화를 관찰하고, 필요에 따라 <code>maximum-pool-size</code>, <code>connectionTimeout</code> 등의 설정을 조정하여 최적의 성능을 유지할 수 있습니다.</li></ol><p>이러한 방안들은 트래픽 변동에 따라 유연하게 커넥션 풀을 관리하고, 시스템 성능을 최적화하는 데 도움이 됩니다.</p><h3 id="성능-테스트-결과-분석-maximum-pool-size를-200으로-조정한-경우">성능 테스트 결과 분석: maximum-pool-size를 200으로 조정한 경우</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">hikari:</span></span><br><span class="line">            <span class="attr">maximum-pool-size:</span> <span class="number">200</span>           <span class="comment"># 최대 커넥션 수</span></span><br><span class="line">            <span class="attr">minimum-idle:</span> <span class="number">10</span>                 <span class="comment"># 최소 유휴 커넥션 수</span></span><br></pre></td></tr></table></figure><p>위와 같이 <code>maximum-pool-size</code>를 200, <code>minimum-idle</code>을 10으로 설정하여 테스트를 진행한 결과, 커넥션 풀이 충분히 확장 가능해지면서 시스템 성능이 크게 개선되었습니다. 주요 개선 사항은 다음과 같습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-1-2.png" alt=""></p><ul><li><strong>Total Requests per Second (RPS)</strong>:<ul><li>RPS가 점진적으로 증가하여 높은 TPS를 안정적으로 처리할 수 있게 되었습니다. 초당 요청 처리량이 약 150까지 증가했음에도 불구하고, 실패한 요청(Failures/s)은 발생하지 않았습니다.</li><li>이는 커넥션 풀이 충분히 확장되어, 모든 요청이 처리되는 동안 커넥션 부족으로 인한 대기 시간이 발생하지 않았음을 의미합니다.</li></ul></li><li><strong>Response Times</strong>:<ul><li>응답 시간 그래프에서 50th 및 95th 퍼센타일 응답 시간이 비교적 안정적인 수준을 유지하고 있습니다.</li><li>95th 퍼센타일 응답 시간은 약 3,000ms 이하로, 50th 퍼센타일은 약 1,000ms 내외로 유지되었습니다. 이는 고TPS 상황에서도 일관된 응답 속도를 제공할 수 있음을 보여줍니다.</li><li>이전 설정에서 발생했던 응답 시간의 급격한 증가가 해소되어, 사용자 경험이 크게 개선되었습니다.</li></ul></li><li><strong>Failures/s 비율</strong>:<ul><li>요청 실패율이 0으로 유지되었습니다. <code>maximum-pool-size</code>를 200으로 설정한 덕분에, <code>connectionTimeout</code>으로 인해 대기 상태에서 실패하는 요청이 없었습니다.</li><li>이로써 고TPS 상황에서도 안정적인 서비스가 가능해졌으며, 대량의 동시 요청을 처리하는 데 적합한 환경이 조성되었습니다.</li></ul></li></ul><h3 id="로그-분석-2">로그 분석</h3><ul><li><strong>totalConnections</strong>: 152 - 현재 총 152개의 커넥션이 생성되었습니다.</li><li><strong>activeConnections</strong>: 152 - 모든 커넥션이 활성 상태로 사용 중입니다.</li><li><strong>idleConnections</strong>: 0 - 유휴 상태의 커넥션은 없습니다.</li><li><strong>threadsAwaitingConnection</strong>: 48 - 48개의 스레드가 커넥션을 기다리고 있습니다.</li><li><strong>maximumPoolSize</strong>: 200 - 최대 커넥션 풀 크기가 200으로 설정되었습니다.</li><li><strong>minimumIdle</strong>: 10 - 최소 유휴 커넥션이 10으로 설정되어 있어, 초기에 모든 커넥션이 생성된 상태입니다.</li></ul><p>이 설정을 통해 커넥션 풀은 트래픽이 적을 때에는 최소한의 자원만 사용하고, 트래픽이 증가할 때에는 최대 200개의 커넥션까지 확장하여 요청을 처리할 수 있습니다. 로그에서 볼 수 있듯이 TPS가 높은 상황에서도 커넥션 풀이 충분히 확장되었고, 전체적인 시스템 성능에는 큰 영향을 미치지 않았습니다. 이를 통해 시스템은 높은 TPS 환경에서도 안정적이고 일관된 성능을 제공할 수 있음을 확인할 수 있습니다.</p><h2 id="성능-테스트-결과-분석-TPS-감소-상황에서의-커넥션-풀-동작">성능 테스트 결과 분석: TPS 감소 상황에서의 커넥션 풀 동작</h2><p>아래 설정으로 TPS가 낮아진 상황에서 성능 테스트를 진행했습니다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">hikari:</span></span><br><span class="line">            <span class="attr">maximum-pool-size:</span> <span class="number">200</span>           <span class="comment"># 최대 커넥션 수</span></span><br><span class="line">            <span class="attr">minimum-idle:</span> <span class="number">10</span>                 <span class="comment"># 최소 유휴 커넥션 수</span></span><br><span class="line">            <span class="attr">max-lifetime:</span> <span class="number">300000</span>             <span class="comment"># 커넥션이 유지될 최대 시간 (밀리초)</span></span><br><span class="line">            <span class="attr">idle-timeout:</span> <span class="number">250000</span>             <span class="comment"># 유휴 커넥션이 유지될 최대 시간 (밀리초)</span></span><br></pre></td></tr></table></figure><ul><li><strong>max-lifetime</strong>: 기본값은 1800000ms (30분)입니다. 각 커넥션이 일정 시간 동안만 유지된 후 새 커넥션으로 교체되도록 하여, 오래된 커넥션으로 인해 발생할 수 있는 문제를 방지합니다. 설정된 시간(예: 300,000ms = 5분) 이후에 커넥션은 제거되고 새로운 커넥션으로 대체됩니다.</li><li><strong>idle-timeout</strong>: 기본값은 600000ms (10분)입니다. 유휴 상태의 커넥션이 설정된 시간 동안 사용되지 않으면 커넥션 풀에서 제거됩니다. 트래픽이 감소한 상황에서는 유휴 커넥션이 줄어들어 리소스가 절약됩니다. 위 설정에서는 250,000ms 동안 유휴 상태인 커넥션을 유지하고 이후에 해제하도록 설정했습니다.</li></ul><h3 id="테스트-결과-분석">테스트 결과 분석</h3><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-1-3.png" alt=""></p><ul><li><strong>Total Requests per Second (RPS)</strong>:<ul><li>TPS가 낮아지며, 초당 요청 처리량이 약 5 수준으로 안정화되었습니다.</li><li>요청 실패(Failures/s)가 발생하지 않았으며, 모든 요청이 성공적으로 처리되었습니다.</li><li>이는 트래픽이 줄어들면서 커넥션 풀이 유휴 상태로 돌아가고 있음을 의미합니다.</li></ul></li><li><strong>Response Times</strong>:<ul><li>50th 및 95th 퍼센타일 응답 시간 모두 약 1,000ms 내외로 일정하게 유지되고 있습니다.</li><li>응답 시간의 변동이 크지 않고 안정적인 수준을 보여, TPS가 낮아진 상황에서도 일관된 성능을 제공하고 있습니다.</li></ul></li><li><strong>Number of Users</strong>:<ul><li>테스트에서 사용자 수가 10명으로 일정하게 유지되고 있으며, TPS가 낮은 상태로 안정화되었습니다.</li></ul></li></ul><h3 id="로그-분석-3">로그 분석</h3><ul><li><strong>totalConnections</strong>: 15 - 현재 총 15개의 커넥션이 생성되었습니다. 트래픽 감소에 따라 필요 없는 커넥션이 자동으로 해제되며, 풀 크기가 줄어든 상태입니다.</li><li><strong>activeConnections</strong>: 6 - 현재 활성 상태로 사용 중인 커넥션이 6개입니다.</li><li><strong>idleConnections</strong>: 9 - 최소 유휴 커넥션 설정(<code>minimumIdle</code>)이 10이므로, 트래픽이 줄어든 상황에서 9개의 유휴 커넥션이 유지됩니다.</li><li><strong>threadsAwaitingConnection</strong>: 0 - 대기 중인 스레드가 없어 모든 요청이 즉시 처리되고 있습니다.</li><li><strong>maximumPoolSize</strong>: 200 - 최대 커넥션 풀 크기가 200으로 설정되어 있지만, 현재 트래픽 수준에서는 전체를 사용할 필요 없이 적정 개수의 커넥션만 유지하고 있습니다.</li><li><strong>minimumIdle</strong>: 10 - 최소 유휴 커넥션 수가 10으로 설정되어, 트래픽이 적을 때도 최소한의 커넥션을 유지해 자원을 절약합니다.</li><li><strong>maxLifetime</strong>: 300000 (밀리초) - 각 커넥션이 5분(300초) 동안 유지된 후 자동으로 갱신되도록 설정되어 있어, 오래된 커넥션으로 인한 문제를 방지하고 안정적인 연결 상태를 보장합니다.</li><li><strong>idleTimeout</strong>: 250000 (밀리초) - 유휴 상태의 커넥션이 4분 10초 동안 사용되지 않으면 풀에서 해제됩니다. 이를 통해 트래픽이 감소한 상황에서는 유휴 커넥션을 줄여 리소스를 절약할 수 있습니다.</li></ul><p>이 테스트 결과는 TPS가 줄어들면 <code>totalConnections</code>도 함께 감소하며 리소스가 효율적으로 관리되는 모습을 보여줍니다. <code>minimum-idle</code> 설정을 통해 커넥션 풀이 최소 10개의 유휴 커넥션을 유지하고, <code>idleTimeout</code>이 설정된 시간 동안 유휴 상태인 커넥션을 자동으로 해제하여 불필요한 자원 낭비를 방지합니다. 또한 <code>maxLifetime</code> 설정으로 각 커넥션의 유지 시간을 제한하여 일정 시간이 지나면 커넥션이 새롭게 갱신되도록 함으로써 오래된 커넥션으로 인한 문제를 예방합니다. 이를 통해 시스템은 트래픽 변화에 유연하게 대응하며 안정적으로 자원을 관리할 수 있는 구조를 갖추게 됩니다.</p><h2 id="결론">결론</h2><p>HikariCP를 사용한 커넥션 풀 설정은 트래픽 변화에 유연하게 대응할 수 있으며, 성능 최적화를 위해 중요한 도구가 됩니다. 적절한 <code>maximum-pool-size</code>와 <code>minimum-idle</code> 설정을 통해 고TPS 환경에서도 안정적이고 일관된 응답 시간을 제공할 수 있으며, 리소스를 효율적으로 관리하여 비용 절감 효과도 기대할 수 있습니다. 이를 통해 Spring Boot 애플리케이션은 다양한 트래픽 상황에서 성능을 최적화하며, 사용자 경험을 크게 개선할 수 있습니다.</p>]]></content:encoded>
      
      
      
      <category domain="https://cheese10yun.github.io/tags/Performance/">Performance</category>
      
      <category domain="https://cheese10yun.github.io/tags/MySQL/">MySQL</category>
      
      
      <comments>https://cheese10yun.github.io/mysql-connection-pool-timeout-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MySQL Connection Pool 관리 - HikariCP 설정 및 타임아웃 처리</title>
      <link>https://cheese10yun.github.io/mysql-connection-pool-timeout/</link>
      <guid>https://cheese10yun.github.io/mysql-connection-pool-timeout/</guid>
      <pubDate>Sun, 20 Oct 2024 16:15:31 GMT</pubDate>
      
      <description>애플리케이션에서 MySQL 데이터베이스와의 효율적인 연결을 위해 커넥션 풀을 사용합니다. 커넥션 풀은 미리 일정한 수의 데이터베이스 연결을 생성해 두고, 애플리케이션이 필요할 때마다 이 연결들을 재사용함으로써 성능을 향상시키는 기법입니다.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Connection-Pool이란">Connection Pool이란?</h2><p>애플리케이션에서 MySQL 데이터베이스와의 효율적인 연결을 위해 <strong>커넥션 풀</strong>을 사용합니다. 커넥션 풀은 미리 일정한 수의 데이터베이스 연결을 생성해 두고, 애플리케이션이 필요할 때마다 이 연결들을 재사용함으로써 성능을 향상시키는 기법입니다. 이 방식은 데이터베이스와의 연결을 매번 새로 생성하는 대신 이미 준비된 연결을 재사용하여 애플리케이션의 응답 시간을 줄이는 데 매우 유용합니다.</p><h2 id="Java-JDBC와-HikariCP">Java JDBC와 HikariCP</h2><p>Java 애플리케이션에서 가장 널리 사용되는 커넥션 풀 중 하나는 <strong>HikariCP</strong>입니다. HikariCP는 가볍고 빠른 커넥션 풀로, 대규모 트래픽이 발생하는 상황에서도 효율적인 연결 관리를 지원합니다. HikariCP는 <strong>HikariPoolMXBean</strong>과 <strong>HikariConfigMXBean</strong>이라는 JMX(Java Management Extensions)를 통해 커넥션 풀의 상태 및 설정을 관리할 수 있습니다.</p><h3 id="Spring-Boot에서의-HikariCP-설정과-기본값">Spring Boot에서의 HikariCP 설정과 기본값</h3><table><thead><tr><th>설정 항목</th><th>설명</th><th>기본값</th></tr></thead><tbody><tr><td><strong>maximum-pool-size</strong></td><td>커넥션 풀에서 유지할 수 있는 최대 커넥션 수입니다. 이 수치를 초과하는 요청은 대기 상태로 들어갑니다.</td><td>10</td></tr><tr><td><strong>minimum-idle</strong></td><td>풀에서 유지할 유휴 커넥션의 최소 개수입니다. 유휴 커넥션이 이 수치 이하로 떨어지면 새로운 커넥션이 생성됩니다.</td><td><code>maximum-pool-size</code> 값과 동일</td></tr><tr><td><strong>connection-timeout</strong></td><td>커넥션을 가져오기 위해 스레드가 대기할 수 있는 최대 시간입니다. 이 시간이 초과되면 예외가 발생합니다.</td><td>30,000ms (30초)</td></tr><tr><td><strong>max-lifetime</strong></td><td>커넥션이 유지될 수 있는 최대 시간입니다. 이 시간이 지나면 커넥션은 폐기되고 새 커넥션으로 교체됩니다.</td><td>1,800,000ms (30분)</td></tr><tr><td><strong>idle-timeout</strong></td><td>유휴 상태의 커넥션이 풀에서 유지될 수 있는 최대 시간입니다. 이 시간이 지나면 유휴 커넥션이 풀에서 제거됩니다.</td><td>600,000ms (10분)</td></tr><tr><td><strong>leak-detection-threshold</strong></td><td>지정된 시간(밀리초) 동안 사용되지 않은 커넥션을 감지하는 데 사용됩니다. 이 시간이 지나면 커넥션 리크(leak)를 의심하고 경고를 남깁니다.</td><td>0 (비활성화)</td></tr><tr><td><strong>pool-name</strong></td><td>커넥션 풀의 이름을 지정합니다. 기본적으로 HikariCP는 자동으로 이름을 생성하지만, 필요에 따라 지정할 수 있습니다.</td><td>자동 생성된 이름</td></tr><tr><td><strong>auto-commit</strong></td><td>새 커넥션이 자동 커밋 모드로 시작할지를 결정합니다. 각 쿼리 후 자동으로 커밋됩니다.</td><td><code>true</code></td></tr><tr><td><strong>validation-timeout</strong></td><td>커넥션이 유효한지 검증할 때 사용할 최대 시간입니다. 이 시간이 초과되면 커넥션은 유효하지 않다고 판단하고 폐기됩니다.</td><td>5,000ms (5초)</td></tr><tr><td><strong>read-only</strong></td><td>커넥션이 읽기 전용 모드에서 작동할지를 결정합니다.</td><td><code>false</code></td></tr><tr><td><strong>isolate-internal-queries</strong></td><td>내부 쿼리(예: 커넥션 풀의 유지 관리 쿼리)가 애플리케이션의 쿼리와 격리되는지를 설정합니다.</td><td><code>false</code></td></tr><tr><td><strong>allow-pool-suspension</strong></td><td>커넥션 풀의 일시 정지 기능을 활성화합니다. 이 설정이 활성화되면 풀을 일시 정지하거나 다시 시작할 수 있습니다.</td><td><code>false</code></td></tr><tr><td><strong>initialization-fail-timeout</strong></td><td>풀을 시작할 때 초기화에 실패하는 경우를 대비한 타임아웃 시간입니다. 이 시간이 지나면 예외가 발생합니다.</td><td>1초 (1,000ms)</td></tr></tbody></table><h2 id="커넥션-풀-시나리오-설명">커넥션 풀 시나리오 설명</h2><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-1.png" alt=""></p><p><code>maximumPoolSize</code>가 10인 커넥션 풀을 가진 애플리케이션에서, 10명의 사용자가 각각 1초에 한 번씩 요청을 보낸다고 가정해보겠습니다. 각 요청은 약 1초가 소요됩니다. 아래 시나리오는 커넥션 풀의 상태를 각 단계별로 설명합니다.</p><h3 id="커넥션-풀의-주요-필드-및-동작-시나리오-분석">커넥션 풀의 주요 필드 및 동작 시나리오 분석</h3><ul><li><strong>maximumPoolSize</strong>:<ul><li><strong>설명</strong>: 커넥션 풀에서 관리할 수 있는 최대 커넥션 수를 나타냅니다. 이 시나리오에서는 10개로 설정되어 있어, 동시에 최대 10개의 요청을 처리할 수 있습니다.</li><li><strong>이미지 설명</strong>: 이미지에서 <code>totalConnections = 10</code>으로 설정되어 있으며, 이는 커넥션 풀에서 관리할 수 있는 총 커넥션이 10개임을 의미합니다.</li></ul></li><li><strong>activeConnections</strong>:<ul><li><strong>설명</strong>: 현재 요청을 처리 중인 커넥션의 수입니다. 동시 요청이 10건 발생하면 <code>activeConnections</code>는 10이 됩니다. 더 이상 여유가 없는 상태에서 추가 요청이 들어오면 대기 상태가 됩니다.</li><li><strong>이미지 설명</strong>: 첫 번째 그림에서 <code>activeConnections = 1</code>로, 한 개의 요청이 활성화된 상태입니다. 두 번째 그림에서는 <code>activeConnections = 5</code>로, 5명이 동시에 요청을 보내고 있습니다. 세 번째 그림에서는 <code>activeConnections = 10</code>으로, 모든 커넥션이 활성화되어 추가 요청을 처리할 수 없는 상태입니다.</li></ul></li><li><strong>idleConnections</strong>:<ul><li><strong>설명</strong>: 유휴 상태로 대기 중인 커넥션의 수를 나타냅니다. 예를 들어, 첫 번째 요청이 처리될 때 <code>idleConnections</code>는 9개이며, 모든 커넥션이 활성화되면 <code>idleConnections</code>는 0이 됩니다.</li><li><strong>이미지 설명</strong>: 첫 번째 그림에서 <code>idleConnections = 9</code>로, 9개의 커넥션이 대기 상태입니다. 두 번째 그림에서는 <code>idleConnections = 5</code>, 세 번째 그림에서는 <code>idleConnections = 0</code>으로, 모든 커넥션이 사용 중인 상태입니다.</li></ul></li><li><strong>totalConnections</strong>:<ul><li><strong>설명</strong>: 커넥션 풀에서 관리하고 있는 총 커넥션 수로, <code>activeConnections</code>와 <code>idleConnections</code>의 합입니다. 이 값은 <code>maximumPoolSize</code> 내에서 유지되며, 동시 요청이 많을수록 <code>idleConnections</code>가 줄어듭니다.</li><li><strong>이미지 설명</strong>: 세 개의 그림 모두 <code>totalConnections = 10</code>으로, 이는 커넥션 풀에서 관리하는 커넥션이 총 10개임을 나타냅니다.</li></ul></li><li><strong>threadsAwaitingConnection</strong>:<ul><li><strong>설명</strong>: 커넥션이 모두 사용 중일 때 대기 중인 요청의 수를 나타냅니다. 예를 들어, 10명의 사용자가 모두 커넥션을 사용 중일 때 추가 요청이 발생하면, 그 요청은 대기 상태로 들어가 <code>threadsAwaitingConnection</code>이 증가합니다.</li><li><strong>이미지 설명</strong>: 마지막 그림에서는 모든 커넥션이 사용 중이기 때문에, 추가 요청이 발생하면 대기 상태로 들어가게 됩니다.</li></ul></li><li><strong>connectionTimeout</strong>:<ul><li><strong>설명</strong>: 대기 중인 요청이 커넥션을 얻기 위해 기다릴 수 있는 최대 시간을 나타냅니다. 예를 들어, <code>connectionTimeout</code>이 2초로 설정된 경우, 대기 중인 요청이 2초 내에 커넥션을 할당받지 못하면 요청은 실패하게 됩니다.</li><li><strong>이미지 설명</strong>: 마지막 그림에서 모든 커넥션이 사용 중인 상태에서 추가 요청이 들어오면, <code>connectionTimeout</code> 내에 커넥션을 할당받지 못할 경우 해당 요청은 실패하게 됩니다.</li></ul></li><li><strong>validationTimeout</strong>:<ul><li><strong>설명</strong>: 풀에서 커넥션을 빌려올 때 해당 커넥션이 유효한지 확인하는 시간입니다. 이 시간이 초과되면 해당 커넥션은 사용되지 않고 새로운 커넥션이 할당됩니다.</li><li><strong>이미지 설명</strong>: 유휴 상태로 오래 있던 커넥션은 유효성 검사에서 실패할 수 있으며, 이 경우 새로운 커넥션이 할당됩니다. 이미지에서는 유휴 상태의 커넥션들이 대기 중인 상태를 보여줍니다.</li></ul></li></ul><h2 id="HikariCP-설정-및-상태-측정-샘플-코드">HikariCP 설정 및 상태 측정 샘플 코드</h2><p>Spring Boot 애플리케이션에서 HikariCP를 사용하는 방법을 설명합니다. HikariCP는 Spring Boot에서 기본적으로 사용하는 커넥션 풀로, 설정을 통해 다양한 커넥션 관리 옵션을 제공합니다. 또한, HikariCP의 상태를 측정할 수 있는 방법을 추가하여 커넥션 풀의 효율적인 관리가 가능합니다.</p><h3 id="HikariCP-Properties-설정">HikariCP Properties 설정</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">hikari:</span></span><br><span class="line">            <span class="attr">maximum-pool-size:</span> <span class="number">10</span>           <span class="comment"># 최대 커넥션 수</span></span><br><span class="line">            <span class="attr">minimum-idle:</span> <span class="number">10</span>                <span class="comment"># 최소 유휴 커넥션 수</span></span><br><span class="line">            <span class="attr">connection-timeout:</span> <span class="number">30000</span>       <span class="comment"># 커넥션을 가져올 때 대기할 최대 시간 (밀리초)</span></span><br><span class="line">            <span class="attr">max-lifetime:</span> <span class="number">1800000</span>           <span class="comment"># 커넥션이 유지될 최대 시간 (밀리초)</span></span><br><span class="line">            <span class="attr">idle-timeout:</span> <span class="number">600000</span>            <span class="comment"># 유휴 커넥션이 유지될 최대 시간 (밀리초)</span></span><br><span class="line">            <span class="attr">leak-detection-threshold:</span> <span class="number">2000</span>  <span class="comment"># 커넥션 리크를 감지할 기준 시간 (밀리초)</span></span><br><span class="line">            <span class="attr">pool-name:</span> <span class="string">Sample-HikariPool</span>    <span class="comment"># 커넥션 풀 이름</span></span><br><span class="line">            <span class="attr">auto-commit:</span> <span class="literal">true</span>               <span class="comment"># 자동 커밋 여부</span></span><br><span class="line">            <span class="attr">validation-timeout:</span> <span class="number">5000</span>        <span class="comment"># 커넥션 유효성 검사를 위한 최대 시간 (밀리초)</span></span><br><span class="line">            <span class="attr">read-only:</span> <span class="literal">false</span>                <span class="comment"># 읽기 전용 모드 여부</span></span><br><span class="line">            <span class="attr">isolate-internal-queries:</span> <span class="literal">false</span> <span class="comment"># 내부 쿼리 격리 여부</span></span><br><span class="line">            <span class="attr">allow-pool-suspension:</span> <span class="literal">false</span>    <span class="comment"># 커넥션 풀 일시 정지 허용 여부</span></span><br><span class="line">            <span class="attr">initialization-fail-timeout:</span> <span class="number">1</span>  <span class="comment"># 초기화 실패 시 타임아웃 (밀리초)</span></span><br></pre></td></tr></table></figure><h3 id="HikariCP-상태-측정-코드">HikariCP 상태 측정 코드</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SampleService</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> dataSource: DataSource,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> memberRepository: MemberRepository</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> log = LoggerFactory.getLogger(javaClass)!!</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getMember</span><span class="params">()</span></span>: Member &#123;</span><br><span class="line">        <span class="keyword">val</span> member = memberRepository.findById(Random.nextInt(<span class="number">1</span>, <span class="number">101</span>).toLong()).<span class="keyword">get</span>()</span><br><span class="line">        runBlocking &#123; delay(<span class="number">1000</span>) &#125;</span><br><span class="line">        <span class="keyword">val</span> targetDataSource = dataSource.unwrap(HikariDataSource::<span class="keyword">class</span>.java)</span><br><span class="line">        <span class="keyword">val</span> hikariDataSource = targetDataSource <span class="keyword">as</span> HikariDataSource</span><br><span class="line">        <span class="keyword">val</span> hikariPoolMXBean = hikariDataSource.hikariPoolMXBean</span><br><span class="line">        <span class="keyword">val</span> hikariConfigMXBean = hikariDataSource.hikariConfigMXBean</span><br><span class="line">        <span class="keyword">val</span> log =</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            totalConnections : <span class="subst">$&#123;hikariPoolMXBean.totalConnections&#125;</span></span></span><br><span class="line"><span class="string">            activeConnections : <span class="subst">$&#123;hikariPoolMXBean.activeConnections&#125;</span></span></span><br><span class="line"><span class="string">            idleConnections : <span class="subst">$&#123;hikariPoolMXBean.idleConnections&#125;</span></span></span><br><span class="line"><span class="string">            threadsAwaitingConnection : <span class="subst">$&#123;hikariPoolMXBean.threadsAwaitingConnection&#125;</span></span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.log.info(log)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> member</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드에서는 먼저 <code>DataSource</code>를 <code>HikariDataSource</code>로 변환한 후, <code>HikariPoolMXBean</code>과 <code>HikariConfigMXBean</code>을 사용하여 커넥션 풀의 상태를 확인합니다. 이를 통해 총 커넥션 수, 활성 커넥션 수, 유휴 커넥션 수, 그리고 대기 중인 스레드 수와 같은 정보를 가져옵니다. 또한, <code>runBlocking &#123; delay(1000) &#125;</code>을 사용하여 1초간의 지연을 추가함으로써, 실제 요청이 처리되는 동안 커넥션 풀의 상태를 보다 명확하게 모니터링할 수 있습니다. 마지막으로, 이러한 커넥션 풀의 상태를 로그로 출력하여 애플리케이션의 성능을 모니터링하고, 필요한 경우 성능을 조정할 수 있는 정보를 제공합니다.</p><h2 id="Connection-Pool-측정">Connection Pool 측정</h2><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-2.png" alt=""></p><p>애플리케이션에서 커넥션 풀을 사용할 때, 커넥션 풀의 상태를 지속적으로 모니터링하는 것은 매우 중요합니다. 아래와 같은 로그는 **10 TPS (초당 트랜잭션)**를 지속적으로 유지할 때 발생한 로그입니다. 이때 평균 응답 시간은 약 1,000ms로 나타나며, 이는 TPS 수준을 고려했을 때 시스템이 적정 수준에서 작동하고 있음을 보여줍니다.</p><ul><li><p><strong>로그 1</strong>:</p><ul><li><code>totalConnections = 10</code></li><li><code>activeConnections = 7</code></li><li><code>idleConnections = 3</code></li><li><code>threadsAwaitingConnection = 0</code></li></ul><p>이 상태는 <strong>총 10개의 커넥션</strong> 중 <strong>7개가 활성화</strong>되어 요청을 처리하고 있으며, <strong>3개의 유휴 커넥션</strong>이 대기 중인 상황입니다. 모든 요청이 원활하게 처리되고 있기 때문에, 대기 중인 스레드는 없습니다.</p></li><li><p><strong>로그 2</strong>:</p><ul><li><code>totalConnections = 10</code></li><li><code>activeConnections = 10</code></li><li><code>idleConnections = 0</code></li><li><code>threadsAwaitingConnection = 4</code></li></ul><p>이 상태는 <strong>모든 10개의 커넥션이 활성화</strong>되어 요청을 처리 중이며, 더 이상 유휴 커넥션이 남아있지 않습니다. 이때 <strong>4개의 추가 요청이 들어와 대기</strong> 중입니다. <code>threadsAwaitingConnection</code> 값이 4로 증가한 이유는, 요청을 처리할 수 있는 유휴 커넥션이 없기 때문입니다.</p></li></ul><h3 id="커넥션-풀-동작-및-타임아웃-발생">커넥션 풀 동작 및 타임아웃 발생</h3><p>커넥션 풀이 설정된 <code>maximumPoolSize</code>만큼 활성화된 경우, 그 이후에 들어오는 요청은 <strong>대기 상태</strong>에 들어가게 됩니다. 이때 <strong>대기 시간이 길어질 수 있으며</strong>, 이러한 대기 시간이 너무 길어지면 <strong>타임아웃</strong>이 발생할 수 있습니다. 타임아웃이 발생하는 주요 원인은 다음과 같습니다.</p><p><strong>connection-timeout</strong>은 커넥션을 얻기 위해 스레드가 대기할 수 있는 최대 시간을 의미합니다. 예를 들어, <code>connection-timeout</code>이 30초로 설정되어 있다면, 커넥션 풀이 사용 가능한 커넥션을 30초 동안 제공하지 못할 경우 타임아웃이 발생하게 됩니다. 이 설정은 대기 중인 요청이 얼마 동안 기다릴 수 있는지를 제한합니다.</p><p>커넥션 풀은 <strong>한정된 자원</strong>을 효율적으로 관리하여 시스템의 안정성을 유지하는 좋은 방법입니다. 그러나, 만약 요청량이 설정된 <code>maximumPoolSize</code>를 초과하게 되면 대기 상태가 발생할 수 있습니다. 이러한 상황을 방지하기 위해 적절한 <strong>타임아웃</strong> 값을 설정하고, 필요에 따라 풀 크기를 조정하는 것이 중요합니다.</p><h3 id="connection-timeout-설정과-TPS-증가로-인한-오류-발생">connection-timeout 설정과 TPS 증가로 인한 오류 발생</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">hikari:</span></span><br><span class="line">            <span class="attr">maximum-pool-size:</span> <span class="number">10</span>         <span class="comment"># 최대 커넥션 수</span></span><br><span class="line">            <span class="attr">minimum-idle:</span> <span class="number">10</span>              <span class="comment"># 최소 유휴 커넥션 수</span></span><br><span class="line">            <span class="attr">connection-timeout:</span> <span class="number">250</span>       <span class="comment"># 커넥션을 가져올 때 대기할 최대 시간 (밀리초)</span></span><br></pre></td></tr></table></figure><p>위 설정에서 <code>connection-timeout</code>을 250ms로 지정한 경우, <strong>TPS</strong>가 10을 초과하게 되면 <strong>threadsAwaitingConnection</strong>에 대기하는 시간이 250ms를 넘을 수 있습니다. 이 상황이 발생하면, 커넥션 풀은 설정된 대기 시간보다 오래 걸리기 때문에 타임아웃 오류가 발생하게 됩니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-3.png" alt=""></p><p>이미지에서와 같이, <code>RPS</code>(Request Per Second)가 10 이상일 때 커넥션 풀의 한계로 인해 대기 중인 요청이 발생하고, 그 대기 시간이 <code>250ms</code>를 초과하면 오류가 발생합니다. 이때 <code>Failures/s</code>가 증가하는 것을 확인할 수 있습니다. 이는 타임아웃 설정과 관련이 있으며, 커넥션 풀의 자원 한계와 처리량을 적절히 맞춰야 하는 이유를 보여줍니다.</p><p><strong>오류 메시지 예시</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.sql.SQLTransientConnectionException: Sample-HikariPool - Connection is not available, request timed out after 251ms.</span><br><span class="line">at com.zaxxer.hikari.pool.HikariPool.createTimeoutException(HikariPool.java:696) ~[HikariCP-4.0.3.jar:na]</span><br><span class="line">at com.zaxxer.hikari.pool.HikariPool.getConnection(HikariPool.java:197) </span><br></pre></td></tr></table></figure><p>이 오류는 대기 시간이 설정된 <code>connection-timeout</code>을 초과했음을 의미하며, 커넥션 풀이 추가 요청을 처리할 수 없다는 것을 나타냅니다. 이 문제를 해결하기 위해 여러 가지 방법을 고려할 수 있습니다.</p><h2 id="Connection-Pool-문제-해결방법">Connection Pool 문제 해결방법</h2><p>애플리케이션에서 <strong>Connection Pool</strong>은 안정적인 데이터베이스 연결을 관리하는 데 매우 중요한 역할을 합니다. 하지만 시스템 부하가 높거나 설정이 적절하지 않은 경우, 커넥션 풀에서 발생하는 문제로 인해 성능 저하나 타임아웃 오류가 발생할 수 있습니다. 이러한 문제를 해결하기 위해서는 몇 가지 핵심적인 접근 방식을 취할 수 있습니다.</p><ol><li><strong>쿼리 최적화</strong>: 데이터베이스 성능 문제는 종종 비효율적인 쿼리로 인해 발생합니다. 쿼리 최적화는 애플리케이션의 응답 시간을 줄이고, 커넥션이 오랫동안 점유되는 상황을 방지할 수 있는 중요한 방법입니다. 인덱스를 추가하거나 복잡한 쿼리 구조를 단순화하는 것 등이 이에 해당합니다.</li><li><strong>connection-timeout 시간 조정</strong>: 커넥션 타임아웃은 대기 중인 요청이 커넥션을 얻기 위해 얼마나 오랜 시간 기다릴 수 있는지를 결정합니다. 이 시간을 적절히 설정함으로써 대기 중인 요청들이 효율적으로 처리되도록 할 수 있습니다. 너무 짧은 타임아웃은 오류를 유발할 수 있고, 너무 긴 타임아웃은 응답 지연을 초래할 수 있으므로, 상황에 맞게 타임아웃을 조정해야 합니다.</li><li><strong>maximum-pool-size 증가</strong>: 예상되는 트래픽에 맞춰 커넥션 풀의 최대 크기를 늘림으로써 동시 요청 처리 성능을 향상시킬 수 있습니다. 그러나 자원 낭비를 방지하기 위해 시스템의 메모리와 CPU 사용량을 신중하게 고려하여 최적의 크기를 설정하는 것이 중요합니다.</li></ol><p>이와 같은 방법을 적절히 적용하면 Connection Pool 문제를 해결하고, 애플리케이션의 성능과 안정성을 크게 향상시킬 수 있습니다. 아래에서는 이 세 가지 접근 방법을 구체적으로 다루고, 실제 적용 사례를 통해 성능 최적화 방법을 설명합니다.</p><h3 id="쿼리-최적화">쿼리 최적화</h3><p><strong>쿼리 최적화</strong>는 데이터베이스 성능 향상에 있어 중요한 단계입니다. 특히, 애플리케이션에서 <code>activeConnections</code>가 빠르게 응답하지 못하는 경우, 그 원인이 복잡한 쿼리 처리에 있다면 쿼리 최적화를 통해 성능을 크게 개선할 수 있습니다. 잘못 설계된 쿼리나 불필요하게 긴 실행 시간을 가진 쿼리는 시스템 전반의 성능에 영향을 미치고, 커넥션 풀의 자원을 오래 점유하게 되어 <strong>대기 중인 요청</strong>들이 지연되는 상황을 초래할 수 있습니다.</p><p>다음과 같은 방식으로 쿼리를 최적화함으로써 응답 속도를 개선할 수 있습니다:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMember</span><span class="params">()</span></span>: Member &#123;</span><br><span class="line">    <span class="keyword">val</span> member = memberRepository.findById(Random.nextInt(<span class="number">1</span>, <span class="number">101</span>).toLong()).<span class="keyword">get</span>()</span><br><span class="line">    <span class="comment">// runBlocking &#123; delay(1000) &#125; 블록킹 코드 제거</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> member</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드에서 불필요한 블로킹 코드인 <code>runBlocking &#123; delay(1000) &#125;</code>를 제거함으로써 쿼리 실행 지연을 없앴습니다. 이와 같이, 쿼리 최적화는 단순히 코드 내의 블로킹 요소를 제거하는 것뿐만 아니라, <strong>인덱스 추가</strong>, <strong>복잡한 조인 구조 단순화</strong>, <strong>캐싱</strong> 등을 통해 데이터베이스에 대한 부하를 줄이는 방법도 포함됩니다. 이러한 최적화 작업을 통해 쿼리 실행 시간이 줄어들면 커넥션이 더 빨리 반환되고, <strong>대기 중인 요청이 빠르게 처리</strong>될 수 있습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-4.png" alt=""></p><p>쿼리 최적화를 통해 성능이 향상되면, <strong>connection-timeout</strong>이 250ms로 설정된 상황에서도 <strong>RPS가 20</strong>인 경우처럼 높은 요청 처리량에서도 타임아웃 오류가 발생하지 않게 됩니다. 이는 쿼리가 최적화되면 커넥션이 더 빠르게 반환되기 때문에, 커넥션 풀 내에서 더 많은 요청을 동시에 처리할 수 있기 때문입니다.</p><p>최적화된 쿼리는 커넥션 점유 시간을 줄여 <strong>connection-timeout</strong> 설정의 제한을 넘지 않도록 도와주며, 결과적으로 더 많은 트랜잭션을 안정적으로 처리할 수 있게 됩니다. 따라서, 쿼리 최적화는 애플리케이션 성능을 유지하고 향상시키는 중요한 방법입니다.</p><p>결론적으로, <strong>쿼리 최적화</strong>는 데이터베이스 성능 개선뿐만 아니라, 커넥션 풀 자원 관리에도 매우 중요한 역할을 합니다. 불필요한 대기 시간을 줄이고, 시스템이 고부하 상황에서도 원활하게 작동할 수 있도록 돕습니다.</p><h3 id="connection-timeout-시간-조정">connection-timeout 시간 조정</h3><p><code>connection-timeout</code> 설정은 대기 중인 요청이 커넥션을 얻기 위해 기다릴 수 있는 시간을 조정하는 중요한 요소입니다. 만약 요청량이 많아 <strong>maximumPoolSize</strong>에 도달했을 때, <code>connection-timeout</code>을 적절히 늘려주면 대기 중인 요청이 커넥션을 할당받기까지 더 오랜 시간을 허용할 수 있습니다. 예를 들어, <code>connection-timeout</code>을 250ms에서 2,500ms로 늘리면, 커넥션 반환 대기 시간을 더 길게 설정함으로써 <strong>타임아웃 오류</strong>를 줄일 수 있습니다. 하지만, 너무 긴 대기 시간을 설정하면 그만큼 <strong>응답 시간이 지연</strong>될 수 있으므로 신중하게 설정해야 합니다.</p><p>아래는 <code>connection-timeout</code>을 2,500ms로 설정하고 테스트한 설정 예시입니다:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">hikari:</span></span><br><span class="line">            <span class="attr">maximum-pool-size:</span> <span class="number">10</span>         <span class="comment"># 최대 커넥션 수</span></span><br><span class="line">            <span class="attr">minimum-idle:</span> <span class="number">10</span>              <span class="comment"># 최소 유휴 커넥션 수</span></span><br><span class="line">            <span class="attr">connection-timeout:</span> <span class="number">2500</span>      <span class="comment"># 커넥션을 가져올 때 대기할 최대 시간 (밀리초)</span></span><br></pre></td></tr></table></figure><p>이 설정에서, <code>delay(1000)</code>는 유지하면서 <code>connection-timeout</code>을 2,500ms로 변경한 후 테스트를 진행하였습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-6.png" alt=""></p><p>테스트 결과는 아래와 같습니다:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">totalConnections : 10</span><br><span class="line">maximumPoolSize : 10</span><br><span class="line">activeConnections : 10</span><br><span class="line">idleConnections : 0</span><br><span class="line">threadsAwaitingConnection : 20</span><br></pre></td></tr></table></figure><ul><li><strong>totalConnections</strong>: 10개 커넥션이 모두 사용 중입니다.</li><li><strong>maximumPoolSize</strong>: 설정된 최대 커넥션 수는 10개입니다.</li><li><strong>activeConnections</strong>: 현재 10개의 커넥션이 활성화되어 있습니다.</li><li><strong>idleConnections</strong>: 유휴 커넥션이 없으며, 모든 커넥션이 사용 중입니다.</li><li><strong>threadsAwaitingConnection</strong>: 20개의 요청이 대기 중입니다.</li></ul><p><strong>connection-timeout</strong> 설정이 2,500ms로 변경됨에 따라, <strong>threadsAwaitingConnection</strong>에서 대기하는 시간이 길어졌습니다. 결과적으로 <strong>타임아웃 오류는 발생하지 않았지만</strong>, 응답 시간이 더 길어졌습니다. 이는 각 요청에 대해 <code>delay(1000)</code>으로 인한 1,000ms의 블로킹 시간과 <strong>threadsAwaitingConnection</strong>에서 대기한 시간이 합쳐져 응답 시간이 느려진 것입니다.</p><p>이런 경우, 타임아웃을 길게 설정하는 것은 타임아웃 오류를 방지할 수 있지만, 동시에 <strong>응답 속도</strong>가 저하될 수 있습니다. 따라서, <strong>connection-timeout</strong>은 요청의 특성과 트래픽 패턴에 맞추어 적절한 값을 설정하는 것이 매우 중요합니다.</p><h3 id="maximum-pool-size-증가">maximum-pool-size 증가</h3><p>애플리케이션에서 처리할 수 있는 동시 요청 수가 많아질 것으로 예상된다면, <code>maximum-pool-size</code>를 늘려 커넥션 풀에서 더 많은 커넥션을 생성하고 유지할 수 있도록 설정할 수 있습니다. 예를 들어, 트래픽이 예상보다 많아지거나, 동시성 처리가 많이 요구되는 상황에서는 커넥션 풀 크기를 늘려주는 것이 유리합니다. 이를 통해 더 많은 요청을 동시에 처리할 수 있게 됩니다. 그러나, 무작정 풀 크기를 크게 설정하는 것은 <strong>자원 낭비</strong>를 초래할 수 있습니다. 커넥션 풀 크기가 커지면 더 많은 메모리와 CPU가 필요하기 때문에, <strong>시스템의 자원 사용량</strong>을 신중히 고려한 후에 조정하는 것이 중요합니다.</p><p>예를 들어, <code>maximum-pool-size</code>를 100으로 설정하고, 1,000ms 대기 코드를 다시 활성화시키며 <code>connection-timeout</code>을 250ms로 유지했음에도 불구하고, 오류가 발생하지 않는 상황을 가정해보겠습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMember</span><span class="params">()</span></span>: Member &#123;</span><br><span class="line">  <span class="keyword">val</span> member = memberRepository.findById(Random.nextInt(<span class="number">1</span>, <span class="number">101</span>).toLong()).<span class="keyword">get</span>()</span><br><span class="line">  runBlocking &#123; delay(<span class="number">1000</span>) &#125;  <span class="comment">// 1,000ms 대기</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> member</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드에서는 <code>runBlocking &#123; delay(1000) &#125;</code>를 통해 각 요청마다 1초의 지연을 발생시키고 있지만, <code>maximum-pool-size</code>를 충분히 높게 설정함으로써 동시 요청이 몰리는 상황에서도 타임아웃 오류가 발생하지 않습니다. 아래와 같은 로그를 통해 확인할 수 있습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/mysql-connection-pool-5.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">totalConnections : 30</span><br><span class="line">maximumPoolSize : 100</span><br><span class="line">activeConnections : 13</span><br><span class="line">idleConnections : 17</span><br></pre></td></tr></table></figure><ul><li><strong>totalConnections</strong>: 현재 커넥션 풀에서 관리되고 있는 커넥션의 총 개수로, 현재 30개가 할당되어 있는 상태입니다.</li><li><strong>maximumPoolSize</strong>: 커넥션 풀에서 설정된 최대 커넥션 수는 100입니다. 하지만, 모든 커넥션이 필요하지 않기 때문에 100까지 차지 않고 있는 상황입니다.</li><li><strong>activeConnections</strong>: 현재 요청을 처리 중인 활성 커넥션 수는 13개입니다.</li><li><strong>idleConnections</strong>: 유휴 상태로 대기 중인 커넥션 수는 17개로, 요청이 추가로 들어오면 이 커넥션들이 활성화될 수 있습니다.</li></ul><p>이 상황에서는 <strong>maximumPoolSize</strong>가 100으로 설정되어 있지만, 모든 커넥션이 사용 중이지 않기 때문에 <strong>자원 낭비를 최소화</strong>할 수 있습니다. 요청이 몰리지 않는 상태에서는 <code>activeConnections</code>가 13개에 머무르고, 나머지 17개는 유휴 상태로 남아있습니다. 이처럼 <strong>최대 커넥션 수</strong>는 설정했지만, 필요할 때만 커넥션이 활성화되고 나머지는 유휴 상태를 유지하는 방식으로 효율적인 자원 관리가 가능합니다.</p><p>따라서, <code>maximum-pool-size</code>는 트래픽이 몰릴 경우를 대비해 충분히 큰 값으로 설정할 수 있지만, 시스템 자원에 부담을 주지 않도록 <strong>실제 트래픽</strong>과 <strong>자원 사용량</strong>을 분석하여 적절한 값으로 설정하는 것이 중요합니다.</p><h2 id="결론">결론</h2><p>HikariCP를 사용한 <strong>MySQL 커넥션 풀 관리</strong>는 애플리케이션 성능 최적화의 핵심 요소입니다. 적절한 커넥션 풀 설정을 통해 데이터베이스와의 연결을 효율적으로 관리하고, 불필요한 연결 재생성을 피하며, 응답 시간을 단축할 수 있습니다. 그러나, <strong>maximumPoolSize</strong>와 <strong>connection-timeout</strong>과 같은 설정이 적절하지 않으면, 트래픽이 증가할 때 커넥션 풀에서 대기 시간이 늘어나거나 타임아웃 오류가 발생할 수 있습니다.</p><p>이를 방지하고 시스템 성능을 최적화하기 위해 다음과 같은 중요한 포인트를 기억해야 합니다.</p><ol><li><strong>쿼리 최적화</strong>: 쿼리의 성능이 느릴 경우 <code>activeConnections</code>가 불필요하게 오래 점유되며, 전체 시스템의 성능을 저하시킬 수 있습니다. 쿼리를 최적화하여 커넥션을 빠르게 반환하면 대기 중인 요청도 신속하게 처리할 수 있습니다.</li><li><strong>maximum-pool-size 설정</strong>: <strong>maximum-pool-size</strong>는 동시 처리할 수 있는 최대 요청 수를 결정합니다. 트래픽 예측에 맞춰 적절히 풀 크기를 늘리는 것은 중요하지만, 자원 낭비를 방지하기 위해 너무 크게 설정하지 않는 것이 좋습니다. 실제로 필요할 때만 커넥션이 활성화되는 방식으로 자원을 효율적으로 관리해야 합니다.</li><li><strong>connection-timeout 설정</strong>: <strong>connection-timeout</strong> 값은 대기 중인 요청이 커넥션을 얻기 위해 기다릴 수 있는 최대 시간을 결정합니다. 이 값을 너무 낮게 설정하면 트래픽이 몰릴 때 타임아웃 오류가 자주 발생할 수 있으며, 반대로 너무 길게 설정하면 응답 시간이 지연될 수 있습니다. 트래픽 패턴에 맞춰 적절한 값을 설정하는 것이 중요합니다.</li><li><strong>TPS 모니터링</strong>: 초당 처리량(TPS)을 지속적으로 모니터링하고, 트래픽 패턴을 기반으로 HikariCP 설정을 조정해야 합니다. 이를 통해 애플리케이션이 다양한 부하 상황에서도 원활하게 작동할 수 있도록 합니다.</li></ol><p>최종적으로, 커넥션 풀 설정을 조정할 때는 트래픽 패턴과 시스템 자원을 고려하여 <strong>최적화된 값</strong>을 설정하는 것이 필수적입니다. 이를 통해 <strong>응답 속도 지연</strong> 및 <strong>타임아웃 오류</strong>를 최소화할 수 있으며, 안정적인 시스템 운영과 함께 애플리케이션의 성능을 극대화할 수 있습니다.</p>]]></content:encoded>
      
      
      
      <category domain="https://cheese10yun.github.io/tags/Performance/">Performance</category>
      
      <category domain="https://cheese10yun.github.io/tags/MySQL/">MySQL</category>
      
      
      <comments>https://cheese10yun.github.io/mysql-connection-pool-timeout/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>코루틴을 이용한 성능 개선 - Flow를 활용한 다중 요청 처리</title>
      <link>https://cheese10yun.github.io/kotlin-flow/</link>
      <guid>https://cheese10yun.github.io/kotlin-flow/</guid>
      <pubDate>Wed, 22 May 2024 15:00:00 GMT</pubDate>
      
      <description>Kotlin의 코루틴을 이용한 비동기 프로그래밍은 성능을 크게 향상시킬 수 있는 강력한 도구입니다. 특히 Flow를 활용하여 여러 요청을 동시에 처리하는 방식은 효율적인 비동기 처리를 가능하게 합니다.</description>
      
      
      
      <content:encoded><![CDATA[<p>Kotlin의 코루틴을 이용한 비동기 프로그래밍은 성능을 크게 향상시킬 수 있는 강력한 도구입니다. 특히 <code>Flow</code>를 활용하여 여러 요청을 동시에 처리하는 방식은 효율적인 비동기 처리를 가능하게 합니다. 이 포스팅에서는는 <code>Flow</code>를 사용하여 다중 요청을 처리하는 방법과 이론적 배경, 그리고 이를 사용할 때 주의할 점에 대해 다루겠습니다.</p><h2 id="시나리오">시나리오</h2><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/result_005.png" alt=""></p><p>300ms가 발생하는 API 요청을 100번 반복하는 시나리오를 가정해봅시다. 동기적으로 처리하면 100번의 요청을 처리하는 데 30초가 걸립니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrderClient</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">getOrder</span><span class="params">(orderRequest: <span class="type">OrderRequest</span>)</span></span>: ResponseResult&lt;OrderResponse&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> runBlocking &#123;</span><br><span class="line">         delay(<span class="number">300</span>) <span class="comment">// 300ms 지연, 실제 API를 호출하지 않고 시간만 지연 </span></span><br><span class="line">         ResponseResult.Success(OrderResponse(orderRequest.productId))</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getOrderSync</span><span class="params">(orderRequests: <span class="type">List</span>&lt;<span class="type">OrderRequest</span>&gt;)</span></span>: List&lt;OrderResponse&gt; &#123;</span><br><span class="line">   <span class="keyword">return</span> orderRequests</span><br><span class="line">      .map &#123;</span><br><span class="line">         orderClient</span><br><span class="line">            .getOrder(it) <span class="comment">// 300ms 지연</span></span><br><span class="line">            .onFailure &#123; log.error(<span class="string">&quot;Failure: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">            .onSuccess &#123; log.info(<span class="string">&quot;Success: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">            .getOrThrow()</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드에서 <code>OrderClient</code>의 <code>getOrder</code> 함수는 각 호출마다 300ms가 소요된다고 가정합니다. 일반적인 API 호출의 경우 300ms 응답속도는 빠른 편에 속합니다. 하지만 100번을 호출 한다고 가정하면 총 소요 시간은 100 * 300ms = 30,000ms, 즉 30초가 됩니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getOrderSync</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> stopWatch = StopWatch()</span><br><span class="line">   <span class="keyword">val</span> flatMapMergeStudy = FlatMapMergeStudy()</span><br><span class="line">   <span class="keyword">val</span> orderRequests = (<span class="number">1.</span><span class="number">.100</span>).map &#123; OrderRequest(<span class="string">&quot;<span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">   stopWatch.start()</span><br><span class="line">   <span class="keyword">val</span> response = flatMapMergeStudy.getOrderSync(orderRequests)</span><br><span class="line">   stopWatch.stop()</span><br><span class="line">   println(stopWatch.totalTimeMillis)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 30,528ms</span></span><br><span class="line">   println(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="코루틴-Flow를-이용한-성능-개선">코루틴 <code>Flow</code>를 이용한 성능 개선</h2><p>Kotlin의 코루틴은 비동기 작업을 손쉽게 처리할 수 있는 강력한 도구입니다. 특히 Flow를 활용하면 여러 비동기 요청을 효율적으로 처리할 수 있습니다. Flow는 데이터 스트림을 처리하는 코루틴 기반 API로, 여러 개의 작업을 동시에 병렬로 수행할 수 있도록 지원합니다. 이번 섹션에서는 Flow의 flatMapMerge를 사용하여 다수의 API 요청을 효율적으로 처리하는 방법과, 이를 통해 얻을 수 있는 성능 향상에 대해 다뤄보겠습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OptIn(FlowPreview::class)</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getOrderFlow</span><span class="params">(orderRequests: <span class="type">List</span>&lt;<span class="type">OrderRequest</span>&gt;)</span></span>: List&lt;OrderResponse&gt; &#123;</span><br><span class="line">   <span class="keyword">return</span> orderRequests</span><br><span class="line">      .asFlow()</span><br><span class="line">      .flatMapMerge &#123; request -&gt;</span><br><span class="line">         flow &#123;</span><br><span class="line">            orderClient</span><br><span class="line">               .getOrder(request)</span><br><span class="line">               .onFailure &#123; log.error(<span class="string">&quot;Failure: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">               .onSuccess &#123;</span><br><span class="line">                  log.info(<span class="string">&quot;Success: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">                  emit(it)</span><br><span class="line">               &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      .toList()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드에서 getOrderFlow 함수는 orderRequests 리스트를 플로우로 변환하고, flatMapMerge를 사용하여 각 요청을 병렬로 처리합니다. 각 요청은 코루틴 내에서 300ms 동안 지연된 후 결과를 반환합니다. 이 방식으로 100개의 요청을 동시에 처리하면, 전체 처리 시간은 가장 오래 걸리는 요청 하나의 시간인 300ms로 줄어듭니다.</p><h3 id="성능-테스트">성능 테스트</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getOrderFlow</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">      <span class="keyword">val</span> stopWatch = StopWatch()</span><br><span class="line">      <span class="keyword">val</span> flatMapMergeStudy = FlatMapMergeStudy()</span><br><span class="line">      <span class="keyword">val</span> orderRequests = (<span class="number">1.</span><span class="number">.100</span>).map &#123; OrderRequest(<span class="string">&quot;<span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">      stopWatch.start()</span><br><span class="line">      <span class="keyword">val</span> response = flatMapMergeStudy.getOrderFlow(orderRequests)</span><br><span class="line">      stopWatch.stop()</span><br><span class="line">      <span class="comment">// 2,228ms</span></span><br><span class="line">      println(stopWatch.totalTimeMillis)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>이론상 100개의 요청을 동시에 처리하면 300ms 정도의 시간이 소요되어야 하지만, 실제로는 2,228ms가 소요됩니다. 이는 다음과 같은 요인들로 인한 것입니다.</p><ol><li><strong>코루틴 생성과 컨텍스트 전환 오버헤드</strong><ul><li>코루틴을 생성하고 실행할 때 발생하는 오버헤드는 무시할 수 없는 시간 지연을 초래할 수 있습니다.</li><li>특히, <code>flatMapMerge</code>를 사용하여 다수의 코루틴을 병렬로 실행할 때, 각 코루틴의 생성과 컨텍스트 전환 비용이 누적되어 총 실행 시간이 증가할 수 있습니다.</li></ul></li><li><strong><code>flatMapMerge</code>의 병합 과정</strong><ul><li><code>flatMapMerge</code>는 여러 플로우를 병합하면서 각 플로우의 결과를 수집합니다.</li><li>이 과정에서 발생하는 추가적인 작업들, 예를 들어 플로우의 결과를 수집하고 병합하는 오버헤드가 존재할 수 있습니다.</li><li>이 오버헤드는 특히 플로우의 개수가 많을 때 더 크게 작용합니다.</li></ul></li><li><strong><code>emit</code> 호출과 플로우 수집의 지연</strong><ul><li>각 플로우에서 <code>emit</code>을 호출하고, 최종적으로 <code>toList</code>로 수집하는 과정에서 발생하는 지연도 무시할 수 없습니다.</li><li><code>emit</code>은 비동기적으로 데이터를 내보내는 작업이므로, 여러 번 호출될 때 지연이 누적될 수 있습니다.</li></ul></li><li><strong>기본 Concurrency 설정</strong><ul><li>flatMapMerge의 기본 concurrency 값은 16이며, 이 코드는 기본값으로 동작합니다.</li><li>Concurrency 16으로 동작할 때 100개의 요청을 처리하는 데 소요되는 시간은 100 / 16 * 300 = 1875ms 정도입니다.</li><li>이 시간은 앞서 언급한 1, 2, 3번 항목들과 함께 작업을 수행해야 하므로 추가적인 지연이 발생할 수 있습니다.</li><li><strong>특히, Concurrency 16으로 처리하는 시간이 가장 오래 걸리며, 이는 전체 처리 시간에 크게 영향을 미칩니다.</strong></li></ul></li></ol><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/result_001.png" alt=""></p><table><thead><tr><th>Rows</th><th>getOrderSync (ms)</th><th>getOrderFlow (ms)</th><th>Improvement (%)</th></tr></thead><tbody><tr><td>10</td><td>3,116</td><td>375</td><td>87.97</td></tr><tr><td>50</td><td>15,360</td><td>1,306</td><td>91.50</td></tr><tr><td>100</td><td>30,615</td><td>2,228</td><td>92.72</td></tr><tr><td>500</td><td>152,690</td><td>9,851</td><td>93.55</td></tr><tr><td>1,000</td><td>305,359</td><td>19,321</td><td>93.67</td></tr></tbody></table><p>위 표는 동기 방식(<code>getOrderSync</code>)과 비동기 방식(<code>getOrderFlow</code>)의 성능을 비교한 결과입니다. <code>getOrderFlow</code>를 사용한 비동기 방식은 모든 요청을 동시에 처리함으로써 동기 방식에 비해 큰 성능 개선을 보여주고 있습니다. 특히, 요청 수가 많을수록 비동기 방식의 성능 향상 효과가 더욱 두드러집니다. 이는 동기 방식이 요청 수에 비례하여 선형적으로 시간이 증가하는 반면, 비동기 방식은 병렬 처리를 통해 시간 증가를 억제할 수 있기 때문입니다.</p><h2 id="스레드와-코루틴-경량-스레드의-강점">스레드와 코루틴: 경량 스레드의 강점</h2><p>Kotlin 문서에서는 코루틴을 경량 스레드라고 합니다. 이는 대부분의 스레드와 마찬가지로 코루틴이 프로세스가 실행할 명령어 집합의 실행을 정의하기 때문입니다. 또한 코루틴은 스레드와 비슷한 라이프 사이클을 갖고 있습니다.</p><p>코루틴은 스레드 안에서 실행됩니다. 하나의 스레드에는 여러 개의 코루틴이 있을 수 있지만, 주어진 시간에 하나의 스레드에서는 하나의 명령만 실행될 수 있습니다. 즉, 같은 스레드에 10개의 코루틴이 있다면 해당 시점에는 하나의 코루틴만 실행됩니다.</p><p>스레드와 코루틴의 가장 큰 차이점은 코루틴이 빠르고 적은 비용으로 생성될 수 있다는 점입니다. 수천 개의 코루틴도 쉽게 생성할 수 있으며, 수천 개의 스레드를 생성하는 것보다 빠르고 자원도 훨씬 적게 사용합니다.</p><h3 id="코루틴-생성-테스트">코루틴 생성 테스트</h3><p>다음 코드는 코루틴을 생성하는 데 필요한 스레드 수를 테스트하는 예제입니다. 이 테스트를 통해 코루틴이 얼마나 적은 리소스로 동작하는지 확인할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 코드 출처 코틀린 동시성 프로그래밍 </span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">createCoroutines</span><span class="params">(amount: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> jobs = ArrayList&lt;Job&gt;()</span><br><span class="line">   <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span>.amount) &#123;</span><br><span class="line">      jobs += GlobalScope.launch &#123;</span><br><span class="line">         delay(<span class="number">1000</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   jobs.forEach &#123; it.join() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DelicateCoroutinesApi</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `코루틴 생성 테스트`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">   println(<span class="string">&quot;<span class="subst">$&#123;Thread.activeCount()&#125;</span> thread active at the start&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">      createCoroutines(<span class="number">100</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   println(<span class="string">&quot;<span class="subst">$&#123;Thread.activeCount()&#125;</span> thread active at the end&quot;</span>)</span><br><span class="line">   println(<span class="string">&quot;Took <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음은 테스트 결과입니다. 다양한 수의 코루틴을 생성했을 때 사용되는 스레드 수를 보여줍니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/result_003.png" alt=""></p><table><thead><tr><th>amount</th><th>시작 시 활성 스레드 수</th><th>종료 시 활성 스레드 수</th></tr></thead><tbody><tr><td>1</td><td>4</td><td>7</td></tr><tr><td>100</td><td>4</td><td>15</td></tr><tr><td>500</td><td>4</td><td>15</td></tr><tr><td>1,000</td><td>4</td><td>15</td></tr><tr><td>5,000</td><td>4</td><td>15</td></tr><tr><td>10,000</td><td>4</td><td>15</td></tr><tr><td>100,000</td><td>4</td><td>15</td></tr></tbody></table><p>위 결과에서 알 수 있듯이, 코루틴을 많이 생성해도 사용되는 스레드 수는 크게 증가하지 않습니다. 시작 시에는 4개의 스레드가 활성화되어 있었고, 종료 시에도 최대 15개의 스레드만 활성화되었습니다. 이는 코루틴이 얼마나 적은 리소스를 사용하여 병렬 작업을 수행할 수 있는지를 잘 보여줍니다. 위 Flow 처리에서도 요청 수가 10에서 1,000일 때 4개의 스레드만 필요합니다.</p><p>코루틴은 스레드와 비교했을 때 훨씬 가볍고, 생성 및 전환 비용이 낮습니다. 이러한 특성 덕분에 코루틴은 높은 동시성을 요구하는 애플리케이션에서 매우 유용합니다. 동기 방식에서 수천 개의 스레드를 생성하는 것은 비효율적이고 리소스 낭비가 심하지만, 코루틴을 사용하면 동일한 작업을 더 적은 리소스로 처리할 수 있습니다.</p><h2 id="Flow-Concurrency-Size-조절">Flow Concurrency Size 조절</h2><h3 id="Concurrency-기본-개념">Concurrency 기본 개념</h3><p>Concurrency(동시성)은 여러 작업이 동시에 진행되는 것을 의미합니다. 컴퓨팅에서 이는 여러 작업이 동시에 실행되거나, 하나의 작업이 다른 작업의 실행 중간에 개입하는 것을 의미합니다. 코루틴을 활용한 동시성은, 실제로 동시에 실행되지 않더라도, 작업이 비동기적으로 실행되는 것처럼 보이게 만듭니다. 이는 특히 IO 바운드 작업에서 효과적입니다.</p><p>Kotlin의 <code>flatMapMerge</code>에서 <code>concurrency</code> 파라미터는 동시에 병렬로 실행할 최대 코루틴 수를 설정합니다. 이 파라미터를 통해 한 번에 얼마나 많은 코루틴이 실행될 수 있는지를 제어할 수 있습니다.</p><h3 id="Concurrency-Size-성능-테스트">Concurrency Size 성능 테스트</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OptIn(FlowPreview::class)</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getOrderFlow</span><span class="params">(orderRequests: <span class="type">List</span>&lt;<span class="type">OrderRequest</span>&gt;, concurrency: <span class="type">Int</span>)</span></span>: List&lt;OrderResponse&gt; &#123;</span><br><span class="line">   <span class="keyword">return</span> orderRequests</span><br><span class="line">      .asFlow()</span><br><span class="line">      <span class="comment">// concurrency 동시 실행할 코루틴 수 제한, </span></span><br><span class="line">      .flatMapMerge(concurrency) &#123; request -&gt;</span><br><span class="line">         flow &#123;</span><br><span class="line">            orderClient</span><br><span class="line">               .getOrder(request)</span><br><span class="line">               .onFailure &#123; log.error(<span class="string">&quot;Failure: <span class="variable">$it</span>&quot;</span>) &#125;</span><br><span class="line">               .onSuccess &#123;</span><br><span class="line">                  log.info(<span class="string">&quot;Success: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">                  emit(it)</span><br><span class="line">               &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      .toList()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flatMapMerge의 concurrency 파라미터는 동시에 실행되는 코루틴 수를 테스트 코드에서 지정할 수 있도록 코드를 수정합니다. 지정하지 않으면 기본값은 <code>DEFAULT_CONCURRENCY</code>로 설정됩니다. 위 예제에서는 16으로 지정된 상태입니다. 다음은 1,000개의 요청을 처리할 때 다양한 <code>concurrency</code> 값에 따른 성능 테스트 결과입니다</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/result_004.png" alt=""></p><table><thead><tr><th>Concurrency</th><th>Time (ms)</th></tr></thead><tbody><tr><td>16</td><td>19,278</td></tr><tr><td>50</td><td>6,174</td></tr><tr><td>100</td><td>3,146</td></tr><tr><td>200</td><td>1,612</td></tr><tr><td>300</td><td>1,312</td></tr><tr><td>400</td><td>1,013</td></tr><tr><td>500</td><td>720</td></tr></tbody></table><p>위 결과에서 알 수 있듯이, <code>concurrency</code> 값을 늘릴수록 전체 처리 시간이 줄어듭니다. 특히, <code>concurrency</code> 값을 16에서 500까지 늘렸을 때, 전체 처리 시간이 19,278ms에서 720ms로 크게 감소한 것을 확인할 수 있습니다. 이는 <code>concurrency</code> 값을 적절히 설정하면 성능을 크게 향상시킬 수 있다는 것을 보여줍니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/kotlin-coroutine/images/result_007.png" alt=""></p><table><thead><tr><th>Rows</th><th>getOrderSync (ms)</th><th>getOrderFlow Concurrency 16 (ms)</th><th>getOrderFlow Concurrency 500 (ms)</th></tr></thead><tbody><tr><td>10</td><td>3,116</td><td>375</td><td>345</td></tr><tr><td>50</td><td>15,360</td><td>1,306</td><td>352</td></tr><tr><td>100</td><td>30,615</td><td>2,228</td><td>347</td></tr><tr><td>500</td><td>152,690</td><td>9,851</td><td>388</td></tr><tr><td>1,000</td><td>305,359</td><td>19,321</td><td>728</td></tr></tbody></table><p>1,000개의 요청을 처리하는 데 있어, 동기식 방식은 305,359ms가 소요되었으며, Flow Concurrency 16을 사용하면 처리 시간이 19,321ms로 줄어들어 약 93.67%의 성능 향상을 보였습니다. Concurrency를 500으로 설정하면 처리 시간이 728ms로 더욱 향상됩니다. Concurrency 값을 적절히 설정하면 성능을 크게 향상시킬 수 있음을 확인할 수 있습니다. 또 코루틴은 적은 양의 스레드로도 많은 데이터를 효율적으로 처리할 수 있음을 보여줍니다. 이러한 결과는 적절한 Concurrency 설정을 통해 애플리케이션의 성능을 극대화할 수 있음을 시사합니다.</p><h3 id="Concurrency-Size-성능-최적화-시-고려-사항">Concurrency Size 성능 최적화 시 고려 사항</h3><p>성능은 크게 향상됐지만 무턱대고 concurrency 값을 늘리는 것은 해결책이 아닙니다. concurrency 값을 너무 크게 설정하면 오히려 시스템 자원을 과도하게 사용하게 되어 성능 저하가 발생할 수 있습니다. 따라서 여러 코루틴을 사용하는 것은 자원을 더 많이 사용하게 되므로, 각자의 리소스와 환경에 맞는 concurrency 값을 적절하게 설정하는 것이 중요합니다. 시스템의 CPU, 메모리, 네트워크 대역폭 등을 고려하여 최적의 concurrency 값을 설정해야 합니다.</p><p>또한 배치 애플리케이션처럼 특정 작업만 하고 애플리케이션이 종료되는 환경에서는 concurrency 값을 높여 처리량을 극대화하는 것이 좋습니다. 이런 경우에는 단기간에 최대한 많은 작업을 처리하는 것이 목표이므로, 가능한 한 높은 concurrency 값을 설정하여 성능을 최적화할 수 있습니다.</p><h2 id="코루틴은-더-적은-스레드로-더-많은-동시성을-처리한다">코루틴은 더 적은 스레드로 더 많은 동시성을 처리한다</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">rxAndBulkWriter</span><span class="params">()</span></span>: ItemWriter&lt;StoreProjection&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> ItemWriter &#123; stores -&gt;</span><br><span class="line">        stores</span><br><span class="line">            .toFlowable()</span><br><span class="line">            .parallel()</span><br><span class="line">            .runOn(Schedulers.io())</span><br><span class="line">            .map &#123; store -&gt;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            .sequential()</span><br><span class="line">            .blockingSubscribe(</span><br><span class="line">                &#123; store -&gt; <span class="comment">// 속도 특정 시에는 주석 ... &#125;,</span></span><br><span class="line">                &#123; log.error(it.message, it) &#125;,</span><br><span class="line">                &#123; ... &#125;</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RxJava에서 flow 방식으로 처리하는 코드는 코루틴과 비교해볼 수 있습니다. RxJava와 코루틴의 flow를 이용한 병렬 처리 및 병합 과정은 기본적으로 유사한 개념을 공유합니다. 두 방식 모두 데이터를 비동기적으로 처리하고 결과를 수집하며, 병렬로 처리한 작업들을 하나의 흐름으로 다시 병합합니다. 그렇다면, 이 두 방식의 차이점은 무엇일까요?</p><p><img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/parallelflowable.sequential.png" alt=""></p><p>RxJava와 같은 라이브러리에서는 동시성 처리를 위해 CPU 코어 수에 맞춰 스레드를 생성하는 것이 일반적입니다. 예를 들어, CPU가 4코어라면 4개의 스레드를 생성해 병렬로 작업을 처리합니다. 이 방식은 각 스레드에 작업을 분배해 동시에 여러 작업을 처리할 수 있지만, 스레드의 생성과 컨텍스트 전환에서 발생하는 비용이 성능에 영향을 미칠 수 있습니다. 스레드 수가 많아질수록 시스템 자원을 더 많이 소비하게 됩니다.</p><p>코틀린의 코루틴은 동시성 프로그래밍에 있어서 더 효율적인 대안을 제공합니다. 코루틴은 스레드보다 훨씬 가벼우며, 하나의 스레드에서 여러 개의 코루틴을 실행할 수 있습니다. 코루틴은 스레드처럼 독립적인 작업 단위이지만, 스레드보다 적은 자원을 사용하고 빠르게 컨텍스트 전환을 할 수 있습니다.</p><p>코루틴은 I/O 작업이나 비동기 처리가 필요한 경우 특히 효과적입니다. 여러 코루틴이 동시에 실행되더라도, 이는 스레드 수와는 무관하게 적은 스레드로도 많은 작업을 처리할 수 있습니다. 즉, CPU 코어 수보다 훨씬 더 많은 동시 작업을 수행할 수 있으며, 스레드의 생성 및 컨텍스트 전환 비용도 줄어듭니다.</p><p>결론적으로, RxJava와 같은 방식은 CPU 코어 수만큼 스레드를 생성해 동시성을 처리하는 반면, 코루틴은 하나의 스레드에서 여러 작업을 동시에 처리할 수 있어, 적은 스레드로도 더 많은 동시성을 처리할 수 있다는 장점이 있습니다. 코루틴의 이러한 특성은 자원을 절약하고, 더 높은 성능을 제공할 수 있는 강력한 도구가 됩니다.</p><h2 id="출처">출처</h2><ul><li><a href="https://m.yes24.com/Goods/Detail/90338766">코틀린 동시성 프로그래밍</a></li><li><a href="https://github.com/ReactiveX/RxJava">RxJava</a></li></ul>]]></content:encoded>
      
      
      
      <category domain="https://cheese10yun.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="https://cheese10yun.github.io/tags/Performance/">Performance</category>
      
      <category domain="https://cheese10yun.github.io/tags/Coroutines/">Coroutines</category>
      
      
      <comments>https://cheese10yun.github.io/kotlin-flow/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Kotlin 자주 사용하는 패턴 정리</title>
      <link>https://cheese10yun.github.io/kotlin-pattern/</link>
      <guid>https://cheese10yun.github.io/kotlin-pattern/</guid>
      <pubDate>Sun, 05 May 2024 15:00:00 GMT</pubDate>
      
      <description>불변 객체는 데이터의 안정성과 예측 가능성을 제공하여 소프트웨어 개발에서 권장되는 패턴입니다. 특히, 암호화와 같은 데이터의 보안적 처리에 있어서 불변 객체를 사용하면 변경될 필요가 없는 정보의 무결성을 유지할 수 있습니다.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="불변-객체의-효율적-관리-copy-메소드-활용">불변 객체의 효율적 관리: <code>copy()</code> 메소드 활용</h2><p>불변 객체는 데이터의 안정성과 예측 가능성을 제공하여 소프트웨어 개발에서 권장되는 패턴입니다. 특히, 암호화와 같은 데이터의 보안적 처리에 있어서 불변 객체를 사용하면 변경될 필요가 없는 정보의 무결성을 유지할 수 있습니다. Kotlin의 <code>data class</code>는 이러한 불변 객체를 다루기 위한 유용한 기능 중 하나로 <code>copy()</code> 메소드를 제공합니다. 이 메소드를 사용하면 객체의 일부만을 변경한 새로운 객체를 생성할 수 있어, 기존 객체의 불변성을 해치지 않으면서 필요한 부분만 업데이트가 가능합니다.</p><h3 id="코드-예시-및-설명">코드 예시 및 설명</h3><p>아래의 테스트 코드는 <code>User</code>라는 데이터 클래스의 인스턴스를 생성한 후, <code>copy()</code> 메소드를 사용하여 이메일 주소만을 암호화된 형태로 변경하는 예를 보여줍니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `불변 객체의 유지보수를 위한 copy 활용 예시`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = User(</span><br><span class="line">        name = <span class="string">&quot;name&quot;</span>,</span><br><span class="line">        email = <span class="string">&quot;email@asd.com&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> userCopy = user.copy(</span><br><span class="line">        email = <span class="string">&quot;email@asd.com 암호화&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// User(name=name, email=email@asd.com)</span></span><br><span class="line">    println(<span class="string">&quot;user: <span class="variable">$user</span>&quot;</span>)</span><br><span class="line">    <span class="comment">// User(name=name, email=email@asd.com 암호화)</span></span><br><span class="line">    println(<span class="string">&quot;userCopy: <span class="variable">$userCopy</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 428039780</span></span><br><span class="line">    println(<span class="string">&quot;user: <span class="subst">$&#123;System.identityHashCode(user)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment">// 48361312</span></span><br><span class="line">    println(<span class="string">&quot;userCopy: <span class="subst">$&#123;System.identityHashCode(userCopy)&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>원본 객체 출력</strong>: <code>user: User(name=name, email=email@asd.com)</code></li><li><strong>복사 후 업데이트된 객체 출력</strong>: <code>userCopy: User(name=name, email=email@asd.com 암호화)</code></li><li><strong>객체 식별자 비교</strong>: 두 객체의 <code>System.identityHashCode</code> 값을 출력하여 각각 다른 객체임을 확인할 수 있습니다.</li></ul><h3 id="포인트-정리">포인트 정리</h3><ul><li><code>copy()</code> 메소드는 원본 객체의 일부 속성을 변경하여 새로운 객체를 생성합니다. 이 방식은 기존 객체의 불변성을 유지하면서 필요한 데이터만 갱신할 수 있는 효율적인 방법을 제공합니다.</li><li><code>val</code> 키워드를 사용하여 불변성을 명시하는 것은 데이터 보호 및 버그 방지에 중요합니다. 특히 암호화와 같이 데이터 보안이 중요한 작업에서는 불변 객체의 사용이 더욱 중요합니다.</li></ul><p>이 방법은 데이터의 무결성을 유지하면서도 효율적인 데이터 관리를 가능하게 하여, 유지보수성을 높이고 시스템의 안정성을 강화합니다. 불변 객체와 <code>copy()</code> 메소드의 적절한 사용은 모던 소프트웨어 개발의 중요한 측면 중 하나입니다.</p><h2 id="Pair와-Triple-객체의-유용성과-효율적-사용">Pair와 Triple 객체의 유용성과 효율적 사용</h2><p>코틀린에서는 간단한 객체를 빠르게 생성하고 사용할 수 있도록 <code>Pair</code>와 <code>Triple</code>이라는 두 가지 유틸리티 클래스를 제공합니다. 이러한 클래스는 특히 서비스 내부 로직에서만 사용되는 임시 데이터를 다룰 때, 매번 새로운 DTO(Data Transfer Object)를 만드는 것보다 더 효율적일 수 있습니다. 또한, 멀티 모듈 프로젝트에서 여러 모듈 간에 DTO 클래스를 공유해야 할 때 이러한 객체의 사용이 유용합니다.</p><h3 id="코드-예시-및-설명-2">코드 예시 및 설명</h3><p>다음은 <code>UserPointCalculator</code> 클래스의 구현 예시입니다. 이 클래스는 사용자 정보를 MySQL 데이터베이스에서 가져오고, 사용자의 포인트 정보는 Redis에서 가져와 계산을 진행합니다. 이 과정에서 Triple 객체를 활용하여 각 사용자의 이름, 이메일, 포인트 정보를 효과적으로 관리합니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserPointCalculator</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> userRepository: UserRepository,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> userPointRepository: UserPointRepository</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> users = userRepository.findUserByIds(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">        <span class="keyword">val</span> points = userPointRepository.findUserPoint(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">            .associateBy &#123; it.id &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> userPoints = users.map &#123;</span><br><span class="line">            Triple(</span><br><span class="line">                first = it.name,</span><br><span class="line">                second = it.email,</span><br><span class="line">                third = points[it.id]!!.point</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (userPoint <span class="keyword">in</span> userPoints) &#123;</span><br><span class="line">            println(<span class="string">&quot;user name: <span class="subst">$&#123;userPoint.first&#125;</span>, user email  <span class="subst">$&#123;userPoint.second&#125;</span>, user point  <span class="subst">$&#123;userPoint.third&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>분석</strong>: 이 예에서 <code>Triple</code> 객체는 각 사용자의 이름, 이메일, 포인트를 저장하는데 사용됩니다. 이는 데이터베이스와 다른 저장소에서 정보를 읽어와 조합할 때 유용하게 사용됩니다.</p><h3 id="Pair와-Triple-사용-시-가독성-향상">Pair와 Triple 사용 시 가독성 향상</h3><p>Pair와 Triple은 기본적으로 <code>first</code>, <code>second</code>, <code>third</code>라는 속성명을 사용합니다. 이 속성명은 코드의 가독성을 저하시킬 수 있으므로, 구조 분해 할당(destructuring declaration)을 사용하여 보다 의미 있는 변수명을 사용하는 것이 좋습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 반복 처리</span></span><br><span class="line">    <span class="keyword">for</span> ((userName, userEmail, userPoint) <span class="keyword">in</span> userPoints) &#123;</span><br><span class="line">        println(<span class="string">&quot;user name: <span class="subst">$&#123;userName&#125;</span>, user email <span class="subst">$&#123;userEmail&#125;</span>, user point <span class="variable">$userPoint</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 개별 처리</span></span><br><span class="line">    <span class="keyword">val</span> (userName, userEmail, userPoint) = userPoints.first()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이와 같은 처리 방식은 <code>Pair</code>와 <code>Triple</code>을 사용할 때 코드의 명확성을 향상시키고, 데이터를 보다 효율적으로 다루는 데 도움이 됩니다. 데이터를 직관적으로 알아볼 수 있도록 이름을 명확하게 지정함으로써, 코드의 가독성과 유지보수성을 크게 개선할 수 있습니다.</p><p>이 방법은 간단한 데이터 구조를 사용하면서도 프로그램의 복잡성을 줄이고, 클린 코드를 유지하는 데 기여합니다.</p><h3 id="포인트-정리-2">포인트 정리</h3><p><code>Pair</code>와 <code>Triple</code> 객체는 임시 데이터 또는 내부 로직에서만 사용되는 데이터를 간편하게 다루기 위한 우수한 도구입니다. 이들은 DTO를 정의하는 복잡성을 피할 수 있으며, 특히 간단한 데이터 그룹을 빠르게 다루어야 할 때 효율적입니다. 하지만, 이들을 사용할 때는 변수명을 명확하게 지정하여 코드의 가독성을 유지하는 것이 중요합니다.</p><p>이 글은 Pair와 Triple 객체의 적절한 사용 사례를 통해 개발자들이 코드의 간결성과 유지보수성을 향상시키는 방법을 제시합니다.</p><h2 id="typealias를-활용한-코드-개선"><code>typealias</code>를 활용한 코드 개선</h2><p>코틀린의 <code>typealias</code> 기능은 복잡한 타입 선언에 대한 간결하고 의미 있는 이름을 제공함으로써 코드의 가독성과 유지보수성을 크게 향상시킵니다. 특히, 프로젝트 내에서 자주 사용되는 타입 조합에 별칭을 부여함으로써, 코드의 일관성을 유지하고 타입 변경 시의 유연성을 높일 수 있습니다.</p><h3 id="코드-예시-및-설명-3">코드 예시 및 설명</h3><p>다음 예제에서는 사용자 정보(<code>User</code>)와 사용자의 포인트(<code>UserPoint</code>)를 연결하는 <code>Pair</code>에 <code>UserPointAssociation</code>이라는 <code>typealias</code>를 사용합니다. 이는 <code>Pair&lt;User, UserPoint&gt;</code>의 사용을 간소화하고, 의미를 명확히 합니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> UserPointAssociation = Pair&lt;User, UserPoint&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> userPointAssociations = users.map &#123;</span><br><span class="line">    UserPointAssociation(</span><br><span class="line">        first = it,</span><br><span class="line">        second = points[it.id]!!</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> (user, userPoint) = userPointAssociations.first()</span><br></pre></td></tr></table></figure><ul><li><code>UserPointAssociation</code> 타입 별칭은 <code>Pair&lt;User, UserPoint&gt;</code>를 대체하여 코드의 목적을 더 명확하게 표현합니다.</li><li><code>map</code> 함수 내에서 <code>UserPointAssociation</code> 생성자를 사용하여 각 사용자와 해당 포인트 객체를 쌍으로 묶습니다. 이는 데이터의 논리적 연관성을 직관적으로 보여줍니다.</li><li>구조 분해 할당을 통해 <code>user</code>와 <code>userPoint</code> 변수에 각각 사용자 정보와 포인트 정보를 할당함으로써, 코드의 가독성을 더욱 향상시킵니다.</li></ul><h3 id="포인트-정리-3">포인트 정리</h3><ul><li><strong>명확성</strong>: <code>UserPointAssociation</code>과 같은 타입 별칭을 사용하면, 복잡한 타입 조합도 의미 있는 이름으로 대체되어 코드의 목적이 분명해집니다.</li><li><strong>유연성</strong>: 타입 별칭을 사용하면, 기본 타입 구조에 변경이 필요할 때 별칭 정의만 수정하면 되므로 코드 전체에 걸쳐 유연하게 변경을 적용할 수 있습니다.</li><li><strong>재사용성</strong>: 일단 정의된 타입 별칭은 프로젝트 전반에 걸쳐 재사용될 수 있으며, 코드의 일관성을 유지하는 데 도움이 됩니다.</li></ul><p><code>typealias</code>는 복잡한 타입을 간소화하고, 코드의 의도를 명확히 전달하는 데 큰 도움을 줍니다. 이는 특히 크고 복잡한 프로젝트에서 타입 관리를 효과적으로 수행하는 데 중요한 역할을 합니다.</p><h2 id="runCatching-함수와-Result-객체를-활용한-안전한-처리"><code>runCatching</code> 함수와 <code>Result</code> 객체를 활용한 안전한 처리</h2><p>코틀린의 <code>runCatching</code> 함수는 예외 발생 가능성이 있는 코드 블록을 실행하고 그 결과를 <code>Result</code> 타입으로 캡처합니다. 이 기능은 HTTP 통신과 같은 네트워크 요청에서 매우 유용하게 사용될 수 있습니다. <code>Result</code> 객체는 성공적인 결과 또는 발생한 예외를 안전하게 처리할 수 있는 API를 제공합니다.</p><h3 id="코드-예시-및-설명-4">코드 예시 및 설명</h3><p>다음 예제는 HTTP API를 통해 사용자 데이터를 요청하고 결과를 처리하는 과정을 보여줍니다:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getUser</span><span class="params">(userId: <span class="type">Long</span>)</span></span>: User &#123;</span><br><span class="line">    <span class="keyword">return</span> runCatching &#123; userClient.getUser(userId) &#125;</span><br><span class="line">        .onFailure &#123; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Failed to fetch user data for user ID <span class="variable">$userId</span>&quot;</span>) &#125;</span><br><span class="line">        .getOrThrow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>userClient.getUser(userId)</code> 함수는 HTTP 요청을 통해 사용자 정보를 가져옵니다. 이 함수는 네트워크 에러나 데이터 문제로 예외를 발생시킬 수 있습니다.</li><li><code>runCatching</code>은 이 요청을 감싸 실행하며, 요청 중 발생하는 예외를 <code>Result</code> 객체로 캡처합니다.</li><li><code>onFailure</code> 블록은 <code>Result</code> 객체가 예외를 캡처했을 경우 실행됩니다. 여기서는 사용자 정의 예외를 던져, 오류 발생을 명확히 알립니다.</li><li><code>getOrThrow</code>는 <code>Result</code> 객체에서 값을 추출합니다. 만약 <code>Result</code>가 실패를 나타내는 경우, <code>onFailure</code>에서 설정한 예외가 발생됩니다.</li></ul><h3 id="포인트-정리-4">포인트 정리</h3><ul><li><strong>안전한 실행과 예외 처리</strong>: <code>runCatching</code>과 <code>Result</code> 객체를 사용하면 예외 처리를 안전하고 효율적으로 수행할 수 있습니다. 이를 통해 프로그램의 견고성이 증가합니다.</li><li><strong>결과 처리의 유연성</strong>: <code>Result</code> 타입은 <code>getOrThrow</code>, <code>getOrElse</code>, <code>getOrNull</code> 등 다양한 방법으로 결과를 처리할 수 있는 확장 함수를 제공합니다. 이 함수들은 각 상황에 맞게 결과를 유연하게 처리할 수 있도록 도와줍니다.</li><li><strong>코드의 간결성과 명확성</strong>: <code>runCatching</code>을 사용함으로써 전통적인 <code>try-catch</code> 블록보다 코드를 더 간결하고 읽기 쉽게 만들 수 있습니다.</li><li><strong>에러 핸들링의 명확성</strong>: <code>onFailure</code>를 통해 에러 발생 시 명확한 처리 로직을 구현할 수 있으며, 에러 메시지를 통해 오류의 원인을 더욱 분명히 할 수 있습니다.</li></ul><p>코틀린의 <code>Result</code> 타입은 개발자가 더 유연하고 견고한 코드를 작성할 수 있도록 지원합니다. 특히, HTTP 통신을 많이 다루는 서비스에서는 이러한 패턴을 적극적으로 활용하여 애플리케이션의 안정성과 유연성을 동시에 향상시킬 수 있습니다.  더 자세한 내용과 실용적인 설계 전략은 카카오페이 기술 블로그의 <a href="https://tech.kakaopay.com/post/make-http-client-design-flexible/">MSA 환경에서의 유연한 HTTP 클라이언트 설계 전략</a> 글에서 확인하실 수 있습니다. 이 글에서는 <code>Result</code> 타입을 활용하여 MSA 환경에서 HTTP 클라이언트를 유연하게 설계하는 방법을 소개하고 있습니다.</p><p>안정적인 서비스 운영을 위해 <code>runCatching</code>과 같은 코틀린의 기능을 적극 활용해보시길 권장드립니다. 이러한 패턴들은 예외가 발생할 가능성이 있는 네트워크 요청을 처리할 때 특히 유용하며, 시스템의 전체적인 에러 관리 능력을 개선할 수 있습니다.</p><h2 id="코틀린에서-by-키워드를-활용한-로깅-설정">코틀린에서 <code>by</code> 키워드를 활용한 로깅 설정</h2><p>코틀린에서 <code>by</code> 키워드는 위임 패턴(delegation)을 간편하게 구현할 수 있도록 도와줍니다. 특히, 로깅과 같은 반복적으로 사용되는 기능을 클래스에 쉽게 통합할 수 있게 하는 강력한 도구입니다. <code>by</code> 키워드를 사용하면 인스턴스 생성을 위임함으로써 코드의 중복을 줄이고 유지보수를 용이하게 만들 수 있습니다.</p><h3 id="코드-예시-및-설명-5">코드 예시 및 설명</h3><p>아래 예제는 <code>by</code> 키워드를 사용하여 <code>Logger</code> 인스턴스를 생성하고 이를 클래스에서 쉽게 사용할 수 있도록 보여줍니다:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory</span><br><span class="line"></span><br><span class="line"><span class="comment">// 로거 인스턴스 생성을 위한 제네릭 확장 함수</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;A : Any&gt;</span> A.<span class="title">logger</span><span class="params">()</span></span>: Lazy&lt;Logger&gt; = lazy &#123; LoggerFactory.getLogger(<span class="keyword">this</span>.javaClass) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 클래스 내부에서 위임을 통해 로그 인스턴스 사용</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> log <span class="keyword">by</span> logger()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">performAction</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Action performed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>logger()</code> 함수는 <code>Lazy&lt;Logger&gt;</code>를 반환합니다. 이 함수는 호출하는 객체의 클래스 이름을 사용하여 <code>Logger</code> 인스턴스를 생성합니다.</li><li><code>private val log by logger()</code> 표현은 실제 로그 인스턴스가 필요할 때까지 로그 객체의 생성을 지연시킵니다(<code>lazy</code>를 사용).</li><li>이 방식을 통해 클래스 내부에서 <code>log</code>를 직접 사용할 수 있으며, 로그 호출 시점에만 로거 인스턴스가 초기화됩니다.</li></ul><h3 id="포인트-정리-5">포인트 정리</h3><ul><li><strong>효율적인 자원 사용</strong>: <code>lazy</code>를 사용함으로써 로거의 초기화를 실제 로깅이 필요한 시점까지 지연시킬 수 있습니다. 이는 자원을 효율적으로 사용하게 합니다.</li><li><strong>코드 중복 감소</strong>: <code>logger()</code> 확장 함수를 사용하면 모든 클래스에서 동일한 로깅 구성을 쉽게 재사용할 수 있습니다. 이는 코드 중복을 크게 줄여줍니다.</li><li><strong>유지보수의 용이성</strong>: 로그 인스턴스 생성 코드를 한 곳에 집중시키므로, 로거 설정을 변경할 때 다수의 클래스를 수정할 필요가 없습니다. 이는 전체적인 유지보수를 간단하게 만듭니다.</li></ul><p><code>by</code> 키워드의 사용은 코틀린의 강력한 기능 중 하나로, 개발자가 코드를 보다 효과적이고 깔끔하게 관리할 수 있도록 돕습니다. 위의 예제처럼 <code>by</code> 키워드를 사용하는 것은 반복되는 코드 패턴을 단순화하고 프로젝트의 전반적인 품질을 향상시키는 데 큰 도움이 됩니다.</p><h2 id="코틀린에서-초기화-지연을-안전하게-관리하기">코틀린에서 초기화 지연을 안전하게 관리하기</h2><p><code>Delegates.notNull()</code>은 코틀린에서 프로퍼티가 사용되기 전에 초기화되어야 함을 보장하는 위임 메커니즘입니다. 이 방법은 특히 프로퍼티의 초기화 시점이 명확하지 않을 때 유용하며, 초기화되지 않은 상태에서의 접근을 방지하여 안전성을 높입니다.</p><h3 id="코드-예시-및-설명-6">코드 예시 및 설명</h3><p>다음 예제는 <code>QuerydslCustomRepositorySupport</code> 클래스에서 <code>Delegates.notNull()</code>을 사용하는 방법을 보여줍니다. 스프링 프레임워크의 의존성 주입 기능을 사용하여 <code>EntityManager</code>가 주입된 후 <code>JPAQueryFactory</code>를 초기화합니다. 이런 경우, 의존성 주입의 시점이 런타임에 결정되므로 <code>Delegates.notNull()</code>을 활용하여 안전하게 초기화를 보장할 수 있습니다. 이는 <code>EntityManager</code>가 설정되기 전에 <code>queryFactory</code>가 사용되는 것을 방지하며, 초기화되지 않은 상태에서의 접근을 효과적으로 차단합니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">QuerydslCustomRepositorySupport</span>(domainClass: Class&lt;*&gt;) : QuerydslRepositorySupport(domainClass) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> queryFactory: JPAQueryFactory <span class="keyword">by</span> Delegates.notNull()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PersistenceContext</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setEntityManager</span><span class="params">(entityManager: <span class="type">EntityManager</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setEntityManager(entityManager)</span><br><span class="line">        <span class="keyword">this</span>.queryFactory = JPAQueryFactory(entityManager)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>queryFactory</code> 프로퍼티는 <code>JPAQueryFactory</code> 타입으로 선언되어 있으며, <code>Delegates.notNull()</code>을 통해 위임되고 있습니다. 이는 <code>queryFactory</code>가 사용되기 전에 반드시 초기화되어야 함을 보장합니다.</li><li><code>setEntityManager</code> 메소드는 <code>EntityManager</code>를 받아 <code>super</code> 클래스의 같은 메소드를 호출한 후, <code>queryFactory</code>를 초기화합니다. 이 메소드는 <code>@PersistenceContext</code> 애노테이션을 통해 JPA의 영속성 컨텍스트에서 <code>EntityManager</code>가 주입될 때 자동으로 호출됩니다.</li><li>만약 <code>queryFactory</code>가 <code>setEntityManager</code> 메소드 호출 전에 사용되려고 하면, <code>IllegalStateException</code>이 발생하여 개발자에게 초기화 문제를 즉시 알려줍니다.</li></ul><h3 id="포인트-정리-6">포인트 정리</h3><ul><li><strong>안전성 보장</strong>: 초기화되지 않은 프로퍼티의 사용을 방지하여 애플리케이션의 안정성을 향상시킵니다.</li><li><strong>명시적인 오류 처리</strong>: 초기화되지 않은 프로퍼티에 접근하려고 할 때 즉각적으로 예외가 발생함으로써, 초기화 로직의 오류를 빠르게 파악하고 수정할 수 있습니다.</li><li><strong>초기화 유연성</strong>: 특정 메소드나 조건 하에서만 초기화가 가능한 경우에 <code>Delegates.notNull()</code>을 사용하여 유연하게 초기화를 관리할 수 있습니다.</li></ul><p>이러한 특성 덕분에 <code>Delegates.notNull()</code>은 코틀린에서 프로퍼티의 초기화를 안전하고 효과적으로 관리할 수 있는 강력한 방법을 제공하며, 특히 늦은 초기화가 필요한 상황에서 그 가치가 더욱 빛납니다.</p>]]></content:encoded>
      
      
      
      <category domain="https://cheese10yun.github.io/tags/Kotlin/">Kotlin</category>
      
      
      <comments>https://cheese10yun.github.io/kotlin-pattern/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Locust 성능 테스트 도구 소개 Part 2</title>
      <link>https://cheese10yun.github.io/locust-part-2/</link>
      <guid>https://cheese10yun.github.io/locust-part-2/</guid>
      <pubDate>Sat, 06 Apr 2024 15:00:00 GMT</pubDate>
      
      <description>이 글을 읽기 전에, Locust 성능 테스트 도구 소개를 먼저 확인해 보시는 것이 좋습니다. 이를 통해 Locust의 기본적인 사용법과 개념을 이해하신 후, 본 글에서 다루는 보다 심화된 사용 방법과 전략에 쉽게 접근하실 수 있습니다.</description>
      
      
      
      <content:encoded><![CDATA[<p>이 글을 읽기 전에, <a href="https://cheese10yun.github.io/locust-part-1/">Locust 성능 테스트 도구 소개</a>를 먼저 확인해 보시는 것이 좋습니다. 이를 통해 Locust의 기본적인 사용법과 개념을 이해하신 후, 본 글에서 다루는 보다 심화된 사용 방법과 전략에 쉽게 접근하실 수 있습니다.</p><h2 id="on-start-및-on-stop-메서드">on_start 및 on_stop 메서드</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrderApiTest</span>(<span class="title class_ inherited__">HttpUser</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.client.post(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_stop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.client.post(<span class="string">&quot;/logout&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>on_start</code>와 <code>on_stop</code> 메서드는 사용자의 세션 시작과 종료 시 특정 작업을 실행하는 데 사용됩니다. 로그인과 로그아웃 외에도, 사용자가 시나리오를 시작하기 전에 필요한 데이터를 세팅하거나, 시나리오 종료 후 사용한 리소스를 정리하는 데 사용할 수 있습니다. 예를 들어, 시나리오 시작 시 특정 API를 호출하여 필요한 설정을 하거나, 시나리오가 끝난 후 생성된 데이터를 삭제하는 등의 작업이 있을 수 있습니다. 이러한 메서드를 통해 테스트의 사전 준비와 후처리를 자동화할 수 있습니다. <code>on_start</code>는 사용자가 시작될 때 호출되며, <code>on_stop</code>은 사용자가 종료될 때 호출됩니다. 강제로 loucst를 종료하면 <code>on_stop</code> 메서드가 호출되지 않습니다.</p><h2 id="task를-이용한-API-요청-비율-조정">@task를 이용한 API 요청 비율 조정</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Advance</span>(<span class="title class_ inherited__">HttpUser</span>):</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">    @task(<span class="params"><span class="number">3</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getOrder</span>(<span class="params">self</span>):</span><br><span class="line">        ...</span><br><span class="line">        <span class="variable language_">self</span>.client.get(</span><br><span class="line">            <span class="string">&quot;/api/v1/orders&quot;</span>,</span><br><span class="line">            headers = &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span> &#125;,</span><br><span class="line">            params = params,</span><br><span class="line">            name = <span class="string">&quot;/api/v1/orders&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="meta">    @task(<span class="params"><span class="number">1</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getShop</span>(<span class="params">self</span>):</span><br><span class="line">        ...</span><br><span class="line">        <span class="variable language_">self</span>.client.get(</span><br><span class="line">            <span class="string">&quot;/api/v1/shops&quot;</span>,</span><br><span class="line">            headers = &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span> &#125;,</span><br><span class="line">            params = params,</span><br><span class="line">            name = <span class="string">&quot;/api/v1/shops&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/locust/imag/locust-1-1.png" alt=""></p><p><code>@task</code> 데코레이터는 Locust에서 작업의 실행 빈도나 우선순위를 지정하는 데 사용됩니다. 숫자를 인자로 제공함으로써, 특정 작업이 다른 작업들에 비해 상대적으로 얼마나 자주 실행될지 결정할 수 있습니다. 예를 들어, <code>@task(3)</code>은 해당 작업이 같은 TaskSet 내 다른 <code>@task(1)</code> 작업보다 세 배 더 많이 실행됨을 의미합니다. 이를 통해 실제 사용자 행동을 더 잘 모방한 부하 테스트 시나리오를 구성할 수 있습니다.</p><h2 id="순차적-TaskSets로-워크플로우-시뮬레이션">순차적 TaskSets로 워크플로우 시뮬레이션</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrderTaskSet</span>(<span class="title class_ inherited__">TaskSet</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @task</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getOrder</span>(<span class="params">self</span>):</span><br><span class="line">        ...</span><br><span class="line">        <span class="variable language_">self</span>.client.get(</span><br><span class="line">            <span class="string">&quot;/api/v1/orders&quot;</span>,</span><br><span class="line">            headers = &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span> &#125;,</span><br><span class="line">            params = params,</span><br><span class="line">            name = <span class="string">&quot;/api/v1/orders&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="meta">    @task</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getShop</span>(<span class="params">self</span>):</span><br><span class="line">        ...</span><br><span class="line">        <span class="variable language_">self</span>.client.get(</span><br><span class="line">            <span class="string">&quot;/api/v1/shops&quot;</span>,</span><br><span class="line">            headers = &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span> &#125;,</span><br><span class="line">            params = params,</span><br><span class="line">            name = <span class="string">&quot;/api/v1/shops&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderTask</span>(<span class="title class_ inherited__">HttpUser</span>):</span><br><span class="line">    wait_time = constant_pacing(<span class="number">2</span>)  <span class="comment"># 최소 10초 간격으로 작업 실행이 보장되도록 대기 시간 설정</span></span><br><span class="line">    host = <span class="string">&quot;http://localhost:8080&quot;</span>  <span class="comment"># 테스트 대상 호스트 주소 지정</span></span><br><span class="line"></span><br><span class="line">    tasks = [OrderTaskSet]</span><br></pre></td></tr></table></figure><p>순차적 TaskSets를 사용하는 워크플로우 시뮬레이션은 사용자가 실제 애플리케이션을 사용할 때의 행동 순서를 모방하는 데 사용됩니다. 이 방식에서는 TaskSet 클래스 내에서 각각의 <code>@task</code> 함수가 사용자의 다음 동작을 시뮬레이션합니다. 이 예제에서는 <code>OrderTaskSet</code> 내의 <code>getOrder</code>와 <code>getShop</code>이 동일한 비율로 실행되며, 사용자는 이 두 작업 사이를 순차적으로, 또는 랜덤으로 전환하면서 진행할 수 있습니다. <code>constant_pacing</code> 설정을 통해 각 작업 사이의 실행 간격을 조절함으로써, 실제 사용자 경험에 더 가까운 테스트 환경을 구성할 수 있습니다. 자세한 내용은 <a href="https://docs.locust.io/en/stable/tasksets.html#tasksets">Locust 공식 문서</a>를 참조하세요.</p><p>공식 문서는 정확한 비율의 작업 호출을 달성하기 위해 루프와 제어문 사용을 권장합니다. <code>@task</code>를 이용한 간단한 호출 비율 조정은 대략적인 작업 순서에 적합하지만, 정확한 작업 순서가 필요한 경우, 공식 문서의 권장 사항을 따르는 것이 더 바람직합니다.</p><h2 id="맞춤형-부하-형태-시뮬레이션">맞춤형 부하 형태 시뮬레이션</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Advance</span>(<span class="title class_ inherited__">HttpUser</span>):</span><br><span class="line">    wait_time = constant(<span class="number">1</span>)  <span class="comment"># 모든 요청 사이에 3초의 고정된 대기 시간 설정</span></span><br><span class="line">    host = <span class="string">&quot;http://localhost:8080&quot;</span>  <span class="comment"># 테스트 대상 호스트 주소 지정</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @task</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getOrder</span>(<span class="params">self</span>):</span><br><span class="line">        ...</span><br><span class="line">        <span class="variable language_">self</span>.client.get(</span><br><span class="line">            <span class="string">&quot;/api/v1/orders&quot;</span>,</span><br><span class="line">            headers = &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span> &#125;,</span><br><span class="line">            params = params,</span><br><span class="line">            name = <span class="string">&quot;/api/v1/orders&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="meta">    @task</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getShop</span>(<span class="params">self</span>):</span><br><span class="line">        ...</span><br><span class="line">        <span class="variable language_">self</span>.client.get(</span><br><span class="line">            <span class="string">&quot;/api/v1/shops&quot;</span>,</span><br><span class="line">            headers = &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span> &#125;,</span><br><span class="line">            params = params,</span><br><span class="line">            name = <span class="string">&quot;/api/v1/shops&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 사용자 정의 부하 모양을 정의하는 LoadTestShape 클래스</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomShape</span>(<span class="title class_ inherited__">LoadTestShape</span>):</span><br><span class="line">    time_limit = <span class="number">600</span>  <span class="comment"># 부하 테스트의 총 시간 한계 설정</span></span><br><span class="line">    spawn_rate = <span class="number">20</span>  <span class="comment"># 초당 새로운 사용자를 생성하는 속도 설정</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tick</span>(<span class="params">self</span>):</span><br><span class="line">        run_time = <span class="variable language_">self</span>.get_run_time()  <span class="comment"># 현재 실행 시간 가져오기</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> run_time &lt; <span class="variable language_">self</span>.time_limit:</span><br><span class="line">            <span class="comment"># 실행 시간에 따라 사용자 수 증가</span></span><br><span class="line">            user_count = run_time // <span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> (user_count, <span class="variable language_">self</span>.spawn_rate)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 시간 한계를 넘으면 테스트 종료</span></span><br></pre></td></tr></table></figure><p>위 코드는 Locust를 사용한 사용자 정의 부하 테스트 시나리오를 설정하는 예시입니다. 테스트 시작부터 시간이 600초(10분)에 이르기까지 실행 시간에 따라 사용자 수를 점진적으로 증가시킵니다. <code>tick</code> 함수는 현재 실행 시간을 기반으로 사용자 수를 결정하고, 실행 시간이 10초마다 사용자 수를 1명씩 증가시키는 로직을 포함하고 있습니다. 시간 한계에 도달하면, 즉 실행 시간이 600초를 초과하면, 테스트는 자동으로 종료됩니다. 이를 통해 초기 단계에서는 부하가 점점 증가하다가 설정된 시간이 지나면 테스트가 종료되는 시나리오를 구현할 수 있습니다.</p><h2 id="정리">정리</h2><p>사용자 세션 시작과 종료에 필요한 동작을 자동화하는 <code>on_start</code>와 <code>on_stop</code> 메서드, 다양한 API 요청의 실행 비율을 조절하는 <code>@task</code>, 실제 사용자 워크플로우 시뮬레이션에 유용한 순차적 <code>TaskSets</code>, 그리고 테스트 동안 사용자 부하를 동적으로 조절할 수 있는 맞춤형 부하 형태 <code>CustomShape</code>에 대해 설명합니다. 이 방법들은 Locust를 활용하여 보다 실제적이고 유연한 성능 테스트를 구현하는 데 도움을 줍니다.</p>]]></content:encoded>
      
      
      
      <category domain="https://cheese10yun.github.io/tags/Performance/">Performance</category>
      
      
      <comments>https://cheese10yun.github.io/locust-part-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Locust 성능 테스트 도구 소개 Part 1</title>
      <link>https://cheese10yun.github.io/locust-part-1/</link>
      <guid>https://cheese10yun.github.io/locust-part-1/</guid>
      <pubDate>Sat, 30 Mar 2024 15:00:00 GMT</pubDate>
      
      <description>Locust는 오픈 소스 부하 테스트 도구로, 사용자가 Python으로 시나리오를 작성하여 웹 애플리케이션의 성능을 측정할 수 있게 해줍니다.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Locust-란">Locust 란?</h2><p>Locust는 오픈 소스 부하 테스트 도구로, 사용자가 Python으로 시나리오를 작성하여 웹 애플리케이션의 성능을 측정할 수 있게 해줍니다. 이 도구는 이벤트 기반 모델을 사용하여 수천 명의 사용자를 시뮬레이션하고, 웹사이트나 API 서버에 대한 부하 테스트를 실시간으로 실행할 수 있습니다. Locust는 사용자 친화적인 웹 인터페이스를 제공하여 테스트의 진행 상황을 모니터링하고, 결과를 분석할 수 있게 합니다.</p><h2 id="Locust-설치">Locust 설치</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install locust</span><br></pre></td></tr></table></figure><p>pip를 통해서 <code>locust</code>를 설치합니다.</p><figure class="highlight pycon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from locust import HttpUser, task, constant</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">class HelloWorldUser(HttpUser):</span><br><span class="line">    wait_time = constant(1)  # 모든 요청 사이에 1초의 고정된 대기 시간 설정</span><br><span class="line">    host = &quot;http://localhost:8080&quot;  # 테스트 대상 호스트 주소 지정</span><br><span class="line"></span><br><span class="line">    @task</span><br><span class="line">    def hello_world(self):</span><br><span class="line">        self.client.get(</span><br><span class="line">            &quot;/api/v1/orders&quot;,</span><br><span class="line">            headers = &#123; &quot;Content-Type&quot;: &quot;application/json&quot; &#125;,</span><br><span class="line">            params = params,</span><br><span class="line">            name = &quot;/api/v1/orders&quot;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>간단하게 HTTP GET 요청을 보내는 Locust 스크립트를 작성해보았습니다. <code>HttpUser</code> 클래스를 상속받아 사용자 클래스를 정의하고, <code>@task</code> 데코레이터를 사용하여 테스트 함수를 정의합니다. <code>self.client.get</code> 메서드를 사용하여 GET 요청을 보내고, <code>params</code>와 <code>name</code> 매개변수를 사용하여 요청 파라미터와 요청 이름을 설정합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ locust -f &lt;file_name.py&gt;</span><br></pre></td></tr></table></figure><p><code>locust</code> 명령어를 사용하여 Locust 스크립트를 실행합니다. <code>-f</code> 옵션을 사용하여 실행할 스크립트 파일을 지정합니다. 실행 후 웹 브라우저에서 <code>http://localhost:8089</code>로 접속하여 Locust 웹 인터페이스를 확인할 수 있습니다. 만약 파일명을 <code>locustfile.py</code> 으로 지정했다면 <code>locust</code> 명령어만 수행하면 됩니다.</p><h2 id="Locust의-특징">Locust의 특징</h2><p>API 서버 성능 테스트 도구로 많이 알려진 도구들 중 JMeter와 nGrinder는 강력한 기능과 세밀한 설정 옵션으로 널리 사용되고 있습니다. 이러한 도구들은 복잡한 시나리오를 구현하고 대규모의 부하 테스트를 수행할 수 있는 뛰어난 능력을 가지고 있습니다. 그러나 이러한 기능성과 다양성이 더 간편하고 신속한 테스트 실행을 선호하는 사용자들에게는 설정과 실행 과정에서의 복잡성으로 인해 접근성이 떨어질 수 있습니다.</p><p>이에 비해 Locust는 사용자 친화적인 API 서버 성능 테스트 도구로, 그 사용의 용이성과 편리함에서 큰 장점을 가지고 있습니다. 특히, Locust는 Python으로 테스트 스크립트를 작성하기 때문에, 기존에 Python을 사용해본 경험이 있는 개발자라면 누구나 쉽게 접근할 수 있습니다. 이는 테스트 스크립트의 작성과 수정을 매우 간단하게 만들어 줍니다.</p><p>Locust의 설치 및 운용의 용이성은 테스트 프로세스를 대폭 단순화시킵니다. 몇 가지 간단한 명령어로 Locust를 설치할 수 있으며, 별도의 복잡한 설정 없이도 로컬 환경에서 바로 부하 테스트를 시작할 수 있습니다. 이러한 점은 개발 초기 단계에서 빠르게 API 성능을 평가하고자 할 때 특히 유용합니다.</p><p>또한, Locust로 작성된 테스트 스크립트는 Python 코드로 구성되어 있기 때문에, GitHub과 같은 원격 저장소에 코드를 올려두면 팀원이나 다른 개발자들이 언제든지 손쉽게 해당 스크립트를 클론하고, 필요한 부하 테스트를 즉시 실행할 수 있습니다. 이는 협업 환경에서의 테스트 과정을 매우 효율적으로 만들어 줍니다. 팀원들은 최신의 테스트 스크립트를 공유받아, 실시간으로 테스트 결과를 확인하고 성능 개선 작업을 진행할 수 있습니다.</p><p>이와 더불어, Locust는 실시간으로 테스트 결과를 웹 인터페이스를 통해 제공합니다. 사용자는 웹 브라우저를 통해 테스트의 진행 상황을 모니터링하고, 성능 지표를 실시간으로 확인할 수 있습니다. 이는 테스트 과정에서의 직관적인 데이터 분석과 신속한 의사 결정을 가능하게 합니다.</p><p>요약하자면, Locust는 설치와 사용이 쉬우며, 로컬 환경에서의 빠른 구동 능력으로 인해 개발자가 신속하게 성능 테스트를 수행할 수 있게 해줍니다. Python 기반의 스크립트 작성 방식은 깃헙과 같은 원격 저장소를 통한 협업에 매우 유리하며, 이로 인해 개발 프로세스의 효율성과 속도를 크게 향상시킬 수 있습니다.</p><h2 id="Locust-Dashboard">Locust Dashboard</h2><h3 id="Start-new-load-test">Start new load test</h3><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/locust/imag/locust_005.png" alt=""></p><p>Start new load test 버튼을 클릭하여 새로운 부하 테스트를 시작할 수 있습니다. 이 버튼을 클릭하면 다음과 같은 옵션을 설정할 수 있는 팝업 창이 나타납니다.</p><ul><li>Number of Users<ul><li>정의: 테스트에서 동시에 시뮬레이션할 가상 사용자의 총 수입니다.</li><li>목적: 애플리케이션이 동시에 처리할 수 있는 사용자 수를 설정하여, 애플리케이션의 동시 사용자 처리 능력을 테스트합니다.</li></ul></li><li>Ramp Up (일반적으로 Ramp Up 시간을 의미하며, Locust에서는 Spawn Rate으로 표현될 수 있음)<ul><li>정의: 테스트 시작부터 설정된 전체 사용자 수에 도달하기까지의 시간 또는 사용자가 점진적으로 증가하는 속도입니다.</li><li>목적: 사용자 수가 점진적으로 증가하는 상황을 모델링하여, 애플리케이션이 사용자 증가 속도에 어떻게 대응하는지 평가합니다.</li></ul></li></ul><h3 id="Statistics">Statistics</h3><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/locust/imag/locust_001.png" alt=""></p><p>Statistics 섹션은 현재 진행 중인 테스트의 실시간 통계를 제공합니다. 이 테이블에는 각 요청 유형별로 세분화된 데이터가 포함되어 있으며, 다음과 같은 정보를 확인할 수 있습니다:</p><ul><li>Name: 요청의 이름이나 경로를 나타냅니다.</li><li>requests: 해당 요청이 몇 번 실행되었는지 보여줍니다.</li><li>failures: 요청 실패 횟수를 나타냅니다.</li><li>Median response time: 응답 시간의 중앙값(밀리초 단위)을 보여줍니다. 이는 모든 요청 중간에 위치하는 응답 시간을 의미합니다.</li><li>Average response time: 평균 응답 시간을 나타냅니다.</li><li>Min/Max response time: 관찰된 최소 및 최대 응답 시간입니다.</li><li>Request per second: 초당 요청 수를 보여줍니다.</li></ul><h3 id="Charts">Charts</h3><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/locust/imag/locust_002.png" alt=""></p><p>Charts 섹션은 테스트 동안 수집된 데이터를 그래프 형태로 시각화합니다. 이 차트는 테스트의 진행에 따라 동적으로 업데이트되며, 주로 다음과 같은 정보를 제공합니다.</p><ul><li>Requests per second (RPS): 시간에 따른 초당 요청 수의 변화를 나타냅니다.</li><li>Response times: 다양한 응답 시간(평균, 최소, 최대)을 시간 경과에 따라 보여줍니다.</li><li>Number of users: 시간에 따른 사용자 수의 변화를 보여줍니다.</li></ul><h3 id="Download-Data">Download Data</h3><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/locust/imag/locust_003.png" alt=""></p><p>Download Data 메뉴는 테스트 결과를 다운로드할 수 있는 옵션을 제공합니다. 테스트의 통계 및 차트 데이터를 CSV 파일 형식으로 내보낼 수 있으며, 이는 보다 심층적인 분석이나 문서화, 또는 다른 팀 구성원과의 공유를 위해 사용될 수 있습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/locust/imag/locust_004.png" alt=""></p><p>특히 Download the Report 메뉴를 통해 테스트 결과를 HTML 형식으로 다운로드할 수 있습니다. 이 HTML 리포트는 테스트의 요약 정보와 세부 통계, 그리고 차트 데이터를 포함하고 있으며, 테스트 결과를 보다 시각적으로 표현할 수 있습니다. 이 리포트는 테스트 결과를 문서화하거나, 다른 팀원과 공유할 때 유용하게 사용될 수 있습니다.</p><h3 id="Local-Performance-Test">Local Performance Test</h3><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/locust/imag/locust_006.png" alt=""></p><p>로컬 환경에서의 성능 테스트 결과, 루프백 네트워크를 통해 2,500 TPS를 달성했습니다. 이는 로컬 환경의 특성을 활용한 결과이며, 실제 운영 환경에서는 성능이 다를 수 있지만, 로컬에서 쉽게 높은 TPS를 달성할 수 있다는 점을 시사합니다.</p><h2 id="정리">정리</h2><p>Locust는 사용의 용이성과 빠른 테스트 실행 능력으로 개발자에게 탁월한 부하 테스트 도구를 제공합니다. Python 기반으로 간단한 설치와 함께, 누구나 쉽게 테스트를 시작할 수 있으며, 이는 빠른 성능 평가와 적시의 개선으로 이어집니다.</p><p>원격 저장소를 통한 테스트 스크립트 공유는 팀 내 협업을 강화하며, 모든 팀원이 필요한 테스트를 쉽게 실행할 수 있게 합니다. 이러한 접근성은 테스트의 재사용성을 높이고, 개발 프로세스의 효율성을 개선합니다.</p><p>Locust는 단순한 테스트 도구를 넘어, 성능 모니터링과 개선을 위한 협업의 핵심이 됩니다. 이를 통해, 사용자에게 최적의 경험을 제공하는 애플리케이션을 구축할 수 있습니다.</p>]]></content:encoded>
      
      
      
      <category domain="https://cheese10yun.github.io/tags/Performance/">Performance</category>
      
      
      <comments>https://cheese10yun.github.io/locust-part-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>IntelliJ 각종 팁</title>
      <link>https://cheese10yun.github.io/intellij-tip2/</link>
      <guid>https://cheese10yun.github.io/intellij-tip2/</guid>
      <pubDate>Sun, 25 Feb 2024 14:26:36 GMT</pubDate>
      
      <description>IntelliJ에서는 MySQL, Oracle, PostgreSQL, Redis, Mongo DB 등을 포함한 다양한 데이터베이스에 대한 지원을 제공해주고 있습니다. 이를 통해서 동일한 도구를 이용해서 다양한 데이터베이스에 대한 작업을 수행할 수 있습니다.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Database-Global">Database Global</h2><p><img src="https://raw.githubusercontent.com/cheese10yun/IntelliJ/master/assets/a002.png" alt=""></p><p>IntelliJ에서는 MySQL, Oracle, PostgreSQL, Redis, Mongo DB 등을 포함한 다양한 데이터베이스에 대한 지원을 제공해주고 있습니다. <strong>이를 통해서 동일한 도구를 이용해서 다양한 데이터베이스에 대한 작업을 수행할 수 있습니다.</strong></p><p><img src="https://raw.githubusercontent.com/cheese10yun/IntelliJ/master/assets/a001.png" alt=""></p><p>해당 Database 설정은 Project Data Sources을 통해서 프로젝트 단위로 설정할 수 있습니다. 만약 다양한 프로젝트에서 이 설정을 공유해서 사용하고 싶다면 빨간색 박스 버튼을 누르면 <strong>Project Data Sources를 Global로 설정할 수 있습니다.</strong></p><h2 id="Database-DateTime-Format">Database DateTime Format</h2><p><img src="https://raw.githubusercontent.com/cheese10yun/IntelliJ/master/assets/a003.png" alt=""></p><p>데이터베이스에서 DateTime이 UTC 기준으로 저장되어 있을 때, 특정 지역의 시간대로 설정하여 데이터 조회를 보다 편리하게 할 수 있습니다. 이 설정은 Data Editor and Viewer에서 <code>Display temporal data in time zone</code> 옵션을 통해 원하는 지역의 시간대로 변경할 수 있습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/IntelliJ/master/assets/a004.png" alt=""></p><p>해당 설정을 한 이후 조회 쿼리를 실행하여 결과를 확인 해보면 <code>Asia/Seoul</code> 기준으로 출력되는 것을 확인할 수 있습니다.</p><h2 id="Live-Template">Live Template</h2><p><img src="https://raw.githubusercontent.com/cheese10yun/IntelliJ/master/assets/a005.png" alt=""></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> xxxx 2024-11-25 by yun.cheese</span></span><br></pre></td></tr></table></figure><p>Live Template에서 TODO를 설정 하여 코드 작성시 자동으로 주석을 추가할 수 있습니다. 이런 경우 TODO 작성시 $END$를 통해 커서를 이동시킬 수 있습니다. 또한 작성 날짜를 추가하고 싶다면 <code>Edit variables</code>를 통해 <code>Date</code>를 추가할 수 있습니다. Data Formatter을 <code>yyyy-MM-dd</code>와 같이 설정할 수 있습니다.</p>]]></content:encoded>
      
      
      
      <category domain="https://cheese10yun.github.io/tags/Jetbrains/">Jetbrains</category>
      
      <category domain="https://cheese10yun.github.io/tags/IntelliJ/">IntelliJ</category>
      
      
      <comments>https://cheese10yun.github.io/intellij-tip2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring Boot3 Kotlin JPA &amp; Querydsl 적용하기</title>
      <link>https://cheese10yun.github.io/springboot3-jpa-querydsl/</link>
      <guid>https://cheese10yun.github.io/springboot3-jpa-querydsl/</guid>
      <pubDate>Sat, 23 Dec 2023 14:00:00 GMT</pubDate>
      
      <description>Spring Boot 2에서 3으로 업데이트되면서 Spring Data JPA 관련 설정이 변경된 부분들이 있습니다. 프로젝트에서 손쉽게 Spring Boot 3으로 업데이트하면서 Spring Data JPA와 Querydsl 설정을 손쉽게 하는 방법에 대해서 살펴보겠습니다.</description>
      
      
      
      <content:encoded><![CDATA[<p>Spring Boot 2에서 3으로 업데이트되면서 Spring Data JPA 관련 설정이 변경된 부분들이 있습니다. 프로젝트에서 손쉽게 Spring Boot 3으로 업데이트하면서 Spring Data JPA와 Querydsl 설정을 손쉽게 하는 방법에 대해서 살펴보겠습니다.</p><h2 id="사전-설정">사전 설정</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew wrapper --gradle-version=8.5</span><br></pre></td></tr></table></figure><p>Gradle Wrapper를 사용하는 경우, 사용하고 있는 버전을 8.5 이상으로 업데이트 및 IntelliJ를 사용하는 경우 프로젝트의 SDK 버전을 17 이상으로 설정하는 과정을 진행합니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/IntelliJ/master/image/Project-Structure.png" alt=""></p><p>Project Structure 설정에서 SDK, Language Level을 17 버전 이상으로 지정합니다.<br><img src="https://raw.githubusercontent.com/cheese10yun/IntelliJ/master/image/module.png" alt=""></p><p>Module SDK 버전도 동일한 버전으로 설정합니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/IntelliJ/master/image/gradle.png" alt=""></p><p>Gradle 마지막으로 gradle 버전도 동일한 버전으로 설정합니다.</p><h2 id="build-gradle-kts">build.gradle.kts</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id(<span class="string">&quot;org.springframework.boot&quot;</span>) version <span class="string">&quot;3.2.1&quot;</span></span><br><span class="line">    id(<span class="string">&quot;io.spring.dependency-management&quot;</span>) version <span class="string">&quot;1.1.4&quot;</span></span><br><span class="line">    kotlin(<span class="string">&quot;jvm&quot;</span>) version <span class="string">&quot;1.9.21&quot;</span></span><br><span class="line">    kotlin(<span class="string">&quot;plugin.spring&quot;</span>) version <span class="string">&quot;1.9.21&quot;</span></span><br><span class="line">    kotlin(<span class="string">&quot;plugin.jpa&quot;</span>) version <span class="string">&quot;1.9.21&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>스프링 부트 버전 <code>3.2.1</code>으로 설정합니다.</li><li>코틀린 버전 <code>1.9.21</code>으로 설정합니다.</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java &#123;</span><br><span class="line">    <span class="keyword">sourceCompatibility</span> = JavaVersion.VERSION_17</span><br><span class="line">    <span class="keyword">targetCompatibility</span> = JavaVersion.VERSION_17</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.withType&lt;KotlinCompile&gt; &#123;</span><br><span class="line">    kotlinOptions &#123;</span><br><span class="line">        jvmTarget = <span class="string">&quot;17&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>build.gradle.kts 설정에 각종 java version을 사전 설정과 동일한 버전으로 설정합니다.</p><h2 id="Import-Replace">Import Replace</h2><p>Spring Data JPA에서의 주요 변경사항 중 하나는 패키지 경로의 변경입니다. 이전에 사용되던 <code>javax.persistence</code>가 <code>jakarta.persistence</code>로 업데이트되었습니다. IntelliJ의 Replace 기능을 이용하면 프로젝트 내의 모든 import 경로를 쉽게 변경할 수 있습니다. <code>cmd + shift + r</code> 단축키로 Replace 설정을 할 수 있습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/query-dsl/docs/images/import-repace.png" alt=""></p><p><code>import javax.persistence</code> -&gt; <code>jakarta.persistence</code> 작성한 이후 <code>REPLACE</code> 버튼으로 적용 합니다.</p><h2 id="Querydsl-적용">Querydsl 적용</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">// implementation(&quot;com.querydsl:querydsl-jpa&quot;)</span></span><br><span class="line">    implementation(<span class="string">&quot;com.querydsl:querydsl-jpa:5.0.0:jakarta&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// kapt(&quot;com.querydsl:querydsl-apt:5.0.0:jpa&quot;)</span></span><br><span class="line">    kapt(<span class="string">&quot;com.querydsl:querydsl-apt:5.0.0:jakarta&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>기존 querydsl 의존성도 변경을 변경을 진행합니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew build -x <span class="built_in">test</span>  </span><br></pre></td></tr></table></figure><p>해당 프로젝트를 빌드하면 QClass가 생성되는 것을 확인할 수 있습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/query-dsl/docs/images/qclass.png" alt=""></p>]]></content:encoded>
      
      
      
      <category domain="https://cheese10yun.github.io/tags/JPA/">JPA</category>
      
      <category domain="https://cheese10yun.github.io/tags/Spring/">Spring</category>
      
      
      <comments>https://cheese10yun.github.io/springboot3-jpa-querydsl/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>IntelliJ cannot resolve symbol 에러 해결</title>
      <link>https://cheese10yun.github.io/intellij-cannot-resolve-symbol/</link>
      <guid>https://cheese10yun.github.io/intellij-cannot-resolve-symbol/</guid>
      <pubDate>Fri, 22 Dec 2023 15:00:00 GMT</pubDate>
      
      <description>자바에서 Lombok과 같은 라이브러리로 인한 cannot resolve symbol 오류는 대체로 SDK 버전 문제로 발생합니다. 이를 해결하기 위해서는 프로젝트 내의 SDK 버전을 일관되게 설정해야 합니다.</description>
      
      
      
      <content:encoded><![CDATA[<p>자바에서 Lombok과 같은 라이브러리로 인한 <code>cannot resolve symbol</code> 오류는 대체로 SDK 버전 문제로 발생합니다. 이를 해결하기 위해서는 프로젝트 내의 SDK 버전을 일관되게 설정해야 합니다. 이 과정에서 여러 설정을 조정해야 하는데, 구체적인 SDK 설정 방법에 대해 안내해 드리겠습니다.</p><h2 id="Project-Settings-설정">Project Settings 설정</h2><h3 id="Project-설정">Project 설정</h3><p><img src="https://raw.githubusercontent.com/cheese10yun/IntelliJ/master/image/Project-Structure.png" alt=""></p><p>Project Structure 설정에서 SDK, Language Level을 동일한 버전으로 설정합니다.</p><h3 id="Modules-설정">Modules 설정</h3><p><img src="https://raw.githubusercontent.com/cheese10yun/IntelliJ/master/image/module.png" alt=""></p><p>Module SDK 버전도 동일한 버전으로 설정합니다.</p><h2 id="Gradle-설정">Gradle 설정</h2><p><img src="https://raw.githubusercontent.com/cheese10yun/IntelliJ/master/image/gradle.png" alt=""></p><p>Gradle JVM SDK 버전도 동일하게 설정합니다.</p><h2 id="Java-Compiler-설정">Java Compiler 설정</h2><p><img src="https://raw.githubusercontent.com/cheese10yun/IntelliJ/master/image/java-compile.png" alt=""></p><p>Java Compiler 설정도 동일한 버전으로 설정합니다.</p>]]></content:encoded>
      
      
      
      <category domain="https://cheese10yun.github.io/tags/IntelliJ/">IntelliJ</category>
      
      
      <comments>https://cheese10yun.github.io/intellij-cannot-resolve-symbol/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MongoDB Update 성능 측정 및 분석</title>
      <link>https://cheese10yun.github.io/spring-data-mongodb-update-performance/</link>
      <guid>https://cheese10yun.github.io/spring-data-mongodb-update-performance/</guid>
      <pubDate>Sat, 16 Dec 2023 15:00:00 GMT</pubDate>
      
      <description>MongoDB는 현대 웹 애플리케이션에서 널리 사용되는 NoSQL 데이터베이스입니다. 특히, Spring Data MongoDB는 Java 개발자에게 친숙하고 효율적인 방법으로 MongoDB와의 상호작용을 가능하게 합니다.</description>
      
      
      
      <content:encoded><![CDATA[<p>MongoDB는 현대 웹 애플리케이션에서 널리 사용되는 NoSQL 데이터베이스입니다. 특히, Spring Data MongoDB는 Java 개발자에게 친숙하고 효율적인 방법으로 MongoDB와의 상호작용을 가능하게 합니다. 이번 포스팅에서는 Spring Data MongoDB를 사용하여 데이터를 업데이트하는 여러 방법의 성능을 비교하고 분석합니다. 특히, saveAll, updateFirst, bulkOps(UNORDERED), bulkOps(ORDERED) 이 네 가지 방법에 대해 깊이 있게 살펴보겠습니다.</p><h2 id="Update-Code">Update Code</h2><h3 id="Document">Document</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document(collection = <span class="string">&quot;members&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span>(</span><br><span class="line"></span><br><span class="line">    <span class="comment">// .. 대략 11개 필드들 존재</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = <span class="string">&quot;name&quot;</span>)</span></span><br><span class="line">    <span class="keyword">var</span> name: String</span><br><span class="line">) : Auditable()</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Auditable</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">var</span> id: ObjectId? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = <span class="string">&quot;created_at&quot;</span>)</span></span><br><span class="line">    <span class="meta">@CreatedDate</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> createdAt: LocalDateTime</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = <span class="string">&quot;updated_at&quot;</span>)</span></span><br><span class="line">    <span class="meta">@LastModifiedDate</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> updatedAt: LocalDateTime</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드는 Kotlin을 사용하여 MongoDB 문서에 대해 정의된 <code>Member</code> 클래스를 나타냅니다. 이 클래스에는 대략 11개의 필드가 정의되어 있으며, 테스트에 사용될 주요 필드는 <code>name</code>입니다. 이 <code>Member</code> 클래스는 <code>Auditable</code> 추상 클래스를 상속받아, MongoDB 문서의 생성 및 수정 시간을 자동으로 추적합니다. 테스트 과정에서는 <code>name</code> 필드만을 대상으로 업데이트 작업을 수행하고 성능을 평가할 예정입니다. 이를 통해 MongoDB에서 단일 필드 업데이트의 성능을 파악하고자 합니다.</p><h3 id="saveAll">saveAll</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">updateSaveAll</span><span class="params">(members: <span class="type">List</span>&lt;<span class="type">Member</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// name 필드만 UUID.randomUUID().toString() 으로 업데이트 </span></span><br><span class="line">    memberRepository.saveAll(members)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>saveAll</code> 메서드는 Spring Data MongoDB의 <code>CrudRepository</code> 인터페이스에서 제공하는 메서드로, 여러 개의 문서를 데이터베이스에 저장하거나 업데이트하는 데 사용됩니다. 동작 방식은 다음과 같습니다.</p><ol><li><strong>ID 존재 여부에 따른 동작</strong>: <code>saveAll</code> 메서드는 전달된 <code>Member</code> 객체 리스트를 순회하면서 각 객체의 <code>id</code> 필드를 확인합니다.<ul><li><strong>ID가 없는 경우 (Insert)</strong>: <code>Member</code> 객체에 <code>id</code> 필드가 <code>null</code>이거나 존재하지 않으면, 해당 객체는 새로운 문서로 간주되어 데이터베이스에 삽입됩니다.</li><li><strong>ID가 있는 경우 (Update)</strong>: 이미 <code>id</code> 필드가 있는 <code>Member</code> 객체는 해당 <code>id</code>를 가진 기존 문서를 업데이트합니다.</li></ul></li><li><strong>일괄 처리</strong>: 여러 객체를 포함하는 리스트를 한 번에 데이터베이스에 저장하거나 업데이트할 수 있는 이점이 있습니다.</li></ol><p>이번 테스트에서는 <code>saveAll</code> 메서드를 사용하여 <code>Member</code> 객체의 <code>name</code> 필드를 업데이트하는 데 집중합니다. 테스트에 사용되는 모든 <code>Member</code> 객체는 이미 <code>id</code>를 가지고 있으므로, 이 메서드는 모든 객체를 데이터베이스에 업데이트하는 작업으로 처리합니다. 이를 통해 <code>saveAll</code> 메서드가 대량의 업데이트 작업을 얼마나 효과적으로 처리할 수 있는지 성능을 평가하고자 합니다.</p><h3 id="updateFirst">updateFirst</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">updateFirst</span><span class="params">(id: <span class="type">ObjectId</span>)</span></span>: UpdateResult &#123;</span><br><span class="line">    <span class="keyword">return</span> mongoTemplate.updateFirst(</span><br><span class="line">        Query(Criteria.<span class="keyword">where</span>(<span class="string">&quot;_id&quot;</span>).`<span class="keyword">is</span>`(id)),</span><br><span class="line">        Update().<span class="keyword">set</span>(<span class="string">&quot;name&quot;</span>, UUID.randomUUID().toString()),</span><br><span class="line">        Member::<span class="keyword">class</span>.java</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>updateFirst</code> 메서드는 Spring Data MongoDB의 <code>MongoTemplate</code>을 사용하여 특정 조건을 만족하는 첫 번째 문서를 업데이트하는 기능을 제공합니다. 이 메서드는 주어진 쿼리에 따라 데이터베이스 내에서 일치하는 첫 번째 문서를 찾아 해당 필드를 업데이트합니다. 동작 방식은 다음과 같습니다.</p><ol><li><strong>쿼리 매칭</strong>: <code>updateFirst</code>는 <code>Query</code> 객체를 사용하여 업데이트할 문서를 찾습니다. 이 예제에서는 <code>Criteria.where(&quot;_id&quot;).is(id)</code>를 통해 특정 <code>id</code> 값을 가진 문서를 찾습니다.</li><li><strong>업데이트 내용 지정</strong>: <code>Update</code> 객체를 사용하여 업데이트할 내용을 지정합니다. 여기서는 <code>name</code> 필드를 새롭게 생성된 무작위 UUID 문자열로 설정합니다.</li><li><strong>첫 번째 일치 문서 업데이트</strong>: 쿼리에 일치하는 첫 번째 문서만 업데이트됩니다. 만약 일치하는 문서가 없으면 업데이트는 수행되지 않습니다.</li><li><strong>결과 반환</strong>: 메서드는 <code>UpdateResult</code>를 반환하여 업데이트 작업의 결과를 나타냅니다. 이를 통해 몇 개의 문서가 영향을 받았는지 확인할 수 있습니다.</li></ol><p>이번 테스트에서는 <code>updateFirst</code> 메서드를 사용하여 <code>Member</code> 클래스의 <code>name</code> 필드를 업데이트합니다. 테스트는 특정 <code>id</code>를 가진 <code>Member</code> 문서를 대상으로 하며, 이 메서드는 해당 문서의 <code>name</code> 필드를 새로운 값으로 업데이트합니다. 이 방법을 통해 <code>updateFirst</code> 메서드의 단일 문서 업데이트 성능을 평가하고자 합니다.</p><h3 id="bulkOps">bulkOps</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">updateBulk</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ids: <span class="type">List</span>&lt;<span class="type">ObjectId</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    bulkMode: <span class="type">BulkOperations</span>.<span class="type">BulkMode</span> = BulkOperations.BulkMode.UNORDERED <span class="comment">// or BulkOperations.BulkMode.ORDERED</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: BulkWriteResult &#123;</span><br><span class="line">    <span class="keyword">val</span> bulkOps = mongoTemplate.bulkOps(bulkMode, Member::<span class="keyword">class</span>.java)</span><br><span class="line">    <span class="keyword">for</span> (id <span class="keyword">in</span> ids) &#123;</span><br><span class="line">        bulkOps.updateOne(</span><br><span class="line">            Query(Criteria.<span class="keyword">where</span>(<span class="string">&quot;_id&quot;</span>).`<span class="keyword">is</span>`(id)),</span><br><span class="line">            Update().<span class="keyword">set</span>(<span class="string">&quot;name&quot;</span>, UUID.randomUUID().toString())</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bulkOps.execute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bulkOps</code> 메서드는 Spring Data MongoDB의 <code>MongoTemplate</code>을 사용하여 대량의 업데이트 작업을 효율적으로 처리하는 방법을 제공합니다. <code>bulkOps</code>는 한 번의 연산으로 여러 업데이트 작업을 모아서 실행할 수 있으며, <code>BulkMode</code>에 따라 순서대로(<code>ORDERED</code>) 또는 순서에 구애받지 않고(<code>UNORDERED</code>) 실행할 수 있습니다. 동작 방식은 다음과 같습니다.</p><ol><li><strong>Bulk Operations 설정</strong>: <code>bulkOps</code>는 주어진 <code>BulkMode</code>와 문서 클래스(<code>Member::class.java</code>)를 기반으로 초기화됩니다.</li><li><strong>업데이트 작업 추가</strong>: <code>updateOne</code> 메서드를 사용하여 각 <code>id</code>에 대한 업데이트 작업을 추가합니다. 여기서는 <code>name</code> 필드를 새로운 무작위 UUID 문자열로 설정합니다.</li><li><strong>Bulk 작업 실행</strong>: <code>execute</code> 메서드를 호출하여 누적된 모든 업데이트 작업을 한 번에 실행합니다.</li><li><strong>결과 반환</strong>: 메서드는 <code>BulkWriteResult</code>를 반환하여 대량 업데이트 작업의 결과를 나타냅니다.</li></ol><p>이번 테스트에서는 <code>bulkOps</code> 메서드를 사용하여 <code>Member</code> 클래스의 <code>name</code> 필드를 대량으로 업데이트합니다. 여러 <code>id</code>를 가진 <code>Member</code> 문서에 대해 각각 <code>name</code> 필드를 새로운 값으로 업데이트하는 작업을 모아 한 번에 실행합니다. 이 방법을 통해 <code>bulkOps</code> 메서드의 대량 업데이트 성능과 <code>UNORDERED</code>와 <code>ORDERED</code> 모드 간의 성능 차이를 평가하고자 합니다.</p><h4 id="BulkMode-차이점">BulkMode 차이점:</h4><ul><li><p><strong><code>BulkOperations.BulkMode.UNORDERED</code></strong>:</p><ul><li>작업들이 순서에 구애받지 않고 병렬적으로 처리됩니다.</li><li>성능 측면에서 더 효율적일 수 있으나, 하나의 작업 실패가 다른 작업에 영향을 미치지 않습니다.</li><li>대량의 독립적인 작업을 빠르게 처리해야 할 때 유용합니다.</li></ul></li><li><p><strong><code>BulkOperations.BulkMode.ORDERED</code></strong>:</p><ul><li>작업들이 추가된 순서대로 처리됩니다.</li><li>하나의 작업이 실패하면 그 이후의 작업은 실행되지 않을 수 있습니다.</li><li>작업들 간의 순서가 중요한 경우에 적합합니다.</li></ul></li></ul><h2 id="성능-측정-결과">성능 측정 결과</h2><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/5fc6127a0800ca9bce5de5a6c73931b2025b0791/mongo-study/images/performance-update.png" alt=""></p><table><thead><tr><th>rows</th><th>saveAll</th><th>updateFirst</th><th>bulkOps(UNORDERED)</th><th>bulkOps(ORDERED)</th></tr></thead><tbody><tr><td>100</td><td>1,052 ms</td><td>1,176 ms</td><td>46 ms</td><td>79 ms</td></tr><tr><td>200</td><td>2,304 ms</td><td>2,196 ms</td><td>103 ms</td><td>124 ms</td></tr><tr><td>500</td><td>5,658 ms</td><td>5,250 ms</td><td>309 ms</td><td>257 ms</td></tr><tr><td>1,000</td><td>11,106 ms</td><td>10,846 ms</td><td>418 ms</td><td>412 ms</td></tr><tr><td>2,000</td><td>22,592 ms</td><td>21,427 ms</td><td>1,060 ms</td><td>1,004 ms</td></tr><tr><td>5,000</td><td>54,407 ms</td><td>52,075 ms</td><td>2,663 ms</td><td>2,292 ms</td></tr><tr><td>10,000</td><td>107,651 ms</td><td>110,884 ms</td><td>4,514 ms</td><td>4,496 ms</td></tr></tbody></table><p>결과는 <code>saveAll</code>, <code>updateFirst</code>, <code>bulkOps(UNORDERED)</code>, <code>bulkOps(ORDERED)</code> 네 가지 방법에 대해 다양한 행(rows) 수에 따라 수행 시간(밀리초)을 비교합니다.</p><h3 id="분석-결과">분석 결과:</h3><h4 id="saveAll과-updateFirst"><code>saveAll과</code> <code>updateFirst</code></h4><ul><li>이 두 방법은 유사한 성능을 보입니다. 행의 수가 증가함에 따라 수행 시간이 선형적으로 증가하는 경향을 보이며, 대량의 데이터를 처리할 때 상대적으로 높은 지연 시간을 가집니다.</li><li><code>saveAll</code>과 <code>updateFirst</code> 메서드의 성능 차이는 유의미하지 않습니다. 따라서, 상대적으로 데이터 양이 적은 경우에는 upsert 기능을 제공하는 <code>saveAll</code>을 사용하여 로직을 단순화할 수 있습니다.</li><li>예제 코드에서는 <code>updateFirst</code> 메서드를 사용하여 기본 키(PK)를 기반으로 업데이트를 수행했습니다. 그러나 다른 키 값으로 조회를 진행할 경우, 조회 속도가 느려져 성능 차이가 발생할 수 있습니다.</li><li><code>saveAll</code> 메서드는 <code>Member</code> 객체의 모든 변경 사항을 반영합니다. 따라서, 특정 필드만을 명확하게 업데이트하고자 할 때는 <code>updateFirst</code>와 같은 메서드를 사용하여 정확한 업데이트 쿼리를 작성하는 것이 좋은 대안이 될 수 있습니다. 이 방법은 업데이트하고자 하는 필드를 직접 지정할 수 있어, 더 세밀한 데이터 업데이트 제어가 가능합니다.</li></ul><h4 id="bulkOps-UNORDERED-와-bulkOps-ORDERED"><code>bulkOps(UNORDERED)</code>와 <code>bulkOps(ORDERED)</code></h4><ul><li>이 방법들은 <code>saveAll</code>과 <code>updateFirst</code>에 비해 현저히 빠른 성능을 보입니다. 특히 <code>bulkOps(UNORDERED)</code>는 가장 빠른 처리 시간을 나타냅니다.</li><li><code>bulkOps(UNORDERED)</code>는 순서에 구애받지 않고 여러 작업을 동시에 처리할 수 있기 때문에, 대량의 데이터 처리에 더 효율적이며, 개별 작업들이 독립적으로 처리됩니다. 이는 특정 작업이 실패해도 다른 작업들에 영향을 주지 않는다는 것을 의미합니다.</li><li><code>bulkOps(ORDERED)</code>도 비교적 빠른 성능을 보이지만, <code>bulkOps(UNORDERED)</code>에 비해 약간 느린 경향이 있습니다. 이는 작업을 순서대로 처리해야 하는 부가적인 비용 때문 이며, 순차적으로 작업이 진행되기 때문에 한 작업이 실패하면 그 이후의 작업은 실행되지 않을 수 있습니다.</li><li><code>bulkOps(UNORDERED)</code>와 <code>bulkOps(ORDERED)</code> 방식은 10,000개의 데이터 모수까지는 큰 성능 차이가 나타나지 않았습니다. 그러나 데이터가 많은 노드에 분산되어 저장된 경우, 이 두 방식 사이에서 더 유의미한 성능 차이가 발생할 수 있습니다. 분산 환경에서는 데이터의 위치와 네트워크 지연이 성능에 영향을 미칠 수 있으며, 이러한 조건에서는 <code>bulkOps(UNORDERED)</code>와 <code>bulkOps(ORDERED)</code>의 처리 방식 차이가 더 명확하게 드러날 가능성이 있습니다.</li></ul><h3 id="결론">결론</h3><ul><li>소량의 데이터를 업데이트할 때는 <code>saveAll</code>과 <code>updateFirst</code> 메서드가 적합할 수 있습니다. 하지만 데이터 양이 많아질수록 이 두 방법의 성능은 상대적으로 감소합니다. 데이터 모수가 적은 경우, <code>saveAll</code>과 <code>updateFirst</code> 각각의 장단점이 있으므로, 특정 환경과 요구사항에 맞게 적절한 메서드를 선택하는 것이 중요합니다.</li><li>대량의 데이터 처리에는 <code>bulkOps</code> 메서드 사용이 효율적입니다. <code>bulkOps(UNORDERED)</code>와 <code>bulkOps(ORDERED)</code> 각각의 장단점이 존재하므로, 이 두 방식 중에서는 특정 환경과 요구사항에 맞게 적절한 옵션을 선택하는 것이 중요합니다.</li></ul><p>이러한 결과는 MongoDB 데이터 업데이트 전략을 선택할 때 중요한 고려 사항을 제공합니다. 데이터의 양, 업데이트의 복잡성, 순서의 중요성 등을 고려하여 적절한 방법을 선택할 필요가 있습니다.</p><h2 id="bulkOps-편의-기능-제공">bulkOps 편의 기능 제공</h2><p>이전 포스팅인 <a href="https://cheese10yun.github.io/spring-data-mongo-repository/">Spring Data MongoDB Repository 확장</a>에서는 <code>MongoCustomRepositorySupport</code>를 사용해 <code>MongoRepository</code>에 편의 기능을 추가하고, 보일러플레이트 코드를 줄이는 방법을 소개했습니다. 이 방법은 코드의 재사용성을 높이는 효과가 있습니다. 마찬가지로, <code>bulkOps</code>와 같은 반복적인 코드도 <code>MongoCustomRepositorySupport</code>에 통합함으로써 더 편리하게 기능을 제공할 수 있습니다. 이렇게 하면 <code>bulkOps</code> 관련 코드를 중앙화하여 관리 및 사용의 용이성을 향상시킬 수 있습니다.</p><h3 id="MongoCustomRepositorySupport을-통한-bulkOps-기능-제공">MongoCustomRepositorySupport을 통한 bulkOps 기능 제공</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MongoCustomRepositorySupport</span>&lt;<span class="type">T</span>&gt;(</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> documentClass: Class&lt;T&gt;,</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> mongoTemplate: MongoTemplate</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">bulkUpdate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        operations: <span class="type">List</span>&lt;<span class="type">Pair</span>&lt;() -&gt; <span class="type">Query</span>, ()</span></span> -&gt; Update&gt;&gt;, <span class="comment">// Query와 Update 생성자를 위한 람다 리스트</span></span><br><span class="line">        bulkMode: BulkOperations.BulkMode</span><br><span class="line">    ): BulkWriteResult &#123;</span><br><span class="line">        <span class="comment">// BulkOperations 객체를 생성합니다.</span></span><br><span class="line">        <span class="keyword">val</span> bulkOps = mongoTemplate.bulkOps(bulkMode, documentClass)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 제공된 리스트를 반복하면서 bulk 연산에 각 update를 추가합니다.</span></span><br><span class="line">        operations.forEach &#123; (queryCreator, updateCreator) -&gt;</span><br><span class="line">            bulkOps.updateOne(queryCreator.invoke(), updateCreator.invoke())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 모든 업데이트를 실행합니다.</span></span><br><span class="line">        <span class="keyword">return</span> bulkOps.execute()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemberCustomRepositoryImpl</span>(mongoTemplate: MongoTemplate) : MemberCustomRepository,</span><br><span class="line">    MongoCustomRepositorySupport&lt;Member&gt;(</span><br><span class="line">        Member::<span class="keyword">class</span>.java,</span><br><span class="line">        mongoTemplate</span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateName</span><span class="params">(listOf: <span class="type">List</span>&lt;<span class="type">Pair</span>&lt;() -&gt; <span class="type">Query</span>, ()</span></span> -&gt; Update&gt;&gt;, bulkMode: BulkOperations.BulkMode) &#123;</span><br><span class="line">        bulkUpdate(listOf, bulkMode)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `updateNmae 사용하는 곳`<span class="params">(pairs: <span class="type">List</span>&lt;<span class="type">Pair</span>&lt;() -&gt; <span class="type">Query</span>, ()</span></span> -&gt; Update&gt;&gt;, bulkMode: BulkOperations.BulkMode) &#123;</span><br><span class="line">    <span class="keyword">val</span> pair = listOf(</span><br><span class="line">        Pair(</span><br><span class="line">            first = &#123; Query(Criteria.<span class="keyword">where</span>(<span class="string">&quot;_id&quot;</span>).`<span class="keyword">is</span>`(ObjectId(<span class="string">&quot;id&quot;</span>))) &#125;,</span><br><span class="line">            second = &#123; Update().<span class="keyword">set</span>(<span class="string">&quot;name&quot;</span>, UUID.randomUUID().toString()) &#125;</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    memberRepository.updateName(pair, BulkOperations.BulkMode.UNORDERED)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드는 외부에서 정의된 쿼리와 업데이트 로직을 사용하여 데이터 업데이트를 수행합니다. 코드는 <code>Pair</code> 리스트를 통해 각 업데이트 작업에 필요한 <code>Query</code>와 <code>Update</code> 객체를 정의하고, 이를 <code>memberRepository</code>의 <code>updateName</code> 메서드에 전달하여 <code>BulkOperations.BulkMode.UNORDERED</code> 모드로 업데이트를 진행합니다. 이 방식은 업데이트 과정을 유연하게 처리할 수 있게 해줍니다.</p>]]></content:encoded>
      
      
      
      <category domain="https://cheese10yun.github.io/tags/Performance/">Performance</category>
      
      <category domain="https://cheese10yun.github.io/tags/Mongo/">Mongo</category>
      
      
      <comments>https://cheese10yun.github.io/spring-data-mongodb-update-performance/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MongoDB 다양한 테스트 케이스를 커버할 수 있는 테스트 데이터 셋업 방법</title>
      <link>https://cheese10yun.github.io/spring-data-mongo-test-setup/</link>
      <guid>https://cheese10yun.github.io/spring-data-mongo-test-setup/</guid>
      <pubDate>Sat, 11 Nov 2023 15:00:00 GMT</pubDate>
      
      <description>테스트 코드의 가치가 널리 인정받으며, 이제 그 필요성을 언급하는 것은 의미가 없어졌습니다. 테스트 코드의 가장 큰 매력은 바로 구현 코드에 대한 실시간 피드백을 제공하고, 이를 바탕으로 구현 코드를 지속적으로 개선해 나갈 수 있다는 점입니다.</description>
      
      
      
      <content:encoded><![CDATA[<p>테스트 코드의 가치가 널리 인정받으며, 이제 그 필요성을 언급하는 것은 의미가 없어졌습니다. 테스트 코드의 가장 큰 매력은 바로 구현 코드에 대한 실시간 피드백을 제공하고, 이를 바탕으로 구현 코드를 지속적으로 개선해 나갈 수 있다는 점입니다. 이 개념은 &quot;<a href="https://tech.kakaopay.com/post/mock-test-code-part-2/">실무에서 적용하는 테스트 코드 작성 방법과 노하우 Part 2: 테스트 코드로부터 피드백 받기</a>&quot;사내 기술 블로그에 이미 다룬 바 있습니다. 폭넓은 테스트를 작성하고 실행하기 위해서는 테스트 코드의 간편한 작성이 필수적입니다. 본 포스팅에서는 Spring Data MongoDB를 사용하여 Given 절의 데이터 셋업을 쉽게 하는 방법을 소개하겠습니다.</p><h2 id="데이터-셋업의-어려움과-중요성">데이터 셋업의 어려움과 중요성</h2><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/intellij-test/intellij-test/images/layer-4.png" alt=""></p><p>위 이미지처럼 주문 테스트 코드에 대한 다양한 테스트 케이스를 작성하기 위해서는 다양한 데이터를 셋업 하는 것은 필수적입니다. 다양한 테스트 케이스를 작성하지 못하면 테스트 케이스가 커버하는 범위가 좁아지며, 이로 인해 테스트 코드로부터 양질의 피드백을 받을 수 없게 됩니다. 따라서, <strong>테스트 코드를 쉽게 작성하고 다양한 시나리오를 손쉽게 검증할 수 있는 환경을 만드는 것이 중요합니다.</strong></p><p>스프링에서는 @Sql 어노테이션을 이용해 테스트 데이터를 간단히 셋업 할 수 있으며, 이를 통해 테스트 케이스를 원활하게 확장할 수 있습니다. 이에 관한 자세한 방법은 <a href="https://cheese10yun.github.io/sql-test/">Sql을 통해서 테스트 코드를 쉽게 작성하자&quot; 포스팅에서 설명하고 있습니다</a>. 해당 포스팅에서는 Sql을 활용하여 다양한 테스트 데이터를 쉽게 구성하는 방법을 제공합니다.</p><h2 id="SQL-파일을-이용한-데이터-셋업-방식">SQL 파일을 이용한 데이터 셋업 방식</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SqlGroup(</span></span><br><span class="line"><span class="meta">    Sql(</span></span><br><span class="line"><span class="meta">        value = [<span class="string">&quot;/schema.sql&quot;</span>, <span class="string">&quot;/order-setup.sql&quot;</span>, <span class="string">&quot;/coupon.sql&quot;</span>, <span class="string">&quot;product.sql&quot;</span>],</span></span><br><span class="line"><span class="meta">        config = SqlConfig(</span></span><br><span class="line"><span class="meta">            dataSource = <span class="string">&quot;dataSource&quot;</span>,</span></span><br><span class="line"><span class="meta">            transactionManager = <span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="meta">        ),</span></span><br><span class="line"><span class="meta">        executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD</span></span><br><span class="line"><span class="meta">    ),</span></span><br><span class="line"><span class="meta">    Sql(</span></span><br><span class="line"><span class="meta">        value = [<span class="string">&quot;/delete.sql&quot;</span>],</span></span><br><span class="line"><span class="meta">        config = SqlConfig(</span></span><br><span class="line"><span class="meta">            dataSource = <span class="string">&quot;dataSource&quot;</span>,</span></span><br><span class="line"><span class="meta">            transactionManager = <span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="meta">        ),</span></span><br><span class="line"><span class="meta">        executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `sql test code`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// test code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@SqlGroup</code> 어노테이션을 사용하면 <code>*.sql</code> 파일을 통해 테스트 데이터를 쉽게 준비할 수 있습니다. 이렇게 데이터를 만들면 setter를 막아 데이터 변경 단위를 논리적으로 제공하는 경우라면 큰 장점이 있습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/intellij-test/intellij-test/images/order-flow.003.jpeg" alt=""></p><ol><li>Order라는 엔티티 객체를 테스트 코드를 작성하려면 특정 Snapshot 상태로 만들어야 한다.</li><li>테스트 코드를 작성하는 구간은 상품 준비 -&gt; 배송시작 임으로 해당 객체를 상품 준비 상태로 만들어야 한다.</li><li>하지만 단순 setter가 없기 때문에 상품 준비 중 객체로 직접 만드는 것이 어려운 부분이 있다.</li></ol><p><strong>이런 경우 <code>*.sql</code> 파일을 활용하면, setter가 없는 객체에 대해서도 비즈니스 로직의 제약 없이 테스트 데이터를 간편하게 준비할 수 있어, 다양한 테스트 케이스를 쉽게 설정할 수 있습니다.</strong></p><h2 id="JSON-파일을-이용한-테스트-데이터-셋업-방식">JSON 파일을 이용한 테스트 데이터 셋업 방식</h2><p><code>@Sql</code>와 같은 어노테이 어노테이션을 제공해주지 않기 때문에 직접 만들어야 합니다. 우선 적용된 코드부터 살펴보도록하겠습니다.</p><h3 id="Document">Document</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document(collection = <span class="string">&quot;foo&quot;</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Foo</span>(</span><br><span class="line">    <span class="meta">@Field(<span class="string">&quot;address_detail&quot;</span>)</span></span><br><span class="line">    <span class="keyword">var</span> addressDetail: String</span><br><span class="line">) : Auditable()</span><br><span class="line"></span><br><span class="line"><span class="meta">@Document(collection = <span class="string">&quot;bar&quot;</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Bar</span>(</span><br><span class="line">    <span class="meta">@Field(<span class="string">&quot;email&quot;</span>)</span></span><br><span class="line">    <span class="keyword">var</span> email: String</span><br><span class="line">) : Auditable()</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Auditable</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">var</span> id: ObjectId? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = <span class="string">&quot;created_at&quot;</span>)</span></span><br><span class="line">    <span class="meta">@CreatedDate</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> createdAt: LocalDateTime</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(name = <span class="string">&quot;updated_at&quot;</span>)</span></span><br><span class="line">    <span class="meta">@LastModifiedDate</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> updatedAt: LocalDateTime</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>테스트를 위해 Foo, Bar Document를 간단한 필드들로 구성하며, <code>Auditable</code>을 상속하여 공통된 필드를 갖도록 합니다.</p><h3 id="MongoDataSetup-활용">MongoDataSetup 활용</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MongoTestSupport</span> <span class="comment">//(1)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@ActiveProfiles(<span class="string">&quot;test&quot;</span>)</span></span><br><span class="line"><span class="meta">@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MongoDataSetupExecutionListenerBeforeTest</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mongoTemplate: MongoTemplate</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// (2)</span></span><br><span class="line">    <span class="meta">@MongoDataSetup(</span></span><br><span class="line"><span class="meta">        // [&#123;<span class="string">&quot;address_detail&quot;</span>: <span class="string">&quot;1동, xxxx&quot;</span>&#125;, &#123;<span class="string">&quot;address_detail&quot;</span>: <span class="string">&quot;2동, xxxx&quot;</span>&#125;]</span></span><br><span class="line"><span class="meta">        jsonPath = <span class="string">&quot;/mongo-document-foo.json&quot;</span>, // (3)</span></span><br><span class="line"><span class="meta">        clazz = Foo::class, // (4)</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(<span class="string">&quot;MongoDataSetup 단일 테스트&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">mongoDataSetup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// when</span></span><br><span class="line">        <span class="keyword">val</span> fooDocuments = mongoTemplate.findAll&lt;Foo&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// then</span></span><br><span class="line">        then(fooDocuments).hasSize(<span class="number">2</span>)</span><br><span class="line">        then(fooDocuments).allSatisfy(</span><br><span class="line">            Consumer &#123;</span><br><span class="line">                then(it.id).isNotNull()</span><br><span class="line">                then(it.addressDetail).isIn(</span><br><span class="line">                    <span class="string">&quot;1동, xxxx&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;2동, xxxx&quot;</span></span><br><span class="line">                )</span><br><span class="line">                then(it.createdAt).isNotNull()</span><br><span class="line">                then(it.updatedAt).isNotNull()</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>적용된 코드부터 살펴보고 이후 구현 코드를 살펴보도록하겠습니다.</p><ul><li>(1): <code>@MongoTestSupport</code> 설정을 통해서 테스트 실행 리스너로 추가하여 데이터 설정을 자동화합니다.</li><li>(2): <code>@MongoDataSetup</code>은 해당 JSON 파일일을 읽어 MongoDB에 삽입합니다.</li><li>(3): <code>jsonPath</code>은 <code>test/resources/</code> 디렉토리에 위치한 JSON 파일의 경로를 지정합니다. 마지막으로,</li><li>(4): MongoDB에 삽입할 문서의 클래스를 명시합니다.</li></ul><p><img src="https://github.com/cheese10yun/blog-sample/blob/391a198fecd66e4f972e8b5cab31e4ce906acadb/mongo-study/images/mongo-test-1.png?raw=true" alt=""></p><p><code>@MongoDataSetup</code> 어노테이션을 사용하면, JSON 파일을 통해 MongoDB 테스트 데이터를 간편하게 설정할 수 있으며, 테스트 실행 시 Foo Document 객체가 성공적으로 저장되어 조회되는 것을 확인할 수 있습니다.</p><h2 id="테스트-데이터-셋업-코드">테스트 데이터 셋업 코드</h2><h3 id="MongoDataSetup">MongoDataSetup</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jsonPath json file의 경로를 작성한다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz MongoDB에 저장할 Document 객체</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> collectionName [clazz]와 Document collection 이름이 다른 경우 명시, 명시하지 않는 경우 [clazz]의 Document의 collection 으로 저장</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.example.mongostudy.MongoDataSetupExecutionListenerTest.mongoDataSetup</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.example.mongostudy.MongoDataSetupExecutionListenerTest.mongoDataSetupCollectionName</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.FUNCTION)</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.RUNTIME)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">MongoDataSetup</span>(</span><br><span class="line">    <span class="keyword">val</span> jsonPath: String,</span><br><span class="line">    <span class="keyword">val</span> clazz: KClass&lt;*&gt;,</span><br><span class="line">    <span class="keyword">val</span> collectionName: String = <span class="string">&quot;&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>단일 문서 데이터 셋업에 사용됩니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 여러 데이터를 셋업이 필요한 경우</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mongoDataSetup</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.example.mongostudy.MongoDataSetupExecutionListenerTest.mongoDataSetups</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.FUNCTION, AnnotationTarget.ANNOTATION_CLASS)</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.RUNTIME)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">MongoDataSetups</span>(<span class="keyword">vararg</span> <span class="keyword">val</span> mongoDataSetup: MongoDataSetup)</span><br></pre></td></tr></table></figure><p>여러 문서의 데이터 셋업 시 사용합니다.</p><h3 id="MongoDataSetupExecutionListener">MongoDataSetupExecutionListener</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MongoDataSetupExecutionListener</span> : <span class="type">TestExecutionListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 테스트 이전에 [MongoDataSetup]기반으로 Document를 생성한다.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">beforeTestMethod</span><span class="params">(testContext: <span class="type">TestContext</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> currentTestMethod = testContext.testMethod</span><br><span class="line">        <span class="keyword">val</span> mongoDataSetup = currentTestMethod.getAnnotation(MongoDataSetup::<span class="keyword">class</span>.java)</span><br><span class="line">        <span class="keyword">val</span> mongoDataSetups = currentTestMethod.getAnnotation(MongoDataSetups::<span class="keyword">class</span>.java)</span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            mongoDataSetup != <span class="literal">null</span> -&gt; insertDocuments(mongoDataSetup, testContext)</span><br><span class="line">            mongoDataSetups != <span class="literal">null</span> -&gt; mongoDataSetups.mongoDataSetup.forEach &#123; document -&gt;</span><br><span class="line">                insertDocuments(document, testContext)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 테스트가 끝난 이후 모든 모든 데이터를 삭제한다.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterTestMethod</span><span class="params">(testContext: <span class="type">TestContext</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> mongoTemplate = mongoTemplate(testContext)</span><br><span class="line">        <span class="keyword">val</span> currentTestMethod = testContext.testMethod</span><br><span class="line">        <span class="keyword">val</span> mongoDataSetup = currentTestMethod.getAnnotation(MongoDataSetup::<span class="keyword">class</span>.java)</span><br><span class="line">        <span class="keyword">val</span> mongoDataSetups = currentTestMethod.getAnnotation(MongoDataSetups::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">when</span> &#123;</span><br><span class="line">            mongoDataSetup != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">when</span> &#123;</span><br><span class="line">                    mongoDataSetup.collectionName.isEmpty() -&gt; mongoTemplate.dropCollection(mongoDataSetup.clazz.java)</span><br><span class="line">                    <span class="keyword">else</span> -&gt; mongoTemplate.dropCollection(mongoDataSetup.collectionName)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mongoDataSetups != <span class="literal">null</span> -&gt; &#123;</span><br><span class="line">                mongoDataSetups.mongoDataSetup.forEach &#123;</span><br><span class="line">                    <span class="keyword">when</span> &#123;</span><br><span class="line">                        it.collectionName.isEmpty() -&gt; mongoTemplate.dropCollection(it.clazz.java)</span><br><span class="line">                        <span class="keyword">else</span> -&gt; mongoTemplate.dropCollection(it.collectionName)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">insertDocuments</span><span class="params">(mongoDataSetup: <span class="type">MongoDataSetup</span>, testContext: <span class="type">TestContext</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> mongoTemplate = mongoTemplate(testContext)</span><br><span class="line">        <span class="keyword">val</span> documents = objectMapper.readValue&lt;List&lt;Any&gt;&gt;(</span><br><span class="line">            readFile(mongoDataSetup.jsonPath),</span><br><span class="line">            objectMapper.typeFactory.constructCollectionType(List::<span class="keyword">class</span>.java, mongoDataSetup.clazz.java)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> (documents.isNotEmpty()) &#123;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                mongoDataSetup.collectionName.isEmpty() -&gt; mongoTemplate.insertAll(documents)</span><br><span class="line">                <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 객체와, collectionName 일치하지 않는 경우는 collectionName을 지정하여 저장한다.</span></span><br><span class="line">                    <span class="keyword">for</span> (document <span class="keyword">in</span> documents) &#123;</span><br><span class="line">                        mongoTemplate.insert(document, mongoDataSetup.collectionName)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">mongoTemplate</span><span class="params">(testContext: <span class="type">TestContext</span>)</span></span>: MongoTemplate &#123;</span><br><span class="line">        <span class="keyword">return</span> testContext.applicationContext.getBean(MongoTemplate::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">readFile</span><span class="params">(path: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> String(ClassPathResource(path).inputStream.readBytes())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> objectMapper: ObjectMapper = ObjectMapper()</span><br><span class="line">        .registerKotlinModule()</span><br><span class="line">        .registerModules(JavaTimeModule(), Jdk8Module())</span><br><span class="line">        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="literal">false</span>)</span><br><span class="line">        .apply &#123; <span class="keyword">this</span>.propertyNamingStrategy = PropertyNamingStrategies.SNAKE_CASE &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MongoDataSetupExecutionListener</code>는 <code>TestExecutionListener</code>를 상속받아 구현되며, 스프링의 테스트 컨텍스트 프레임워크를 사용합니다. 이 리스너는 <code>beforeTestMethod</code>와 <code>afterTestMethod</code> 이벤트를 활용해 테스트 메소드 실행 전에 데이터를 준비하고, 실행 후에 데이터를 정리하는 기능을 수행합니다. 이 리스너는 <code>TestContext</code>에 의존하여 테스트 애플리케이션 컨텍스트에서 Bean을 쉽게 가져올 수 있으며, 예시에서는 <code>MongoTemplate</code>를 추출하는 데 사용되며 테스트 환경을 설정하거나, <strong>테스트 데이터를 초기화하거나, 테스트 결과를 정리하는 등의 작업을 자동화하는 데 유용합니다.</strong> <code>TestExecutionListener</code> 인터페이스를 구현하고, 스프링의 테스트에 <code>@TestExecutionListeners</code> 어노테이션을 사용하여 리스너를 등록함으로써 활용할 수 있습니다.</p><h3 id="TestExecutionListeners-리스너-등록-방법">TestExecutionListeners 리스너 등록 방법</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestExecutionListeners(</span></span><br><span class="line"><span class="meta">    listeners = [</span></span><br><span class="line"><span class="meta">        MongoDataSetupExecutionListener::class,</span></span><br><span class="line"><span class="meta">        DependencyInjectionTestExecutionListener::class</span></span><br><span class="line"><span class="meta">    ]</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.CLASS)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">MongoTestSupport</span></span><br></pre></td></tr></table></figure><p><code>MongoDataSetupExecutionListener</code>는 테스트에 필요한 리스너로, <code>TestExecutionListeners</code> 어노테이션을 통해 등록합니다. 이 과정을 단순화하기 위해 <code>MongoTestSupport</code> 어노테이션을 생성하여, <code>TestExecutionListeners</code> 설정을 손쉽게 적용할 수 있도록 합니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MongoTestSupport</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MongoDataSetupExecutionListenerBeforeTest</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>클래스 상단에 <code>@MongoTestSupport</code> 어노테이션을 추가함으로써, <code>MongoDataSetupExecutionListener</code>가 포함된 <code>TestExecutionListeners</code>를 쉽게 사용할 수 있습니다.</p><h3 id="MongoDataSetups-여러-문서의-데이터-셋업">MongoDataSetups 여러 문서의 데이터 셋업</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MongoDataSetups(</span></span><br><span class="line"><span class="meta">    MongoDataSetup(</span></span><br><span class="line"><span class="meta">        jsonPath = <span class="string">&quot;/mongo-document-bar.json&quot;</span>,</span></span><br><span class="line"><span class="meta">        clazz = Bar::class,</span></span><br><span class="line"><span class="meta">    ),</span></span><br><span class="line"><span class="meta">    MongoDataSetup(</span></span><br><span class="line"><span class="meta">        jsonPath = <span class="string">&quot;/mongo-document-foo.json&quot;</span>,</span></span><br><span class="line"><span class="meta">        clazz = Foo::class,</span></span><br><span class="line"><span class="meta">    ),</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(<span class="string">&quot;MongoDataSetups 여러개 테스트&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mongoDataSetups</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// when</span></span><br><span class="line">    <span class="keyword">val</span> fooDocuments = mongoTemplate.findAll&lt;Foo&gt;()</span><br><span class="line">    <span class="keyword">val</span> barDocuments = mongoTemplate.findAll&lt;Bar&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then</span></span><br><span class="line">    then(fooDocuments).hasSize(<span class="number">2</span>)</span><br><span class="line">    then(fooDocuments).allSatisfy(</span><br><span class="line">        Consumer &#123;</span><br><span class="line">            then(it.id).isNotNull()</span><br><span class="line">            then(it.addressDetail).isIn(</span><br><span class="line">                <span class="string">&quot;1동, xxxx&quot;</span>,</span><br><span class="line">                <span class="string">&quot;2동, xxxx&quot;</span></span><br><span class="line">            )</span><br><span class="line">            then(it.createdAt).isNotNull()</span><br><span class="line">            then(it.updatedAt).isNotNull()</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    then(barDocuments).hasSize(<span class="number">2</span>)</span><br><span class="line">    then(barDocuments).allSatisfy(</span><br><span class="line">        Consumer &#123;</span><br><span class="line">            then(it.id).isNotNull()</span><br><span class="line">            then(it.email).isIn(</span><br><span class="line">                <span class="string">&quot;aaa@asd.com&quot;</span>,</span><br><span class="line">                <span class="string">&quot;bbb@asd.com&quot;</span></span><br><span class="line">            )</span><br><span class="line">            then(it.createdAt).isNotNull()</span><br><span class="line">            then(it.updatedAt).isNotNull()</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MongoDataSetups</code>를 사용하면 다수의 <code>MongoDataSetup</code> 인스턴스를 결합하여 여러 문서를 쉽게 설정할 수 있습니다.</p><h3 id="MongoDataSetup-Projection-사용">MongoDataSetup Projection 사용</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">FooProjection</span>(</span><br><span class="line">    <span class="meta">@Field(<span class="string">&quot;address_detail&quot;</span>)</span></span><br><span class="line">    <span class="keyword">var</span> addressDetail: String,</span><br><span class="line">    <span class="meta">@Field(<span class="string">&quot;created_at&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> createdAt: LocalDateTime,</span><br><span class="line">    <span class="meta">@Field(<span class="string">&quot;updated_at&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> updatedAt: LocalDateTime</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@MongoDataSetup(</span></span><br><span class="line"><span class="meta">    jsonPath = <span class="string">&quot;/mongo-document-foo-projection.json&quot;</span>,</span></span><br><span class="line"><span class="meta">    clazz = FooProjection::class,</span></span><br><span class="line"><span class="meta">    collectionName = <span class="string">&quot;foo&quot;</span></span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisplayName(<span class="string">&quot;collectionName 기반으로 테스트&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mongoDataSetupCollectionName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// when</span></span><br><span class="line">    <span class="keyword">val</span> fooDocuments = mongoTemplate.findAll&lt;Foo&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then</span></span><br><span class="line">    then(fooDocuments).hasSize(<span class="number">2</span>)</span><br><span class="line">    then(fooDocuments).allSatisfy(</span><br><span class="line">        Consumer &#123;</span><br><span class="line">            then(it.id).isNotNull()</span><br><span class="line">            then(it.addressDetail).isIn(</span><br><span class="line">                <span class="string">&quot;1동, xxxx&quot;</span>,</span><br><span class="line">                <span class="string">&quot;2동, xxxx&quot;</span></span><br><span class="line">            )</span><br><span class="line">            then(it.createdAt).isNotNull()</span><br><span class="line">            then(it.updatedAt).isNotNull()</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Document 클래스가 아닌 Projection 객체를 이용해 데이터를 설정하려면, collectionName을 사용하여 명시적으로 컬렉션 이름을 지정함으로써 데이터를 원하는 컬렉션에 설정할 수 있습니다.</p><h2 id="편리성-제공">편리성 제공</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@ActiveProfiles(<span class="string">&quot;test&quot;</span>)</span></span><br><span class="line"><span class="meta">@TestInstance(TestInstance.Lifecycle.PER_CLASS)</span></span><br><span class="line"><span class="meta">@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)</span></span><br><span class="line"><span class="meta">@MongoTestSupport</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MongoApplicationTests</span></span><br></pre></td></tr></table></figure><p><code>@SpringBootTest</code> 어노테이션을 사용하는 테스트 클래스에 <code>@MongoTestSupport</code>를 추가함으로써, 개별 테스트 클래스에서 어노테이션을 중복하여 작성할 필요 없이 모든 테스트에 적용될 수 있으며, 이를 통해 Application Context를 효율적으로 재사용할 수 있습니다. 이러한 방식은 공통적인 설정을 일관되게 관리하는 데에도 도움이 됩니다.</p><h2 id="MongoDataSetup-적절한-사용">@MongoDataSetup 적절한 사용</h2><p><code>@Sql</code> 방식과 마찬가지로, JSON 파일 기반의 데이터 셋업에는 단점이 있습니다. 코드 내에서 객체를 생성하면 변수명과 주석을 통해 명확한 컨텍스트를 제공할 수 있는 반면, JSON 방식은 이러한 세부 사항을 전달하기 어렵습니다. 또한, <code>Document</code> 클래스의 코드 변경 시 관련 JSON 파일을 수동으로 업데이트해야 하는 번거로움이 있습니다.</p><p><strong><code>@MongoDataSetup</code>을 사용한 데이터 셋업은 주로 대량의 데이터나 복잡한 데이터 조합이 필요한 로직을 테스트할 때 추천됩니다.</strong> 이런 케이스에서는 코드로 직접 작성할 경우 유지보수 비용이 증가하고, 변수명과 주석을 통한 컨텍스트 전달에 한계가 있기 때문에, 이러한 상황에서 <code>@MongoDataSetup</code>의 사용이 효과적입니다.</p><h2 id="마무리">마무리</h2><p>이 포스팅에서는 MongoDB 데이터를 쉽게 설정하는 방법을 소개했지만, 강조하고 싶은 주요 메시지는 테스트 코드의 중요성과 함께 <strong>테스트 환경 구성의 중요성입니다.</strong> <strong>다양한 테스트 케이스를 작성할 수 있는 환경이 준비되어야만, 테스트 코드를 통해 유의미한 피드백을 얻고, 이를 통해 로직을 검증하고 코드 품질을 향상시킬 수 있습니다.</strong></p>]]></content:encoded>
      
      
      
      <category domain="https://cheese10yun.github.io/tags/Test/">Test</category>
      
      <category domain="https://cheese10yun.github.io/tags/Mongo/">Mongo</category>
      
      
      <comments>https://cheese10yun.github.io/spring-data-mongo-test-setup/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JPA 페이징 Performance 향상 방법</title>
      <link>https://cheese10yun.github.io/page-performance/</link>
      <guid>https://cheese10yun.github.io/page-performance/</guid>
      <pubDate>Mon, 04 Sep 2023 15:00:00 GMT</pubDate>
      
      <description>일반적으로 어드민 페이지와 같이 데이터를 테이블 뷰 형식으로 제공할 때, 페이징 기법을 사용하여 현재 페이지의 내용과 페이지 정보를 표시합니다. JPA를 활용하면 이러한 반복적인 코드 작성을 보다 쉽게 처리할 수 있습니다.</description>
      
      
      
      <content:encoded><![CDATA[<p>일반적으로 어드민 페이지와 같이 데이터를 테이블 뷰 형식으로 제공할 때, 페이징 기법을 사용하여 현재 페이지의 내용과 페이지 정보를 표시합니다. JPA를 활용하면 이러한 반복적인 코드 작성을 보다 쉽게 처리할 수 있습니다.</p><p>데이터 모수가 적고 단순한 구조로 데이터를 보여주는 경우라면 JPA에서 제공해 주는 방식으로 처리하는 것이 효율적일 수 있으나 데이터 모수가 많고 여러 테이블을 조인해서 표현해야 하는 데이터 구조라면 성능적인 이슈가 발생할 수 있습니다. 이러한 이슈와 성능 개선 방법에 대해 알아보겠습니다.</p><h2 id="Querydsl-페이징-처리-방식">Querydsl 페이징 처리 방식</h2><p>데이터 모수가 적고 간단한 조회 구조를 가질 때, Querydsl의 applyPagination 메서드를 활용하면 페이징 로직을 더 쉽게 작성할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrderCustomRepositoryImpl</span> : <span class="type">QuerydslRepositorySupport</span>(Order::<span class="keyword">class</span>.java), OrderCustomRepository &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findPagingBy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        address: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Page&lt;Order&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> query: JPAQuery&lt;Order&gt; = from(order).select(order).<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">        <span class="keyword">val</span> content: List&lt;Order&gt; = querydsl.applyPagination(pageable, query).fetch()</span><br><span class="line">        <span class="keyword">val</span> totalCount: <span class="built_in">Long</span> = query.fetchCount()</span><br><span class="line">        <span class="keyword">return</span> PageImpl(content, pageable, totalCount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://cheese10yun.github.io/spring-jpa-best-15/">Spring-JPA Best Practices step-15 - Querydsl를 이용해서 Repository 확장하기 (1)</a>에서 공유드린 QuerydslRepositorySupport를 기반으로 JpaRepository 확장시켜 페이징 로직을 구현했습니다.</p><p>세부 구현체에서는 조회 로직을 살펴보겠습니다. 이 과정에서 Querydsl를 기반으로 JPAQuery를 생성하며 필요한 조회 조건을 작성합니다. 그런 다음 해당 쿼리 객체를 이용하여 Content 조회와 전체 레코드 수 조회를 수행합니다. 마지막으로 각각의 실제 쿼리를 확인하게 됩니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> order0_.id           <span class="keyword">as</span> id1_4_,</span><br><span class="line">       ...</span><br><span class="line">       order0_.address      <span class="keyword">as</span> address4_4_,</span><br><span class="line">       order0_.created_at   <span class="keyword">as</span> created_2_4_,</span><br><span class="line">       order0_.updated_at   <span class="keyword">as</span> updated_3_4_,</span><br><span class="line"><span class="keyword">from</span> orders order0_</span><br><span class="line"><span class="keyword">where</span> order0_.address <span class="operator">=</span> ?</span><br><span class="line">limit ?, ?</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(order0_.id) <span class="keyword">as</span> col_0_0_</span><br><span class="line"><span class="keyword">from</span> orders order0_</span><br><span class="line"><span class="keyword">where</span> order0_.address <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure><p>Content 조회에 필요하 조회 쿼리와, 전체 레코드 조회에 필요한 쿼리를 JPAQuery를 통해 동일하게 사용이 가능하며, Querydsl의 applyPagination 메서드를 활용하여 offset 및 limit 관련 페이징 로직을 간단하게 구현할 수 있다는 큰 장점이 있습니다.</p><p>Querydsl의 applyPagination을 활용하면 페이징 조회 관련 로직을 간단하게 구현할 수 있어서 개발 생산성 측면에서 큰 이점이 있습니다. 그러나 모든 개발 결정 과정에서는 트레이드오프가 발생합니다. 편리한 기능을 즉시 활용할 수 있지만, 나중에는 추가 비용을 지불해야 하며 이 비용은 이자를 포함하여 청구될 수 있습니다.</p><p>어떤 문제가 발생하는지 살펴보겠습니다.</p><h3 id="Count-쿼리의-성능-문제">Count 쿼리의 성능 문제</h3><p>Count 쿼리는 특정 조건에 해당하는 전체 레코드 수를 조회하는 구조로, 데이터 총량이 증가하면 성능 저하가 발생할 수 있습니다. Content를 조회하는 limit 및 offset 쿼리는 빠르게 처리되는(offset 비교적 크지 않은 초반 구간) <strong>반면 Count 쿼리는 시간이 오래 걸려 병목 현상이 발생할 수 있습니다.</strong> 또한, 여러 테이블을 조인하여 데이터를 조회하는 경우에는 조회 조건이 복잡해져 정확한 인덱스를 타겟팅하기 어려운 이슈가 발생할 수 있습니다. <strong>이는 조회 조건에 부합하는 전체 레코드를 Count 하는 구조에서 필연적으로 발생할 수밖에 없는 문제입니다.</strong></p><h3 id="Count-쿼리의-최적화-문제">Count 쿼리의 최적화 문제</h3><p>이러한 문제 외에도 다른 문제가 있습니다. <strong>JPAQuery를 사용하여 Content 조회 쿼리와 레코드 Count 조회 쿼리를 동일하게 처리하면 성능적인 손해가 발생할 수 있습니다.</strong> 특히 여러 테이블을 조인하여 데이터를 조회하는 경우에 이 문제가 더 두드러집니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/query-dsl/docs/images/001.png" alt=""></p><p>주문 조회 시에 사용자 및 쿠폰 정보와 함께 내려줘야 하는 경우, 조회 필터에 주문 정보만 있는 상황에서 Count 쿼리를 실행할 때, 다른 테이블의 조인 없이 주문에 대한 Count 쿼리를 작성하는 것이 효율적입니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Content 조회 쿼리</span></span><br><span class="line"><span class="keyword">select</span> o.<span class="operator">*</span>,</span><br><span class="line">       u.<span class="operator">*</span>,</span><br><span class="line">       c.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> orders o</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">join</span> coupon c <span class="keyword">on</span> o.coupon_id <span class="operator">=</span> c.id</span><br><span class="line">         <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> o.user_id <span class="operator">=</span> u.id</span><br><span class="line"><span class="keyword">where</span> o.address <span class="operator">=</span> ? limit ?, ?</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Content 조회 쿼리를 그대로 사용하는 경우</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(o.id)</span><br><span class="line"><span class="keyword">from</span> orders o</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">join</span> coupon c <span class="keyword">on</span> o.coupon_id <span class="operator">=</span> c.id</span><br><span class="line">         <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> o.user_id <span class="operator">=</span> u.id</span><br><span class="line"><span class="keyword">where</span> o.address <span class="operator">=</span> ?</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Content 쿼리를 사용하지 않고 별도의 Count 조회 쿼리</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(o.id) ascount</span><br><span class="line"><span class="keyword">from</span> orders o</span><br><span class="line"><span class="keyword">where</span> o.address <span class="operator">=</span> ?</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>주문 조회에서 address 필드만 조회 조건에 해당된다면, 사용자 및 쿠폰 테이블과의 조인은 필요하지 않습니다. 이 경우, Count 쿼리를 간단하게 주문 테이블만을 대상으로 작성하는 것이 효율적입니다. 조회 조건이 복잡해질 때, Count 쿼리를 별도로 작성하는 것은 성능적으로 장점을 가질 수 있습니다.</p><h2 id="Querydsl-페이징-성능-최적화-방법">Querydsl 페이징 성능 최적화 방법</h2><h3 id="Slice-기반으로-Count-쿼리를-사용하지-않는-방법">Slice 기반으로 Count 쿼리를 사용하지 않는 방법</h3><p>JPA Slice 방식은 Page 방식과는 다르게 Total Count를 조회하는 count 쿼리를 실행하지 않는 방식입니다. 따라서 Total Count를 조회하는데 드는 시간을 절약하여 성능적인 이점을 얻을 수 있습니다. 페이지네이션 된 데이터를 불러올 때, 전체 데이터의 총개수를 파악하지 않고도 일부 데이터를 가져올 수 있기 때문에, Total Count가 필요 없는 상황에서 사용하면 성능을 향상시킬 수 있습니다. Slice 방식은 특히 대용량 데이터의 페이징 처리에 유용합니다. 이렇게 Slice 방식은 Total Count를 구하지 않고도 효율적인 페이징 처리를 가능하게 합니다. Total Count가 꼭 필요한 데이터인지 비즈니스 적으로 확인해 보고 꼭 필요한 데이터가 아니라면 사용하지 않는 것을 권장 드립니다.</p><h4 id="Slice-페이징-처리-방법">Slice 페이징 처리 방법</h4><p>Spring Data에서는 Slice를 통해 Total Count를 조회하지 않는 형태의 페이징 처리를 지원하고 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrderCustomRepositoryImpl</span> : <span class="type">QuerydslRepositorySupport</span>(Order::<span class="keyword">class</span>.java), OrderCustomRepository &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findSliceBy</span><span class="params">(pageable: <span class="type">Pageable</span>, address: <span class="type">String</span>)</span></span>: Slice&lt;Order&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> query: JPAQuery&lt;Order&gt; = from(order).select(order).<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">        <span class="keyword">val</span> content: List&lt;Order&gt; = querydsl.applyPagination(pageable, query).fetch()</span><br><span class="line">        <span class="keyword">val</span> hasNext: <span class="built_in">Boolean</span> = content.size &gt;= pageable.pageSize</span><br><span class="line">        <span class="keyword">return</span> SliceImpl(content, pageable, hasNext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Total Count가 필요 없기 때문에 생략 가능하며, 페이징 로직은 동일하게 <code>applyPagination</code>으로 진행하며 중요한 부분은 <code>hasNext</code>로 앞으로 더 읽을 데이터가 남아 있는지를 결정하는 변수입니다.</p><p>Order 데이터가 총 22개 있다고 가정하고 Page 0 ~ 4까지 Size 5개를 기준으로 조회한다고 가정해 보겠습니다.</p><table><thead><tr><th>Page</th><th>Size</th><th>Content</th><th style="text-align:left">Last</th></tr></thead><tbody><tr><td>0</td><td>5</td><td>5</td><td style="text-align:left">F</td></tr><tr><td>1</td><td>5</td><td>5</td><td style="text-align:left">F</td></tr><tr><td>2</td><td>5</td><td>5</td><td style="text-align:left">F</td></tr><tr><td>3</td><td>5</td><td>5</td><td style="text-align:left">F</td></tr><tr><td>4</td><td>5</td><td>3</td><td style="text-align:left">T</td></tr></tbody></table><p>Page 3까지는 Content가 설정한 크기만큼 반환되어 Last가 False 상태입니다. 그러나 Page 4에서는 남은 Content가 3개만 남아 있기 때문에 3개의 Content를 반환하고 Last가 True 상태로 변경됩니다. 이 방식은 코드로 작성하면 <code>content.size &gt;= pageable.pageSize</code>로 표현됩니다.</p><p>이 방식은 Total Count를 알 수 없기 때문에 Last 여부를 확인하기 위해서는 끝까지 데이터를 읽어봐야 정확히 판단할 수 있습니다. 반면에 Slice가 아닌 Page 방식에서는 Total Count를 알고 있어 다음 페이지를 읽지 않아도 Last 여부를 정확히 판단할 수 있습니다.</p><p>Order 데이터가 총 22개 있다고 가정하고 동일한 Size를 가지는 Page 방식과 Slice 방식을 비교해 보겠습니다.</p><table><thead><tr><th style="text-align:left">방식</th><th>Page</th><th>Size</th><th>Content</th><th style="text-align:left">Total Count</th><th style="text-align:left">Last</th></tr></thead><tbody><tr><td style="text-align:left">Page 방식</td><td>0</td><td>22</td><td>22</td><td style="text-align:left">22</td><td style="text-align:left">T</td></tr><tr><td style="text-align:left">Slice 방식</td><td>0</td><td>22</td><td>22</td><td style="text-align:left">알 수 없음</td><td style="text-align:left">F</td></tr><tr><td style="text-align:left">Slice 방식</td><td>0</td><td>23</td><td>22</td><td style="text-align:left">알 수 없음</td><td style="text-align:left">T</td></tr></tbody></table><p>Page 방식에서는 Total Count를 알고 있기 때문에 Content Size가 동일하다면 Last가 True로 판단할 수 있습니다. 반면에 Total Count을 모르는 Slice 방식에서는 다음 페이지까지 읽어보고 Content Size가 0인 것을 확인해야 Last가 True로 판단할 수 있습니다. Size를 23으로 조회하면 응답하는 Content는 22개로, 요청한 Size보다 Content가 작게 응답되므로 Last를 True로 판단할 수 있습니다.</p><p>이로 인해 발생하는 성능적인 차이를 언급하는 것은 아니며, Page 방식과 Slice 방식 간의 구조적인 차이를 설명하기 위해 이를 언급한 것입니다.</p><h4 id="Slice-사용이-용이한-구간">Slice 사용이 용이한 구간</h4><p>테이블 뷰 형식으로 페이징 처리를 할 때, Total Count가 반드시 필요하지 않은 경우에는 대부분 Slice 방식을 활용하는 것이 효율적입니다. 예를 들어, 최근 주문 정보를 기반으로 회원 등급을 업데이트하는 배치 기능을 개발한다고 가정해 보겠습니다. 이 경우에는 Count 쿼리를 사용할 필요가 없습니다. 단순히 필요한 데이터를 offset과 limit 방식으로 읽고 처리하기 때문에 Count 쿼리를 수행하지 않아도 됩니다. 더불어 Count 쿼리는 데이터양에 상관없이 일정 시간이 걸리는데, 데이터양이 많은 경우 Content 조회 쿼리보다 더 많은 시간이 소요됩니다. 그러므로 이 Count 쿼리를 계속 사용하는 것은 성능상의 부담을 가중시킬 수 있습니다.</p><p><a href="https://cheese10yun.github.io/spring-batch-http-page-item-reader/">Spring Batch HTTP Page Item Reader</a>처럼 대량의 데이터를 처리하는 배치 애플리케이션에 API를 제공할 때는 Slice 기반으로 제공하는 것이 성능적으로 이점이 있습니다.</p><h3 id="Count-쿼리의-최적화-하여-개선">Count 쿼리의 최적화 하여 개선</h3><p>Total Count가 반드시 필요한 경우에는 Slice 방식을 사용할 수 없으므로 Page 방식을 사용해야 합니다. 또한, 위에서 언급한 대로 여러 테이블을 조인해서 복잡한 데이터를 조회하는 경우에는 Count 쿼리를 별도로 구현하는 것이 성능적인 이점을 가져올 수 있습니다.</p><p><strong>이는 AbstractJPAQuery의 <code>fetchCount()</code>가 Deprecated된 이유 중 하나입니다.</strong> 조인이 많거나 복잡한 쿼리에서 fetchCount를 사용하면 성능 저하가 발생할 수 있기 때문에 다른 방식으로 count 쿼리를 실행하도록 권장하고 있습니다.</p><p>Count 쿼리를 별도로 구현하면 다음과 같이 구현할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrderCustomRepositoryImpl</span> : <span class="type">QuerydslRepositorySupport</span>(Order::<span class="keyword">class</span>.java), OrderCustomRepository &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findPagingBy</span><span class="params">(pageable: <span class="type">Pageable</span>, address: <span class="type">String</span>)</span></span>: Page&lt;Order&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> content: List&lt;Order&gt; = from(order)</span><br><span class="line">            .select(order)</span><br><span class="line">            .innerJoin(user).on(order.userId.eq(user.id))</span><br><span class="line">            .leftJoin(coupon).on(order.couponId.eq(coupon.id))</span><br><span class="line">            .<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">            .run &#123;</span><br><span class="line">                querydsl.applyPagination(pageable, <span class="keyword">this</span>).fetch()</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">val</span> totalCount: <span class="built_in">Long</span> = from(order)</span><br><span class="line">            .select(order.count())</span><br><span class="line">            .<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">            .fetchFirst()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> PageImpl(content, pageable, totalCount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PageImpl을 사용하여 Page 객체를 생성할 때, totalCount를 Content 쿼리와 별도로 구현하여 작성합니다. totalCount를 구할 때 SimpleExpression의 <code>count()</code>를 사용하여 질의합니다. 이러한 최종 쿼리를 살펴보겠습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Content 쿼리</span></span><br><span class="line"><span class="keyword">select</span> order0_.id           <span class="keyword">as</span> id1_4_,</span><br><span class="line">       order0_.created_at   <span class="keyword">as</span> created_2_4_,</span><br><span class="line">       order0_.updated_at   <span class="keyword">as</span> updated_3_4_,</span><br><span class="line">       order0_.address      <span class="keyword">as</span> address4_4_,</span><br><span class="line">       order0_.coupon_id    <span class="keyword">as</span> coupon_i5_4_,</span><br><span class="line">       order0_.order_number <span class="keyword">as</span> order_nu6_4_,</span><br><span class="line">       order0_.user_id      <span class="keyword">as</span> user_id7_4_</span><br><span class="line"><span class="keyword">from</span> orders order0_</span><br><span class="line">         <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">user</span> user1_ <span class="keyword">on</span> (order0_.user_id <span class="operator">=</span> user1_.id)</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> coupon coupon2_ <span class="keyword">on</span> (order0_.coupon_id <span class="operator">=</span> coupon2_.id)</span><br><span class="line"><span class="keyword">where</span> order0_.address <span class="operator">=</span> ? limit ?, ?</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Count 쿼리</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(order0_.id) <span class="keyword">as</span> col_0_0_</span><br><span class="line"><span class="keyword">from</span> orders order0_</span><br><span class="line"><span class="keyword">where</span> order0_.address <span class="operator">=</span> ? limit ?</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>Content 쿼리는 Content에 필요한 정보를 여러 테이블의 조인을 통해 가져오며, Count 쿼리는 조회 조건에 필요한 정보만 가져옵니다. 이때 <code>fetchCount()</code>가 Deprecated 되었기 때문에 <code>fetchFirst()</code>로 대체합니다. 이렇게 Count 쿼리를 따로 구현하면 Count 조건에 맞는 방식으로 최적화하여 성능적인 이점을 얻을 수 있습니다.</p><h3 id="Count-쿼리와-Content-쿼리-병렬-처리하여-개선-방법">Count 쿼리와 Content 쿼리 병렬 처리하여 개선 방법</h3><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/query-dsl/docs/images/002.png" alt=""></p><p>Count 쿼리가 1,000ms가 소요되고, 이후 Content 쿼리가 500ms 소요된다고 가정하면 총 1,500ms가 소요됩니다. 이 작업을 전체 데이터를 읽을 때마다 반복하면 성능상 문제가 발생할 수 있습니다. <strong>그러나 이 두 작업은 서로 의존성이 없기 때문에 병렬로 처리할 수 있습니다.</strong></p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/query-dsl/docs/images/003.png" alt=""></p><p>Count 쿼리와 Content 쿼리를 병렬로 처리하면 Count 쿼리가 소요 시간이 더 길더라도 1,000ms에 작업을 완료할 수 있습니다. 병렬 처리를 코루틴을 활용하여 구현해 보겠습니다.</p><h4 id="코루틴을-이용한-Count-쿼리와-Content-쿼리-병렬-처리">코루틴을 이용한 Count 쿼리와 Content 쿼리 병렬 처리</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrderCustomRepositoryImpl</span> : <span class="type">QuerydslRepositorySupport</span>(Order::<span class="keyword">class</span>.java), OrderCustomRepository &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findPagingBy</span><span class="params">(pageable: <span class="type">Pageable</span>, address: <span class="type">String</span>)</span></span>: Page&lt;Order&gt; = runBlocking &#123;</span><br><span class="line">        log.info(<span class="string">&quot;findPagingBy thread : <span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> content: Deferred&lt;List&lt;Order&gt;&gt; = async &#123;</span><br><span class="line">            log.info(<span class="string">&quot;content thread : <span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">            from(order)</span><br><span class="line">                .select(order)</span><br><span class="line">                .innerJoin(user).on(order.userId.eq(user.id))</span><br><span class="line">                .leftJoin(coupon).on(order.couponId.eq(coupon.id))</span><br><span class="line">                .<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">                .run &#123;</span><br><span class="line">                    querydsl.applyPagination(pageable, <span class="keyword">this</span>).fetch()</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> totalCount: Deferred&lt;<span class="built_in">Long</span>&gt; = async &#123;</span><br><span class="line">            log.info(<span class="string">&quot;count thread : <span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">            from(order)</span><br><span class="line">                .select(order.count())</span><br><span class="line">                .<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">                .fetchFirst()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PageImpl(content.await(), pageable, totalCount.await())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코루틴의 <code>async</code>와 <code>await</code>를 활용하여 Content 쿼리와 Count 쿼리를 병렬로 처리하였습니다. 이 과정에서 스레드 정보를 확인하기 위해 <code>Thread.currentThread()</code>를 사용하여 현재 스레드 정보를 출력합니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INFO [nio-8080-exec-1] repository.order.OrderApi  : thread api : Thread[http-nio-8080-exec-1,5,main]</span><br><span class="line">INFO [-1 @coroutine#1] OrderCustomRepositoryImpl  : findPagingBy thread : Thread[http-nio-8080-exec-1 @coroutine#1,5,main]</span><br><span class="line">INFO [-1 @coroutine#2] OrderCustomRepositoryImpl  : content thread : Thread[http-nio-8080-exec-1 @coroutine#2,5,main]</span><br><span class="line">INFO [-1 @coroutine#3] OrderCustomRepositoryImpl  : count thread : Thread[http-nio-8080-exec-1 @coroutine#3,5,main]</span><br></pre></td></tr></table></figure><p>OrderApi의 <code>exec-1</code> 요청 스레드를 기준으로 <code>findPagingBy</code>, <code>content</code>, <code>count</code> 스레드가 동일한 스레드를 사용하는 것을 확인할 수 있습니다. 이것은 <code>@coroutine#</code> 주석에서 볼 수 있듯이 한 스레드 내에서 여러 코루틴을 실행할 수 있는 구조를 의미합니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/query-dsl/docs/images/004.png" alt=""></p><p>VM Option에 <code>-Dkotlinx.coroutines.debug</code>을 추가하면 실행 중인 코루틴이 어떤 스레드에서 실행되는지를 확인할 수 있습니다.</p><h4 id="코루틴을-이용한-Count-쿼리와-Content-쿼리-병렬-처리-테스트">코루틴을 이용한 Count 쿼리와 Content 쿼리 병렬 처리 테스트</h4><p>Count 쿼리에는 <code>delay(1_000)</code>을 지정하여 1초 동안 대기하고, Content 쿼리에는 <code>delay(500)</code>을 지정하여 0.5초 동안 대기하며 테스트를 진행합니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `count 1,000ms, content 500ms delay test`<span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">            orderRepository.findPagingBy(</span><br><span class="line">                pageable = PageRequest.of(<span class="number">0</span>, <span class="number">10</span>),</span><br><span class="line">                address = <span class="string">&quot;address&quot;</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;time&#125;</span>ms&quot;</span>) <span class="comment">// 1,037ms</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>소요 시간은 1,037ms으로 정상적으로 병렬 처리가 되는 것을 확인할 수 있습니다.</p><h2 id="Support-객체를-통한-Querydsl-페이징-로직-개선">Support 객체를 통한 Querydsl 페이징 로직 개선</h2><p>Slice, Page 등과 같은 페이징 처리를 위한 중복 로직을 피하고 편리하게 사용하기 위해 해당 기능을 Support 객체에 관련 로직을 위임 시키겠습니다. <a href="https://cheese10yun.github.io/querydsl-support/">Querydsl Repository Support 활용</a>에서 소개한 QuerydslRepositorySupport를 기반으로 해당 기능을 한 번 더 감싸는 QuerydslCustomRepositorySupport 클래스에서 페이징 로직을 작성하겠습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">QuerydslCustomRepositorySupport</span>(domainClass: Class&lt;*&gt;) : QuerydslRepositorySupport(domainClass) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> queryFactory: JPAQueryFactory <span class="keyword">by</span> Delegates.notNull()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PersistenceContext</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setEntityManager</span><span class="params">(entityManager: <span class="type">EntityManager</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setEntityManager(entityManager)</span><br><span class="line">        <span class="keyword">this</span>.queryFactory = JPAQueryFactory(entityManager)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">select</span><span class="params">(expr: <span class="type">Expression</span>&lt;<span class="type">T</span>&gt;)</span></span>: JPAQuery&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> queryFactory.select(expr)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">selectFrom</span><span class="params">(from: <span class="type">EntityPath</span>&lt;<span class="type">T</span>&gt;)</span></span>: JPAQuery&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> queryFactory.selectFrom(from)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">from</span><span class="params">(path: <span class="type">EntityPath</span>&lt;*&gt;)</span></span>: JPAQuery&lt;*&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> queryFactory.from(path)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">applyPagination</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        contentQuery: <span class="type">Function</span>&lt;<span class="type">JPAQueryFactory</span>, JPAQuery&lt;T&gt;&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        countQuery: <span class="type">Function</span>&lt;<span class="type">JPAQueryFactory</span>, JPAQuery&lt;<span class="built_in">Long</span>&gt;&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Page&lt;T&gt; = runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> jpaContentQuery = contentQuery.apply(queryFactory)</span><br><span class="line">        <span class="keyword">val</span> content = async &#123; querydsl!!.applyPagination(pageable, jpaContentQuery).fetch() <span class="keyword">as</span> List&lt;T&gt; &#125;</span><br><span class="line">        <span class="keyword">val</span> count = async &#123; countQuery.apply(queryFactory).fetchFirst() &#125;</span><br><span class="line"></span><br><span class="line">        PageImpl(content.await(), pageable, count.await())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">applySlicePagination</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        query: <span class="type">Function</span>&lt;<span class="type">JPAQueryFactory</span>, JPAQuery&lt;T&gt;&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Slice&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> jpaContentQuery = query.apply(queryFactory)</span><br><span class="line">        <span class="keyword">val</span> content = querydsl!!.applyPagination(pageable, jpaContentQuery).fetch()</span><br><span class="line">        <span class="keyword">val</span> hasNext = content.size &gt;= pageable.pageSize</span><br><span class="line">        <span class="keyword">return</span> SliceImpl(content, pageable, hasNext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>queryFactory</code>에서 제공하는 <code>selectFrom</code> 및 <code>select</code> 기능도 제공하여 DSL 표현을 보다 다양하게 활용할 수 있도록 합니다.</li><li><code>applyPagination</code> 메서드는 페이징 처리를 위해 <code>Pageable</code> 객체와, Content 쿼리를 위한 <code>contentQuery</code>, Count 쿼리를 위한 <code>countQuery</code> 객체를 입력으로 받아서 코루틴을 활용하여 병렬 처리를 수행합니다.</li><li><code>applySlicePagination</code> 메서드는 Content 쿼리만을 수행하기 때문에 <code>query</code> 객체만을 입력으로 받고, content 조회와 <code>hasNext</code> 로직을 작성합니다.</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderCustomRepositoryImpl</span> : <span class="type">QuerydslCustomRepositorySupport</span>(Order::<span class="keyword">class</span>.java), OrderCustomRepository &#123;</span><br><span class="line">    <span class="comment">// Slice 로직 AS-IS</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findSliceBy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        address: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Slice&lt;Order&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> query: JPAQuery&lt;Order&gt; = from(order).select(order).<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">        <span class="keyword">val</span> content: List&lt;Order&gt; = querydsl!!.applyPagination(pageable, query).fetch()</span><br><span class="line">        <span class="keyword">val</span> hasNext: <span class="built_in">Boolean</span> = content.size &gt;= pageable.pageSize</span><br><span class="line">        <span class="keyword">return</span> SliceImpl(content, pageable, hasNext)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Slice 로직 TO-BE</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findSliceBy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        address: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Slice&lt;Order&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> applySlicePagination(</span><br><span class="line">            pageable = pageable,</span><br><span class="line">            query = &#123;</span><br><span class="line">                selectFrom(order).<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Page 로직 AS-IS</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findPagingBy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        address: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Page&lt;Order&gt; = runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> content: Deferred&lt;List&lt;Order&gt;&gt; = async &#123;</span><br><span class="line">            from(order)</span><br><span class="line">                .select(order)</span><br><span class="line">                .innerJoin(user).on(order.userId.eq(user.id))</span><br><span class="line">                .leftJoin(coupon).on(order.couponId.eq(coupon.id))</span><br><span class="line">                .<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">                .run &#123;</span><br><span class="line">                    querydsl!!.applyPagination(pageable, <span class="keyword">this</span>).fetch()</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> totalCount: Deferred&lt;<span class="built_in">Long</span>&gt; = async &#123;</span><br><span class="line">            from(order)</span><br><span class="line">                .select(order.count())</span><br><span class="line">                .<span class="keyword">where</span>(order.address.eq(address))</span><br><span class="line">                .fetchFirst()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PageImpl(content.await(), pageable, totalCount.await())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Page 로직 TO-BE</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findPaging</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        address: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: Page&lt;Order&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> applyPagination(</span><br><span class="line">            pageable = pageable,</span><br><span class="line">            contentQuery = &#123; selectFrom(order).<span class="keyword">where</span>(order.userId.isNotNull) &#125;,</span><br><span class="line">            countQuery = &#123; select(order.count()).from(order).<span class="keyword">where</span>(order.userId.isNotNull) &#125;,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>QuerydslCustomRepositorySupport</code> 객체를 상속받아 <code>applyPagination</code>과 <code>applySlicePagination</code> 로직을 작성합니다. 페이징 로직에 대한 처리는 모두 <code>QuerydslCustomRepositorySupport</code>로 위임되며, 각 Repository에서는 해당하는 쿼리만 작성하면 되는 구조로 코드가 훨씬 더 간결해졌습니다.</p>]]></content:encoded>
      
      
      
      <category domain="https://cheese10yun.github.io/tags/JPA/">JPA</category>
      
      <category domain="https://cheese10yun.github.io/tags/Performance/">Performance</category>
      
      <category domain="https://cheese10yun.github.io/tags/Querydsl/">Querydsl</category>
      
      <category domain="https://cheese10yun.github.io/tags/Coroutines/">Coroutines</category>
      
      
      <comments>https://cheese10yun.github.io/page-performance/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Kotlin 기반 경량 ORM Exposed 추가 정리 part 3</title>
      <link>https://cheese10yun.github.io/exposed-3/</link>
      <guid>https://cheese10yun.github.io/exposed-3/</guid>
      <pubDate>Sat, 01 Jul 2023 15:00:00 GMT</pubDate>
      
      <description>데이터 저장소에 값을 저장하는 경우, 저장된 데이터를 가져오는 경우 적절하게 컨버팅이 필요한 경우 JPA에서는 @Converter를 사용하면 손쉽게 제어할 수 있습니다. Exposed에서는 VarCharColumnType를 확장하는 방식으로 해당 기능을 사용할 수 있습니다.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Exposed-포스팅">Exposed 포스팅</h2><ul><li><a href="https://cheese10yun.github.io/exposed/">Kotlin 기반 경량 ORM Exposed</a></li><li><a href="https://cheese10yun.github.io/exposed-2/">Kotlin 기반 경량 ORM Exposed 추가 정리 part 2</a></li><li><a href="https://cheese10yun.github.io/exposed-3/">Kotlin 기반 경량 ORM Exposed 추가 정리 part 3</a></li></ul><h2 id="VarCharColumnType-기반-Converter">VarCharColumnType 기반 Converter</h2><p>데이터 저장소에 값을 저장하는 경우, 저장된 데이터를 가져오는 경우 적절하게 컨버팅이 필요한 경우 JPA에서는 <code>@Converter</code>를 사용하면 손쉽게 제어할 수 있습니다. Exposed에서는 <code>VarCharColumnType</code>를 확장하는 방식으로 해당 기능을 사용할 수 있습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Writers : LongIdTable(<span class="string">&quot;writer&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> name = varchar(<span class="string">&quot;name&quot;</span>, <span class="number">150</span>).nullable()</span><br><span class="line">    <span class="keyword">val</span> email = varchar(<span class="string">&quot;email&quot;</span>, <span class="number">150</span>)</span><br><span class="line">    <span class="keyword">val</span> createdAt = datetime(<span class="string">&quot;created_at&quot;</span>).clientDefault &#123; LocalDateTime.now() &#125;</span><br><span class="line">    <span class="keyword">val</span> updatedAt = datetime(<span class="string">&quot;updated_at&quot;</span>).clientDefault &#123; LocalDateTime.now() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>title</code> 필드에 불필요한 공백을 제거하고 싶은 Converter를 사용하고 싶은 경우에는 <code>VarCharColumnType</code>를 확장하여 구현이 가능합니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrimmingWhitespaceConverterColumnType</span>(length: <span class="built_in">Int</span>) : VarCharColumnType(colLength = length) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">valueToDB</span><span class="params">(value: <span class="type">Any</span>?)</span></span>: String? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> (value) &#123;</span><br><span class="line">            <span class="keyword">is</span> String -&gt; value.trim()</span><br><span class="line">            <span class="literal">null</span> -&gt; <span class="literal">null</span></span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;<span class="subst">$&#123;value::class.java.typeName&#125;</span> 타입은 Exposed 기반 컨버터에서 지원하지 않습니다.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">valueFromDB</span><span class="params">(value: <span class="type">Any</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> (value) &#123;</span><br><span class="line">            <span class="keyword">is</span> String -&gt; value.trim()</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;<span class="subst">$&#123;value::class.java.typeName&#125;</span> 타입은 Exposed 기반 컨버터에서 지원하지 않습니다.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>title</code> 칼럼은 <code>varchar</code> 타입이므로 <code>VarCharColumnType</code>을 통해서 구현합니다. <code>valueToDB</code>에는 데이터 저장소에 들어가는 컨버팅 로직을, <code>valueFromDB</code>에는 반대로 데이터베이스에서 가져온 데이터에 대한 컨버팅 로직을 작성합니다. 해당 로직은 공백을 제거하는 로직이므로 <code>trim()</code>을 사용해서 동일하게 구현합니다. 해당 코드는 String 자료형에만 동작하게 구성했으며 필요에 따라 추가적인 자료형을 추가하면 됩니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Writers : LongIdTable(<span class="string">&quot;writer&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> name = registerColumn&lt;String&gt;(</span><br><span class="line">        name = <span class="string">&quot;name&quot;</span>,</span><br><span class="line">        type = TrimmingWhitespaceConverterColumnType(length = <span class="number">150</span>)</span><br><span class="line">    ).nullable()</span><br><span class="line">    <span class="keyword">val</span> email = varchar(<span class="string">&quot;email&quot;</span>, <span class="number">150</span>)</span><br><span class="line">    <span class="keyword">val</span> createdAt = datetime(<span class="string">&quot;created_at&quot;</span>).clientDefault &#123; LocalDateTime.now() &#125;</span><br><span class="line">    <span class="keyword">val</span> updatedAt = datetime(<span class="string">&quot;updated_at&quot;</span>).clientDefault &#123; LocalDateTime.now() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerColumn을 활용해서 Converter 코드 TrimmingWhitespaceConverterColumnType을 적용시킵니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `Writers name test`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//given</span></span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">&quot;    yun kim   &quot;</span></span><br><span class="line">    <span class="keyword">val</span> email = <span class="string">&quot;email@asd.com&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//when</span></span><br><span class="line">    <span class="keyword">val</span> entityID = Writers.insertAndGetId &#123; writer -&gt;</span><br><span class="line">        writer[<span class="keyword">this</span>.name] = name</span><br><span class="line">        writer[<span class="keyword">this</span>.email] = email</span><br><span class="line">        writer[<span class="keyword">this</span>.createdAt] = LocalDateTime.now()</span><br><span class="line">        writer[<span class="keyword">this</span>.updatedAt] = LocalDateTime.now()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//then</span></span><br><span class="line">    <span class="keyword">val</span> writer = Writer.findById(entityID)!!</span><br><span class="line"></span><br><span class="line">    then(writer.name).isEqualTo(<span class="string">&quot;yun kim&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>앞뒤 공백이 있는 문자열에 대해서 실제 데이터베이스에 정상적으로 Converter 로직이 동작하는지 테스트를 진행해 보겠습니다. 실제 디버깅으로 확인해 보겠습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/exposed-study/docs/images/exposed-1.png" alt=""></p><p>앞뒤 공백이 제거된 <code>yun kim</code>으로 출력되는 것을 확인할 수 있습니다.</p><h2 id="Function">Function</h2><p>SQL Function 중 자주 사용되는 기능들에 대해서는 이미 구현하여 기능을 제공하고 있습니다. 집계 함수 Books.price.sum(), 문자열 함수 Books.title.lowerCase() 등이 있습니다. 예제 코드로 groupConcat을 살펴보겠습니다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `groupConcat`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//given</span></span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">&quot;yun kim&quot;</span></span><br><span class="line">    Writers.batchInsert((<span class="number">1.</span><span class="number">.2</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>[Writers.name] = name</span><br><span class="line">        <span class="keyword">this</span>[Writers.email] = <span class="string">&quot;email-<span class="subst">$&#123;it&#125;</span>@asd.com&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//when</span></span><br><span class="line">    <span class="keyword">val</span> groupConcat = Writers.email.groupConcat(distinct = <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">val</span> result = Writers</span><br><span class="line">        .slice(</span><br><span class="line">            groupConcat,</span><br><span class="line">            Writers.name,</span><br><span class="line">        )</span><br><span class="line">        .select &#123;</span><br><span class="line">            Writers.name eq name</span><br><span class="line">        &#125;</span><br><span class="line">        .map &#123;</span><br><span class="line">            Pair(</span><br><span class="line">                it[Writers.name], it[groupConcat]</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        .first()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//then</span></span><br><span class="line">    then(result.first).isEqualTo(name)</span><br><span class="line">    then(result.second).isEqualTo(<span class="string">&quot;email-1@asd.com,email-2@asd.com&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>email 필드는 varchar 타입이며 다음과 같은 구조이기 때문에 groupConcat을 메서드를 사용할 수 있습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/exposed-study/docs/images/exposed-column.png" alt=""></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">varchar</span><span class="params">(name: <span class="type">String</span>, length: <span class="type">Int</span>, collate: <span class="type">String</span>? = <span class="literal">null</span>)</span></span>: Column&lt;String&gt; = registerColumn(name, VarCharColumnType(length, collate))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : String?&gt;</span> Expression<span class="type">&lt;T&gt;</span>.<span class="title">groupConcat</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    separator: <span class="type">String</span>? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    distinct: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    orderBy: <span class="type">Array</span>&lt;<span class="type">Pair</span>&lt;<span class="type">Expression</span>&lt;*&gt;, SortOrder&gt;&gt; = emptyArray()</span></span></span><br><span class="line">): GroupConcat&lt;T&gt; = GroupConcat(<span class="keyword">this</span>, separator, distinct, orderBy = orderBy)</span><br></pre></td></tr></table></figure><p>Expression<String> 타입이기 때문에 groupConcat 확장 함수를 그대로 사용할 수 있습니다. 최종 SQL을 살펴보겠습니다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> GROUP_CONCAT(<span class="keyword">DISTINCT</span> writer.email), writer.`name`</span><br><span class="line"><span class="keyword">FROM</span> writer</span><br><span class="line"><span class="keyword">WHERE</span> writer.`name` <span class="operator">=</span> <span class="string">&#x27;yun kim&#x27;</span></span><br></pre></td></tr></table></figure><p>의도한 대로 <code>GROUP_CONCAT(DISTINCT writer.email)</code> SQL Function이 정상적으로 출력되었습니다. 그러면 조회한 데이터를 확인해 보겠습니다.</p><p><img src="https://raw.githubusercontent.com/cheese10yun/blog-sample/master/exposed-study/docs/images/exposed-2.png" alt=""></p><p>최종 결과로 문자열 <code>email-1@asd.com, email-2@asd.com</code>을 응답받은 것을 확인할 수 있습니다.</p>]]></content:encoded>
      
      
      
      <category domain="https://cheese10yun.github.io/tags/ORM/">ORM</category>
      
      <category domain="https://cheese10yun.github.io/tags/Kotlin/">Kotlin</category>
      
      <category domain="https://cheese10yun.github.io/tags/Exposed/">Exposed</category>
      
      
      <comments>https://cheese10yun.github.io/exposed-3/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
